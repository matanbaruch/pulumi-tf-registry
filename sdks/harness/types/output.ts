// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AutostoppingAwsProxyCertificates {
    /**
     * Certificate secret ID
     */
    certSecretId: string;
    /**
     * Private key secret ID
     */
    keySecretId: string;
}

export interface AutostoppingAzureProxyCertificates {
    /**
     * ID of certificate secret uploaded to vault
     */
    certSecretId: string;
    /**
     * ID of certificate key uploaded to vault
     */
    keySecretId: string;
}

export interface AutostoppingGcpProxyCertificates {
    /**
     * Certificate secret ID
     */
    certSecretId: string;
    /**
     * Private key secret ID
     */
    keySecretId: string;
}

export interface AutostoppingRuleEcsContainer {
    /**
     * Name of cluster in which service belong to
     */
    cluster: string;
    /**
     * Region of cluster
     */
    region: string;
    /**
     * Name of service to be onboarded
     */
    service: string;
    /**
     * Desired number of tasks on warming up a rule
     */
    taskCount?: number;
}

export interface AutostoppingRuleEcsDepend {
    /**
     * Number of seconds the rule should wait after warming up the dependent rule
     */
    delayInSec?: number;
    /**
     * Rule id of the dependent rule
     */
    ruleId: number;
}

export interface AutostoppingRuleEcsHttp {
    /**
     * Id of the proxy
     */
    proxyId: string;
}

export interface AutostoppingRuleRdsDatabase {
    /**
     * ID of the database
     */
    id: string;
    /**
     * Region to which database belong to
     */
    region: string;
}

export interface AutostoppingRuleRdsDepend {
    /**
     * Number of seconds the rule should wait after warming up the dependent rule
     */
    delayInSec?: number;
    /**
     * Rule id of the dependent rule
     */
    ruleId: number;
}

export interface AutostoppingRuleRdsTcp {
    /**
     * Additional tcp forwarding rules
     */
    forwardRules?: outputs.AutostoppingRuleRdsTcpForwardRule[];
    /**
     * Id of the Proxy
     */
    proxyId: string;
}

export interface AutostoppingRuleRdsTcpForwardRule {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port: number;
}

export interface AutostoppingRuleVmDepend {
    /**
     * Number of seconds the rule should wait after warming up the dependent rule
     */
    delayInSec?: number;
    /**
     * Rule id of the dependent rule
     */
    ruleId: number;
}

export interface AutostoppingRuleVmFilter {
    /**
     * Regions of instances that needs to be managed using the AutoStopping rules
     */
    regions?: string[];
    /**
     * Tags of instances that needs to be managed using the AutoStopping rules
     */
    tags?: outputs.AutostoppingRuleVmFilterTag[];
    /**
     * Ids of instances that needs to be managed using the AutoStopping rules
     */
    vmIds: string[];
    /**
     * Zones of instances that needs to be managed using the AutoStopping rules
     */
    zones?: string[];
}

export interface AutostoppingRuleVmFilterTag {
    key: string;
    value: string;
}

export interface AutostoppingRuleVmHttp {
    /**
     * Health Check Details
     */
    healths?: outputs.AutostoppingRuleVmHttpHealth[];
    /**
     * Id of the proxy
     */
    proxyId: string;
    /**
     * Routing configuration used to access the instances
     */
    routings?: outputs.AutostoppingRuleVmHttpRouting[];
}

export interface AutostoppingRuleVmHttpHealth {
    /**
     * API path to use for health check
     */
    path?: string;
    /**
     * Health check port on the VM
     */
    port: number;
    /**
     * Protocol can be http or https
     */
    protocol: string;
    /**
     * Lower limit for acceptable status code
     */
    statusCodeFrom?: number;
    /**
     * Upper limit for acceptable status code
     */
    statusCodeTo?: number;
    /**
     * Health check timeout
     */
    timeout?: number;
}

export interface AutostoppingRuleVmHttpRouting {
    /**
     * Organization Identifier for the Entity
     */
    action?: string;
    /**
     * Port on the proxy
     */
    sourcePort?: number;
    /**
     * Source protocol of the proxy can be http or https
     */
    sourceProtocol: string;
    /**
     * Port on the VM
     */
    targetPort?: number;
    /**
     * Target protocol of the instance can be http or https
     */
    targetProtocol: string;
}

export interface AutostoppingRuleVmTcp {
    /**
     * Additional tcp forwarding rules
     */
    forwardRules?: outputs.AutostoppingRuleVmTcpForwardRule[];
    /**
     * Id of the Proxy
     */
    proxyId: string;
    /**
     * RDP configuration
     */
    rdps?: outputs.AutostoppingRuleVmTcpRdp[];
    /**
     * SSH configuration
     */
    sshes?: outputs.AutostoppingRuleVmTcpSsh[];
}

export interface AutostoppingRuleVmTcpForwardRule {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port: number;
}

export interface AutostoppingRuleVmTcpRdp {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port?: number;
}

export interface AutostoppingRuleVmTcpSsh {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port?: number;
}

export interface AutostoppingScheduleRepeat {
    /**
     * List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
     */
    days: string[];
    /**
     * Ending time of schedule action on the day. Defaults to 24:00Hrs unless specified. Accepted format is HH:MM. Eg : 20:00 for 8pm
     */
    endTime?: string;
    /**
     * Starting time of schedule action on the day. Defaults to 00:00Hrs unless specified. Accepted format is HH:MM. Eg : 13:15 for 01:15pm
     */
    startTime?: string;
}

export interface CloudproviderAwsAssumeCrossAccountRole {
    /**
     * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
     */
    externalId?: string;
    /**
     * This is an IAM role in the target deployment AWS account.
     */
    roleArn: string;
}

export interface CloudproviderAwsUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface CloudproviderDatacenterUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface CloudproviderGcpUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface CloudproviderKubernetesAuthentication {
    /**
     * Delegate selectors to inherit the GCP credentials from.
     */
    delegateSelectors?: string[];
    /**
     * Service account configuration for connecting to the Kubernetes cluster
     */
    oidc?: outputs.CloudproviderKubernetesAuthenticationOidc;
    /**
     * Username and password for authentication to the cluster
     */
    serviceAccount?: outputs.CloudproviderKubernetesAuthenticationServiceAccount;
    /**
     * Username and password for authentication to the cluster
     */
    usernamePassword?: outputs.CloudproviderKubernetesAuthenticationUsernamePassword;
}

export interface CloudproviderKubernetesAuthenticationOidc {
    /**
     * Name of the Harness secret containing the client ID for the cluster.
     */
    clientIdSecretName: string;
    /**
     * Name of the Harness secret containing the client secret for the cluster.
     */
    clientSecretSecretName?: string;
    /**
     * URL of the identity provider to use.
     */
    identityProviderUrl: string;
    /**
     * URL of the Kubernetes master to connect to.
     */
    masterUrl: string;
    /**
     * Name of the Harness secret containing the password for the cluster.
     */
    passwordSecretName: string;
    /**
     * Scopes to request from the identity provider.
     */
    scopes?: string[];
    /**
     * Username for authentication to the cluster. This can be the username itself or the ID of a harness secret.
     */
    username: string;
}

export interface CloudproviderKubernetesAuthenticationServiceAccount {
    /**
     * Name of the Harness secret containing the CA certificate for the cluster.
     */
    caCertificateSecretName?: string;
    /**
     * URL of the Kubernetes master to connect to.
     */
    masterUrl: string;
    /**
     * Name of the Harness secret containing the service account token for the cluster.
     */
    serviceAccountTokenSecretName: string;
}

export interface CloudproviderKubernetesAuthenticationUsernamePassword {
    /**
     * URL of the Kubernetes master to connect to.
     */
    masterUrl: string;
    /**
     * Name of the Harness secret containing the password for the cluster.
     */
    passwordSecretName: string;
    /**
     * Username for authentication to the cluster
     */
    username?: string;
    /**
     * Name of the Harness secret containing the username for authentication to the cluster
     */
    usernameSecretName?: string;
}

export interface CloudproviderKubernetesUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The name of the service
     */
    serviceName?: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: string;
    /**
     * The value of the service variable
     */
    value: string;
}

export interface GetAutostoppingAwsProxyCertificates {
    /**
     * Certificate secret ID
     */
    certSecretId: string;
    /**
     * Private key secret ID
     */
    keySecretId: string;
}

export interface GetAutostoppingAzureProxyCertificates {
    /**
     * ID of certificate secret uploaded to vault
     */
    certSecretId: string;
    /**
     * ID of certificate key uploaded to vault
     */
    keySecretId: string;
}

export interface GetAutostoppingGcpProxyCertificates {
    /**
     * Certificate secret ID
     */
    certSecretId: string;
    /**
     * Private key secret ID
     */
    keySecretId: string;
}

export interface GetAutostoppingRuleEcsContainer {
    /**
     * Name of cluster in which service belong to
     */
    cluster: string;
    /**
     * Region of cluster
     */
    region: string;
    /**
     * Name of service to be onboarded
     */
    service: string;
    /**
     * Desired number of tasks on warming up a rule
     */
    taskCount?: number;
}

export interface GetAutostoppingRuleEcsDepend {
    /**
     * Number of seconds the rule should wait after warming up the dependent rule
     */
    delayInSec?: number;
    /**
     * Rule id of the dependent rule
     */
    ruleId: number;
}

export interface GetAutostoppingRuleEcsHttp {
    /**
     * Id of the proxy
     */
    proxyId: string;
}

export interface GetAutostoppingRuleRdsDatabase {
    /**
     * ID of the database
     */
    id: string;
    /**
     * Region to which database belong to
     */
    region: string;
}

export interface GetAutostoppingRuleRdsDepend {
    /**
     * Number of seconds the rule should wait after warming up the dependent rule
     */
    delayInSec?: number;
    /**
     * Rule id of the dependent rule
     */
    ruleId: number;
}

export interface GetAutostoppingRuleRdsTcp {
    /**
     * Additional tcp forwarding rules
     */
    forwardRules?: outputs.GetAutostoppingRuleRdsTcpForwardRule[];
    /**
     * Id of the Proxy
     */
    proxyId: string;
}

export interface GetAutostoppingRuleRdsTcpForwardRule {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port: number;
}

export interface GetAutostoppingRuleVmDepend {
    /**
     * Number of seconds the rule should wait after warming up the dependent rule
     */
    delayInSec?: number;
    /**
     * Rule id of the dependent rule
     */
    ruleId: number;
}

export interface GetAutostoppingRuleVmFilter {
    /**
     * Regions of instances that needs to be managed using the AutoStopping rules
     */
    regions?: string[];
    /**
     * Tags of instances that needs to be managed using the AutoStopping rules
     */
    tags?: outputs.GetAutostoppingRuleVmFilterTag[];
    /**
     * Ids of instances that needs to be managed using the AutoStopping rules
     */
    vmIds: string[];
    /**
     * Zones of instances that needs to be managed using the AutoStopping rules
     */
    zones?: string[];
}

export interface GetAutostoppingRuleVmFilterTag {
    key: string;
    value: string;
}

export interface GetAutostoppingRuleVmHttp {
    /**
     * Health Check Details
     */
    healths?: outputs.GetAutostoppingRuleVmHttpHealth[];
    /**
     * Id of the proxy
     */
    proxyId: string;
    /**
     * Routing configuration used to access the instances
     */
    routings?: outputs.GetAutostoppingRuleVmHttpRouting[];
}

export interface GetAutostoppingRuleVmHttpHealth {
    /**
     * API path to use for health check
     */
    path?: string;
    /**
     * Health check port on the VM
     */
    port: number;
    /**
     * Protocol can be http or https
     */
    protocol: string;
    /**
     * Lower limit for acceptable status code
     */
    statusCodeFrom?: number;
    /**
     * Upper limit for acceptable status code
     */
    statusCodeTo?: number;
    /**
     * Health check timeout
     */
    timeout?: number;
}

export interface GetAutostoppingRuleVmHttpRouting {
    /**
     * Organization Identifier for the Entity
     */
    action?: string;
    /**
     * Port on the proxy
     */
    sourcePort?: number;
    /**
     * Source protocol of the proxy can be http or https
     */
    sourceProtocol: string;
    /**
     * Port on the VM
     */
    targetPort?: number;
    /**
     * Target protocol of the instance can be http or https
     */
    targetProtocol: string;
}

export interface GetAutostoppingRuleVmTcp {
    /**
     * Additional tcp forwarding rules
     */
    forwardRules?: outputs.GetAutostoppingRuleVmTcpForwardRule[];
    /**
     * Id of the Proxy
     */
    proxyId: string;
    /**
     * RDP configuration
     */
    rdps?: outputs.GetAutostoppingRuleVmTcpRdp[];
    /**
     * SSH configuration
     */
    sshes?: outputs.GetAutostoppingRuleVmTcpSsh[];
}

export interface GetAutostoppingRuleVmTcpForwardRule {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port: number;
}

export interface GetAutostoppingRuleVmTcpRdp {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port?: number;
}

export interface GetAutostoppingRuleVmTcpSsh {
    /**
     * Port to listen on the proxy
     */
    connectOn?: number;
    /**
     * Port to listen on the vm
     */
    port?: number;
}

export interface GetAutostoppingScheduleRepeat {
    days: string[];
    endTime: string;
    startTime: string;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface GetEnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: string;
    /**
     * The value of the service variable
     */
    value: string;
}

export interface GetGitConnectorCommitDetail {
    authorEmailId: string;
    authorName: string;
    message: string;
}

export interface GetPlatformCcmFiltersFilterProperty {
    filterType: string;
    tags: string[];
}

export interface GetPlatformConnectorAppdynamicsApiToken {
    clientId: string;
    clientSecretRef: string;
}

export interface GetPlatformConnectorAppdynamicsUsernamePassword {
    passwordRef: string;
    username: string;
}

export interface GetPlatformConnectorArtifactoryCredential {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorAwsCrossAccountAccess {
    externalId: string;
    roleArn: string;
}

export interface GetPlatformConnectorAwsEqualJitterBackoffStrategy {
    baseDelay: number;
    maxBackoffTime: number;
    retryCount: number;
}

export interface GetPlatformConnectorAwsFixedDelayBackoffStrategy {
    fixedBackoff: number;
    retryCount: number;
}

export interface GetPlatformConnectorAwsFullJitterBackoffStrategy {
    baseDelay: number;
    maxBackoffTime: number;
    retryCount: number;
}

export interface GetPlatformConnectorAwsInheritFromDelegate {
    delegateSelectors: string[];
    region: string;
}

export interface GetPlatformConnectorAwsIrsa {
    delegateSelectors: string[];
    region: string;
}

export interface GetPlatformConnectorAwsManual {
    accessKey: string;
    accessKeyPlainText: string;
    accessKeyRef: string;
    delegateSelectors: string[];
    region: string;
    secretKeyRef: string;
}

export interface GetPlatformConnectorAwsOidcAuthentication {
    delegateSelectors: string[];
    iamRoleArn: string;
    region: string;
}

export interface GetPlatformConnectorAwsSecretManagerCredential {
    assumeRoles: outputs.GetPlatformConnectorAwsSecretManagerCredentialAssumeRole[];
    inheritFromDelegate: boolean;
    manuals: outputs.GetPlatformConnectorAwsSecretManagerCredentialManual[];
}

export interface GetPlatformConnectorAwsSecretManagerCredentialAssumeRole {
    duration: number;
    externalId: string;
    roleArn: string;
}

export interface GetPlatformConnectorAwsSecretManagerCredentialManual {
    accessKeyRef: string;
    secretKeyRef: string;
}

export interface GetPlatformConnectorAwsccCrossAccountAccess {
    externalId: string;
    roleArn: string;
}

export interface GetPlatformConnectorAwskmsCredential {
    assumeRoles: outputs.GetPlatformConnectorAwskmsCredentialAssumeRole[];
    inheritFromDelegate: boolean;
    manuals: outputs.GetPlatformConnectorAwskmsCredentialManual[];
}

export interface GetPlatformConnectorAwskmsCredentialAssumeRole {
    duration: number;
    externalId: string;
    roleArn: string;
}

export interface GetPlatformConnectorAwskmsCredentialManual {
    accessKeyRef: string;
    secretKeyRef: string;
}

export interface GetPlatformConnectorAzureCloudCostBillingExportSpec {
    containerName: string;
    directoryName: string;
    reportName: string;
    storageAccountName: string;
    subscriptionId: string;
}

export interface GetPlatformConnectorAzureCloudProviderCredential {
    azureInheritFromDelegateDetails: outputs.GetPlatformConnectorAzureCloudProviderCredentialAzureInheritFromDelegateDetail[];
    azureManualDetails: outputs.GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetail[];
    type: string;
}

export interface GetPlatformConnectorAzureCloudProviderCredentialAzureInheritFromDelegateDetail {
    auths: outputs.GetPlatformConnectorAzureCloudProviderCredentialAzureInheritFromDelegateDetailAuth[];
}

export interface GetPlatformConnectorAzureCloudProviderCredentialAzureInheritFromDelegateDetailAuth {
    azureMsiAuthUas: outputs.GetPlatformConnectorAzureCloudProviderCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUa[];
    type: string;
}

export interface GetPlatformConnectorAzureCloudProviderCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUa {
    clientId: string;
}

export interface GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetail {
    applicationId: string;
    auths: outputs.GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetailAuth[];
    tenantId: string;
}

export interface GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetailAuth {
    azureClientKeyCerts: outputs.GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetailAuthAzureClientKeyCert[];
    azureClientSecretKeys: outputs.GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetailAuthAzureClientSecretKey[];
    type: string;
}

export interface GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetailAuthAzureClientKeyCert {
    certificateRef: string;
}

export interface GetPlatformConnectorAzureCloudProviderCredentialAzureManualDetailAuthAzureClientSecretKey {
    secretRef: string;
}

export interface GetPlatformConnectorBitbucketApiAuthentication {
    tokenRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorBitbucketCredential {
    https: outputs.GetPlatformConnectorBitbucketCredentialHttp[];
    sshes: outputs.GetPlatformConnectorBitbucketCredentialSsh[];
}

export interface GetPlatformConnectorBitbucketCredentialHttp {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorBitbucketCredentialSsh {
    sshKeyRef: string;
}

export interface GetPlatformConnectorCustomSecretManagerTemplateInput {
    environmentVariables: outputs.GetPlatformConnectorCustomSecretManagerTemplateInputEnvironmentVariable[];
}

export interface GetPlatformConnectorCustomSecretManagerTemplateInputEnvironmentVariable {
    default: boolean;
    name: string;
    type: string;
    value: string;
}

export interface GetPlatformConnectorCustomhealthsourceHeader {
    encryptedValueRef: string;
    key: string;
    value: string;
    valueEncrypted: boolean;
}

export interface GetPlatformConnectorCustomhealthsourceParam {
    encryptedValueRef: string;
    key: string;
    value: string;
    valueEncrypted: boolean;
}

export interface GetPlatformConnectorDockerCredential {
    executeOnDelegate: boolean;
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorElasticsearchApiToken {
    clientId: string;
    clientSecretRef: string;
}

export interface GetPlatformConnectorElasticsearchUsernamePassword {
    passwordRef: string;
    username: string;
}

export interface GetPlatformConnectorGcpCloudCostBillingExportSpec {
    dataSetId: string;
    tableId: string;
}

export interface GetPlatformConnectorGcpInheritFromDelegate {
    delegateSelectors: string[];
}

export interface GetPlatformConnectorGcpManual {
    delegateSelectors: string[];
    secretKeyRef: string;
}

export interface GetPlatformConnectorGcpOidcAuthentication {
    delegateSelectors: string[];
    gcpProjectId: string;
    providerId: string;
    serviceAccountEmail: string;
    workloadPoolId: string;
}

export interface GetPlatformConnectorGitCredential {
    https: outputs.GetPlatformConnectorGitCredentialHttp[];
    sshes: outputs.GetPlatformConnectorGitCredentialSsh[];
}

export interface GetPlatformConnectorGitCredentialHttp {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorGitCredentialSsh {
    sshKeyRef: string;
}

export interface GetPlatformConnectorGithubApiAuthentication {
    githubApps: outputs.GetPlatformConnectorGithubApiAuthenticationGithubApp[];
    tokenRef: string;
}

export interface GetPlatformConnectorGithubApiAuthenticationGithubApp {
    applicationId: string;
    applicationIdRef: string;
    installationId: string;
    installationIdRef: string;
    privateKeyRef: string;
}

export interface GetPlatformConnectorGithubCredential {
    https: outputs.GetPlatformConnectorGithubCredentialHttp[];
    sshes: outputs.GetPlatformConnectorGithubCredentialSsh[];
}

export interface GetPlatformConnectorGithubCredentialHttp {
    anonymouses: outputs.GetPlatformConnectorGithubCredentialHttpAnonymouse[];
    githubApps: outputs.GetPlatformConnectorGithubCredentialHttpGithubApp[];
    tokenRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorGithubCredentialHttpAnonymouse {
}

export interface GetPlatformConnectorGithubCredentialHttpGithubApp {
    applicationId: string;
    applicationIdRef: string;
    installationId: string;
    installationIdRef: string;
    privateKeyRef: string;
}

export interface GetPlatformConnectorGithubCredentialSsh {
    sshKeyRef: string;
}

export interface GetPlatformConnectorGitlabApiAuthentication {
    tokenRef: string;
}

export interface GetPlatformConnectorGitlabCredential {
    https: outputs.GetPlatformConnectorGitlabCredentialHttp[];
    sshes: outputs.GetPlatformConnectorGitlabCredentialSsh[];
}

export interface GetPlatformConnectorGitlabCredentialHttp {
    passwordRef: string;
    tokenRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorGitlabCredentialSsh {
    sshKeyRef: string;
}

export interface GetPlatformConnectorHelmCredential {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorJdbcCredential {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorJenkinsAuth {
    jenkinsBearerTokens: outputs.GetPlatformConnectorJenkinsAuthJenkinsBearerToken[];
    jenkinsUserNamePasswords: outputs.GetPlatformConnectorJenkinsAuthJenkinsUserNamePassword[];
    type: string;
}

export interface GetPlatformConnectorJenkinsAuthJenkinsBearerToken {
    tokenRef: string;
}

export interface GetPlatformConnectorJenkinsAuthJenkinsUserNamePassword {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorJiraAuth {
    authType: string;
    personalAccessTokens: outputs.GetPlatformConnectorJiraAuthPersonalAccessToken[];
    usernamePasswords: outputs.GetPlatformConnectorJiraAuthUsernamePassword[];
}

export interface GetPlatformConnectorJiraAuthPersonalAccessToken {
    patRef: string;
}

export interface GetPlatformConnectorJiraAuthUsernamePassword {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorKubernetesClientKeyCert {
    caCertRef: string;
    clientCertRef: string;
    clientKeyAlgorithm: string;
    clientKeyPassphraseRef: string;
    clientKeyRef: string;
    masterUrl: string;
}

export interface GetPlatformConnectorKubernetesInheritFromDelegate {
    delegateSelectors: string[];
}

export interface GetPlatformConnectorKubernetesOpenidConnect {
    clientIdRef: string;
    issuerUrl: string;
    masterUrl: string;
    passwordRef: string;
    scopes: string[];
    secretRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorKubernetesServiceAccount {
    masterUrl: string;
    serviceAccountTokenRef: string;
}

export interface GetPlatformConnectorKubernetesUsernamePassword {
    masterUrl: string;
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorNexusCredential {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorOciHelmCredential {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorPdcHost {
    attributes: {[key: string]: string};
    hostname: string;
}

export interface GetPlatformConnectorPrometheusHeader {
    encryptedValueRef: string;
    key: string;
    value: string;
    valueEncrypted: boolean;
}

export interface GetPlatformConnectorRancherBearerToken {
    /**
     * Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * The URL of the Rancher cluster.
     */
    rancherUrl: string;
}

export interface GetPlatformConnectorServiceNowAuth {
    adfs: outputs.GetPlatformConnectorServiceNowAuthAdf[];
    authType: string;
    refreshTokens: outputs.GetPlatformConnectorServiceNowAuthRefreshToken[];
    usernamePasswords: outputs.GetPlatformConnectorServiceNowAuthUsernamePassword[];
}

export interface GetPlatformConnectorServiceNowAuthAdf {
    adfsUrl: string;
    certificateRef: string;
    clientIdRef: string;
    privateKeyRef: string;
    resourceIdRef: string;
}

export interface GetPlatformConnectorServiceNowAuthRefreshToken {
    clientIdRef: string;
    clientSecretRef: string;
    refreshTokenRef: string;
    scope: string;
    tokenUrl: string;
}

export interface GetPlatformConnectorServiceNowAuthUsernamePassword {
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorSpotPermanentToken {
    apiTokenRef: string;
    delegateSelectors: string[];
    executeOnDelegate: boolean;
    spotAccountId: string;
    spotAccountIdRef: string;
}

export interface GetPlatformConnectorTasCredential {
    tasManualDetails: outputs.GetPlatformConnectorTasCredentialTasManualDetail[];
    type: string;
}

export interface GetPlatformConnectorTasCredentialTasManualDetail {
    endpointUrl: string;
    passwordRef: string;
    username: string;
    usernameRef: string;
}

export interface GetPlatformConnectorTerraformCloudCredential {
    apiTokens: outputs.GetPlatformConnectorTerraformCloudCredentialApiToken[];
}

export interface GetPlatformConnectorTerraformCloudCredentialApiToken {
    apiTokenRef: string;
}

export interface GetPlatformDbSchemaSchemaSource {
    connector: string;
    location: string;
    repo: string;
}

export interface GetPlatformEnvironmentClustersMappingCluster {
    /**
     * agent identifier of the cluster (include scope prefix)
     */
    agentIdentifier?: string;
    /**
     * identifier of the cluster
     */
    identifier?: string;
    /**
     * name of the cluster
     */
    name?: string;
    /**
     * scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
     */
    scope?: string;
}

export interface GetPlatformEnvironmentGitDetails {
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Load environment yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Repo name of remote environment
     */
    repoName: string;
}

export interface GetPlatformEnvironmentListEnvironment {
    identifier: string;
    name: string;
}

export interface GetPlatformFileStoreFileCreatedBy {
    email: string;
    name: string;
}

export interface GetPlatformFileStoreFileLastModifiedBy {
    email: string;
    name: string;
}

export interface GetPlatformFileStoreFolderCreatedBy {
    email: string;
    name: string;
}

export interface GetPlatformFileStoreFolderLastModifiedBy {
    email: string;
    name: string;
}

export interface GetPlatformFiltersFilterProperty {
    filterType: string;
    tags: string[];
}

export interface GetPlatformGitopsAgentDeployYamlProxy {
    /**
     * HTTP proxy settings for the GitOps agent.
     */
    http?: string;
    /**
     * HTTPS proxy settings for the GitOps agent.
     */
    https?: string;
    /**
     * Password for the proxy.
     */
    password?: string;
    /**
     * Username for the proxy.
     */
    username?: string;
}

export interface GetPlatformGitopsAgentMetadata {
    highAvailability: boolean;
    isNamespaced: boolean;
    namespace: string;
}

export interface GetPlatformGitopsApplicationsApplication {
    metadatas: outputs.GetPlatformGitopsApplicationsApplicationMetadata[];
    specs: outputs.GetPlatformGitopsApplicationsApplicationSpec[];
}

export interface GetPlatformGitopsApplicationsApplicationMetadata {
    annotations: {[key: string]: string};
    clusterName: string;
    finalizers: string[];
    generateName: string;
    generation: string;
    labels: {[key: string]: string};
    name: string;
    namespace: string;
    ownerReferences: outputs.GetPlatformGitopsApplicationsApplicationMetadataOwnerReference[];
    uid: string;
}

export interface GetPlatformGitopsApplicationsApplicationMetadataOwnerReference {
    apiVersion: string;
    blockOwnerDeletion: boolean;
    controller: boolean;
    kind: string;
    name: string;
    uid: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpec {
    destinations: outputs.GetPlatformGitopsApplicationsApplicationSpecDestination[];
    sources: outputs.GetPlatformGitopsApplicationsApplicationSpecSource[];
    syncPolicies: outputs.GetPlatformGitopsApplicationsApplicationSpecSyncPolicy[];
}

export interface GetPlatformGitopsApplicationsApplicationSpecDestination {
    name: string;
    namespace: string;
    server: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSource {
    chart: string;
    directories: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceDirectory[];
    helms: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceHelm[];
    ksonnets: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceKsonnet[];
    kustomizes: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceKustomize[];
    path: string;
    plugins: outputs.GetPlatformGitopsApplicationsApplicationSpecSourcePlugin[];
    repoUrl: string;
    targetRevision: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceDirectory {
    exclude: string;
    include: string;
    jsonnets: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnet[];
    recurse: boolean;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnet {
    extVars: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar[];
    libs: string[];
    tlas: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla[];
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar {
    code: boolean;
    name: string;
    value: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla {
    code: boolean;
    name: string;
    value: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceHelm {
    fileParameters: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceHelmFileParameter[];
    parameters: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceHelmParameter[];
    passCredentials: boolean;
    releaseName: string;
    valueFiles: string[];
    values: string;
    version: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceHelmFileParameter {
    name: string;
    path: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceHelmParameter {
    forceString: boolean;
    name: string;
    value: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceKsonnet {
    environment: string;
    parameters: outputs.GetPlatformGitopsApplicationsApplicationSpecSourceKsonnetParameter[];
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceKsonnetParameter {
    component: string;
    name: string;
    value: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourceKustomize {
    commonAnnotations: {[key: string]: string};
    commonLabels: {[key: string]: string};
    forceCommonAnnotations: boolean;
    forceCommonLabels: boolean;
    images: string[];
    namePrefix: string;
    nameSuffix: string;
    version: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourcePlugin {
    envs: outputs.GetPlatformGitopsApplicationsApplicationSpecSourcePluginEnv[];
    name: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSourcePluginEnv {
    name: string;
    value: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSyncPolicy {
    automateds: outputs.GetPlatformGitopsApplicationsApplicationSpecSyncPolicyAutomated[];
    retries: outputs.GetPlatformGitopsApplicationsApplicationSpecSyncPolicyRetry[];
    syncOptions: string[];
}

export interface GetPlatformGitopsApplicationsApplicationSpecSyncPolicyAutomated {
    allowEmpty: boolean;
    prune: boolean;
    selfHeal: boolean;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSyncPolicyRetry {
    backoffs: outputs.GetPlatformGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff[];
    limit: string;
}

export interface GetPlatformGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff {
    duration: string;
    factor: string;
    maxDuration: string;
}

export interface GetPlatformGitopsClusterRequest {
    clusters: outputs.GetPlatformGitopsClusterRequestCluster[];
    tags: string[];
    updatedFields: string[];
    upsert: boolean;
}

export interface GetPlatformGitopsClusterRequestCluster {
    annotations: {[key: string]: string};
    clusterResources: boolean;
    configs: outputs.GetPlatformGitopsClusterRequestClusterConfig[];
    infos: outputs.GetPlatformGitopsClusterRequestClusterInfo[];
    labels: {[key: string]: string};
    name: string;
    namespaces: string[];
    project: string;
    refreshRequestedAts: outputs.GetPlatformGitopsClusterRequestClusterRefreshRequestedAt[];
    server: string;
    shard: string;
}

export interface GetPlatformGitopsClusterRequestClusterConfig {
    awsClusterName: string;
    bearerToken: string;
    clusterConnectionType: string;
    execProviderConfigs: outputs.GetPlatformGitopsClusterRequestClusterConfigExecProviderConfig[];
    password: string;
    roleARN: string;
    tlsClientConfigs: outputs.GetPlatformGitopsClusterRequestClusterConfigTlsClientConfig[];
    username: string;
}

export interface GetPlatformGitopsClusterRequestClusterConfigExecProviderConfig {
    apiVersion: string;
    args: string[];
    command: string;
    env: {[key: string]: string};
    installHint: string;
}

export interface GetPlatformGitopsClusterRequestClusterConfigTlsClientConfig {
    caData: string;
    certData: string;
    insecure: boolean;
    keyData: string;
    serverName: string;
}

export interface GetPlatformGitopsClusterRequestClusterInfo {
    apiVersions: string[];
    applicationsCount: string;
    cacheInfos: outputs.GetPlatformGitopsClusterRequestClusterInfoCacheInfo[];
    connectionStates: outputs.GetPlatformGitopsClusterRequestClusterInfoConnectionState[];
    serverVersion: string;
}

export interface GetPlatformGitopsClusterRequestClusterInfoCacheInfo {
    apisCount: string;
    lastCacheSyncTime: string;
    resourcesCount: string;
}

export interface GetPlatformGitopsClusterRequestClusterInfoConnectionState {
    attemptedAts: outputs.GetPlatformGitopsClusterRequestClusterInfoConnectionStateAttemptedAt[];
    message: string;
    status: string;
}

export interface GetPlatformGitopsClusterRequestClusterInfoConnectionStateAttemptedAt {
    nanos: number;
    seconds: string;
}

export interface GetPlatformGitopsClusterRequestClusterRefreshRequestedAt {
    nanos: number;
    seconds: string;
}

export interface GetPlatformGitopsGnupgRequest {
    /**
     * Public key details.
     */
    publickeys?: outputs.GetPlatformGitopsGnupgRequestPublickey[];
    /**
     * Indicates if the GnuPG Key should be inserted if not present or updated if present.
     */
    upsert?: boolean;
}

export interface GetPlatformGitopsGnupgRequestPublickey {
    /**
     * Fingerprint is the fingerprint of the key
     */
    fingerprint?: string;
    /**
     * KeyData holds the raw key data, in base64 encoded format.
     */
    keyData?: string;
    /**
     * KeyID specifies the key ID, in hexadecimal string format.
     */
    keyId?: string;
    /**
     * Owner holds the owner identification, e.g. a name and e-mail address
     */
    owner?: string;
    /**
     * SubType holds the key's sub type
     */
    subType?: string;
    /**
     * Trust holds the level of trust assigned to this key
     */
    trust?: string;
}

export interface GetPlatformGitopsRepoCredCred {
    /**
     * Specifies whether helm-oci support should be enabled for this repo.
     */
    enableOci?: boolean;
    /**
     * Specifies the GitHub API URL for GitHub app authentication.
     */
    githubAppEnterpriseBaseUrl?: string;
    /**
     * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
     */
    githubAppId?: string;
    /**
     * Specifies the ID of the installed GitHub App for GitHub app authentication.
     */
    githubAppInstallationId?: string;
    /**
     * github_app_private_key specifies the private key PEM data for authentication via GitHub app.
     */
    githubAppPrivateKey?: string;
    /**
     * Password or PAT to be used for authenticating the remote repository.
     */
    password?: string;
    /**
     * SSH Key in PEM format for authenticating the repository. Used only for Git repository.
     */
    sshPrivateKey?: string;
    /**
     * Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
     */
    tlsClientCertData?: string;
    /**
     * Private key in PEM format for authenticating at the repo server. This is used for mTLS.
     */
    tlsClientCertKey?: string;
    /**
     * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
     */
    type?: string;
    /**
     * URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
     */
    url?: string;
    /**
     * Username to be used for authenticating the remote repository.
     */
    username?: string;
}

export interface GetPlatformGitopsRepositoryRepo {
    connectionType: string;
    enableLfs: boolean;
    enableOci: boolean;
    githubAppEnterpriseBaseUrl: string;
    githubAppId: string;
    githubAppInstallationId: string;
    githubAppPrivateKey: string;
    inheritedCreds: boolean;
    insecure: boolean;
    insecureIgnoreHostKey: boolean;
    name: string;
    password: string;
    project: string;
    proxy: string;
    repo: string;
    sshPrivateKey: string;
    tlsClientCertData: string;
    tlsClientCertKey: string;
    type_: string;
    username: string;
}

export interface GetPlatformGitopsRepositoryUpdateMask {
    /**
     * The set of field mask paths.
     */
    paths?: string[];
}

export interface GetPlatformInfrastructureGitDetails {
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * If the Entity is to be fetched from cache
     */
    loadFromCache: string;
    /**
     * Load Infrastructure yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Repo name of remote Infrastructure
     */
    repoName: string;
}

export interface GetPlatformInputSetGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branchName: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * Connector reference for Parent Entity (Pipeline).
     */
    parentEntityConnectorRef: string;
    /**
     * Repository name for Parent Entity (Pipeline).
     */
    parentEntityRepoName: string;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface GetPlatformManualFreezeCurrentOrUpcomingWindow {
    endTime: number;
    startTime: number;
}

export interface GetPlatformManualFreezeFreezeWindow {
    duration: string;
    endTime: string;
    recurrences: outputs.GetPlatformManualFreezeFreezeWindowRecurrence[];
    startTime: string;
    timeZone: string;
}

export interface GetPlatformManualFreezeFreezeWindowRecurrence {
    recurrenceSpecs: outputs.GetPlatformManualFreezeFreezeWindowRecurrenceRecurrenceSpec[];
    type: string;
}

export interface GetPlatformManualFreezeFreezeWindowRecurrenceRecurrenceSpec {
    until: string;
    value: number;
}

export interface GetPlatformOverridesGitDetails {
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Load service yaml from fallback branch
     */
    loadFromCache: boolean;
    /**
     * Load service yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Repo name of remote service override
     */
    repoName: string;
}

export interface GetPlatformPermissionsPermission {
    action: string;
    allowedScopeLevels: string[];
    identifier: string;
    includeInAllRoles: boolean;
    name: string;
    resourceType: string;
    status: string;
}

export interface GetPlatformPipelineFiltersFilterProperty {
    description: string;
    filterType: string;
    moduleProperties: outputs.GetPlatformPipelineFiltersFilterPropertyModuleProperty[];
    name: string;
    pipelineIdentifiers: string[];
    pipelineTags: {[key: string]: string}[];
    tags: string[];
}

export interface GetPlatformPipelineFiltersFilterPropertyModuleProperty {
    cds: outputs.GetPlatformPipelineFiltersFilterPropertyModulePropertyCd[];
    cis: outputs.GetPlatformPipelineFiltersFilterPropertyModulePropertyCi[];
}

export interface GetPlatformPipelineFiltersFilterPropertyModulePropertyCd {
    artifactDisplayNames: string[];
    deploymentTypes: string;
    environmentNames: string[];
    serviceNames: string[];
}

export interface GetPlatformPipelineFiltersFilterPropertyModulePropertyCi {
    branch: string;
    buildType: string;
    ciExecutionInfos: outputs.GetPlatformPipelineFiltersFilterPropertyModulePropertyCiCiExecutionInfo[];
    repoNames: string;
    tag: string;
}

export interface GetPlatformPipelineFiltersFilterPropertyModulePropertyCiCiExecutionInfo {
    event: string;
    pullRequests: outputs.GetPlatformPipelineFiltersFilterPropertyModulePropertyCiCiExecutionInfoPullRequest[];
}

export interface GetPlatformPipelineFiltersFilterPropertyModulePropertyCiCiExecutionInfoPullRequest {
    sourceBranch: string;
    targetBranch: string;
}

export interface GetPlatformPipelineGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branchName: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface GetPlatformPipelineListPipeline {
    identifier: string;
    name: string;
}

export interface GetPlatformPolicysetPolicy {
    /**
     * Account Identifier of the account
     */
    identifier: string;
    /**
     * Policy failure response - 'warning' for continuation, 'error' for exit
     */
    severity: string;
}

export interface GetPlatformProjectListProject {
    identifier: string;
    name: string;
}

export interface GetPlatformRepoRuleBranchBypass {
    /**
     * Allow users with repository edit permission to bypass.
     */
    repoOwners?: boolean;
    /**
     * List of user ids with who can bypass.
     */
    userIds?: string[];
}

export interface GetPlatformRepoRuleBranchPattern {
    /**
     * Should rule apply to default branch of the repository.
     */
    defaultBranch?: boolean;
    /**
     * Globstar branch patterns on which rules will NOT be applied.
     */
    excludes?: string[];
    /**
     * Globstar branch patterns on which rules will be applied.
     */
    includes?: string[];
}

export interface GetPlatformRepoRuleBranchPolicy {
    /**
     * Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
     */
    allowMergeStrategies?: string[];
    /**
     * Only allow users with bypass permission to create matching branches.
     */
    blockBranchCreation?: boolean;
    /**
     * Only allow users with bypass permission to delete matching branches.
     */
    blockBranchDeletion?: boolean;
    /**
     * Automatically delete the source branch of a pull request after it is merged.
     */
    deleteBranchOnMerge?: boolean;
    /**
     * Require approval on pull requests from one reviewer for each codeowner rule.
     */
    requireCodeOwners?: boolean;
    /**
     * Require re-approval when there are new changes in the pull request.
     */
    requireLatestCommitApproval?: boolean;
    /**
     * Require approval on pull requests from a minimum number of reviewers.
     */
    requireMinimumApprovalCount?: number;
    /**
     * Require all request for changes have been resolved.
     */
    requireNoChangeRequest?: boolean;
    /**
     * Do not allow any changes to matching branches without a pull request.
     */
    requirePullRequest?: boolean;
    /**
     * All comments on a pull request must be resolved before it can be merged.
     */
    requireResolveAllComments?: boolean;
    /**
     * Selected status checks must pass before a pull request can be merged.
     */
    requireStatusChecks?: string[];
}

export interface GetPlatformRepoSource {
    /**
     * The host URL for the import source.
     */
    host?: string;
    /**
     * The password for authentication when importing.
     */
    password?: string;
    /**
     * The full identifier of the repository on the SCM provider's platform.
     */
    repo?: string;
    /**
     * The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
     */
    type?: string;
    /**
     * The username for authentication when importing.
     */
    username?: string;
}

export interface GetPlatformResourceGroupIncludedScope {
    accountId: string;
    filter: string;
    orgId: string;
    projectId: string;
}

export interface GetPlatformResourceGroupResourceFilter {
    includeAllResources: boolean;
    resources: outputs.GetPlatformResourceGroupResourceFilterResource[];
}

export interface GetPlatformResourceGroupResourceFilterResource {
    attributeFilters: outputs.GetPlatformResourceGroupResourceFilterResourceAttributeFilter[];
    identifiers: string[];
    resourceType: string;
}

export interface GetPlatformResourceGroupResourceFilterResourceAttributeFilter {
    attributeName: string;
    attributeValues: string[];
}

export interface GetPlatformRoleAssignmentsPrincipal {
    identifier: string;
    scopeLevel: string;
    type: string;
}

export interface GetPlatformSecretSshkeyKerbero {
    principal: string;
    realm: string;
    tgtGenerationMethod: string;
    tgtKeyTabFilePathSpecs: outputs.GetPlatformSecretSshkeyKerberoTgtKeyTabFilePathSpec[];
    tgtPasswordSpecs: outputs.GetPlatformSecretSshkeyKerberoTgtPasswordSpec[];
}

export interface GetPlatformSecretSshkeyKerberoTgtKeyTabFilePathSpec {
    keyPath: string;
}

export interface GetPlatformSecretSshkeyKerberoTgtPasswordSpec {
    password: string;
}

export interface GetPlatformSecretSshkeySsh {
    credentialType: string;
    sshPasswordCredentials: outputs.GetPlatformSecretSshkeySshSshPasswordCredential[];
    sshkeyPathCredentials: outputs.GetPlatformSecretSshkeySshSshkeyPathCredential[];
    sshkeyReferenceCredentials: outputs.GetPlatformSecretSshkeySshSshkeyReferenceCredential[];
}

export interface GetPlatformSecretSshkeySshSshPasswordCredential {
    password: string;
    userName: string;
}

export interface GetPlatformSecretSshkeySshSshkeyPathCredential {
    encryptedPassphrase: string;
    keyPath: string;
    userName: string;
}

export interface GetPlatformSecretSshkeySshSshkeyReferenceCredential {
    encryptedAssphrase: string;
    key: string;
    userName: string;
}

export interface GetPlatformSecretTextAdditionalMetadata {
    values?: outputs.GetPlatformSecretTextAdditionalMetadataValue[];
}

export interface GetPlatformSecretTextAdditionalMetadataValue {
    version?: string;
}

export interface GetPlatformServiceGitDetails {
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Load service yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Repo name of remote service
     */
    repoName: string;
}

export interface GetPlatformServiceListService {
    identifier: string;
    name: string;
}

export interface GetPlatformServiceOverridesV2GitDetails {
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Load service yaml from fallback branch
     */
    loadFromCache: boolean;
    /**
     * Load service yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Repo name of remote service override
     */
    repoName: string;
}

export interface GetPlatformTemplateFiltersFilterProperty {
    filterType: string;
    tags: string[];
}

export interface GetPlatformTemplateGitDetails {
    /**
     * Name of the branch.
     */
    branchName?: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath?: string;
    /**
     * File url of the Entity in the repository.
     */
    fileUrl?: string;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * Name of the repository.
     */
    repoName?: string;
    /**
     * Repo url of the Entity in the repository.
     */
    repoUrl?: string;
}

export interface GetPlatformUsergroupNotificationConfig {
    /**
     * Group email.
     */
    groupEmail: string;
    /**
     * Url of Microsoft teams webhook.
     */
    microsoftTeamsWebhookUrl: string;
    /**
     * Pager duty key.
     */
    pagerDutyKey: string;
    /**
     * Send email to all the group members.
     */
    sendEmailToAllUsers: boolean;
    /**
     * Url of slack webhook.
     */
    slackWebhookUrl: string;
    /**
     * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
     */
    type: string;
}

export interface GetPlatformVariablesSpec {
    fixedValue: string;
    valueType: string;
}

export interface GetPlatformWorkspaceEnvironmentVariable {
    /**
     * Key is the identifier for the variable`
     */
    key: string;
    /**
     * value is the value of the variable
     */
    value: string;
    /**
     * Value type indicates the value type of the variable, text or secret
     */
    valueType: string;
}

export interface GetPlatformWorkspaceOutputOutput {
    name: string;
    sensitive: boolean;
    value: string;
}

export interface GetPlatformWorkspaceTerraformVariable {
    /**
     * Key is the identifier for the variable`
     */
    key: string;
    /**
     * value is the value of the variable
     */
    value: string;
    /**
     * Value type indicates the value type of the variable, text or secret
     */
    valueType: string;
}

export interface GetPlatformWorkspaceTerraformVariableFile {
    /**
     * Repository is the name of the repository to fetch the code from.
     */
    repository: string;
    /**
     * Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit is set
     */
    repositoryBranch: string;
    /**
     * Repository commit is commit or tag to fetch the variables from. This cannot be set if repository branch is set.
     */
    repositoryCommit: string;
    /**
     * Repository connector is the reference to the connector used to fetch the variables.
     */
    repositoryConnector: string;
    /**
     * Repository path is the path in which the variables reside.
     */
    repositoryPath: string;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface GetTriggerCondition {
    onWebhooks: outputs.GetTriggerConditionOnWebhook[];
    triggerConditionType: string;
}

export interface GetTriggerConditionOnWebhook {
    webhookDetails: outputs.GetTriggerConditionOnWebhookWebhookDetail[];
}

export interface GetTriggerConditionOnWebhookWebhookDetail {
    header: string;
    method: string;
    payload: string;
    webhookToken: string;
    webhookUrl: string;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: string;
    /**
     * The name of the author
     */
    authorName?: string;
    /**
     * Commit message
     */
    message?: string;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: string;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: boolean;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: string[];
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('\.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: string;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: string;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: string[];
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: string[];
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: string[];
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: boolean;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: boolean;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: string;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: string;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The IAM role to use.
     */
    iamRole?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE_DNS, PUBLIC_DNS, PRIVATE_IP, PUBLIC_IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('\.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: outputs.InfrastructureDefinitionAwsSshTag[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: string[];
}

export interface InfrastructureDefinitionAwsSshTag {
    /**
     * The key of the tag.
     */
    key: string;
    /**
     * The value of the tag.
     */
    value: string;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE_DNS, PUBLIC_DNS, PRIVATE_IP, PUBLIC_IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('\.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH_PUBLIC_KEY.
     */
    authType: string;
    /**
     * Base name.
     */
    baseName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: string;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The name of the resource group.
     */
    resourceGroupName: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
    /**
     * The username to connect with.
     */
    username: string;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the resource group.
     */
    resourceGroup: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
}

export interface InfrastructureDefinitionCustom {
    /**
     * The template version
     */
    deploymentTypeTemplateVersion: string;
    /**
     * Variables to be used in the service
     */
    variables?: outputs.InfrastructureDefinitionCustomVariable[];
}

export interface InfrastructureDefinitionCustomVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: string;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: string;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release.
     */
    releaseName: string;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The PCF organization to use.
     */
    organization: string;
    /**
     * The PCF space to deploy to.
     */
    space: string;
}

export interface PlatformCcmFiltersFilterProperties {
    /**
     * Type of CCM filters.
     */
    filterType: string;
    /**
     * Tags to associate with the resource. Tags should be in the form `name:value`.
     */
    tags?: string[];
}

export interface PlatformConnectorAppdynamicsApiToken {
    /**
     * The client id used for connecting to App Dynamics.
     */
    clientId: string;
    /**
     * Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientSecretRef: string;
}

export interface PlatformConnectorAppdynamicsUsernamePassword {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username: string;
}

export interface PlatformConnectorArtifactoryCredentials {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorAwsCrossAccountAccess {
    /**
     * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
     */
    externalId?: string;
    /**
     * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
     */
    roleArn: string;
}

export interface PlatformConnectorAwsEqualJitterBackoffStrategy {
    /**
     * Base delay.
     */
    baseDelay?: number;
    /**
     * Max BackOff Time.
     */
    maxBackoffTime?: number;
    /**
     * Retry Count.
     */
    retryCount?: number;
}

export interface PlatformConnectorAwsFixedDelayBackoffStrategy {
    /**
     * Fixed Backoff.
     */
    fixedBackoff?: number;
    /**
     * Retry Count.
     */
    retryCount?: number;
}

export interface PlatformConnectorAwsFullJitterBackoffStrategy {
    /**
     * Base delay.
     */
    baseDelay?: number;
    /**
     * Max BackOff Time.
     */
    maxBackoffTime?: number;
    /**
     * Retry Count.
     */
    retryCount?: number;
}

export interface PlatformConnectorAwsInheritFromDelegate {
    /**
     * The delegates to inherit the credentials from.
     */
    delegateSelectors: string[];
    /**
     * Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    region?: string;
}

export interface PlatformConnectorAwsIrsa {
    /**
     * The delegates to inherit the credentials from.
     */
    delegateSelectors: string[];
    /**
     * Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    region?: string;
}

export interface PlatformConnectorAwsManual {
    /**
     * AWS access key.
     */
    accessKey?: string;
    /**
     * Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    accessKeyRef?: string;
    /**
     * Connect only use delegates with these tags.
     */
    delegateSelectors?: string[];
    /**
     * Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    region?: string;
    /**
     * Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    secretKeyRef: string;
}

export interface PlatformConnectorAwsOidcAuthentication {
    /**
     * The delegates to inherit the credentials from.
     */
    delegateSelectors: string[];
    /**
     * The IAM Role to assume the credentials from.
     */
    iamRoleArn: string;
    /**
     * Test Region to perform Connection test of AWS Connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    region?: string;
}

export interface PlatformConnectorAwsSecretManagerCredentials {
    /**
     * Connect using STS assume role.
     */
    assumeRole?: outputs.PlatformConnectorAwsSecretManagerCredentialsAssumeRole;
    /**
     * Inherit the credentials from from the delegate.
     */
    inheritFromDelegate?: boolean;
    /**
     * Specify the AWS key and secret used for authenticating.
     */
    manual?: outputs.PlatformConnectorAwsSecretManagerCredentialsManual;
}

export interface PlatformConnectorAwsSecretManagerCredentialsAssumeRole {
    /**
     * The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
     */
    duration: number;
    /**
     * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
     */
    externalId?: string;
    /**
     * The ARN of the role to assume.
     */
    roleArn: string;
}

export interface PlatformConnectorAwsSecretManagerCredentialsManual {
    /**
     * The plain text AWS access key.
     */
    accessKeyPlainText?: string;
    /**
     * The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    accessKeyRef?: string;
    /**
     * The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    secretKeyRef: string;
}

export interface PlatformConnectorAwsccCrossAccountAccess {
    /**
     * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
     */
    externalId: string;
    /**
     * The ARN of the role to use for cross-account access.
     */
    roleArn: string;
}

export interface PlatformConnectorAwskmsCredentials {
    /**
     * Connect using STS assume role.
     */
    assumeRole?: outputs.PlatformConnectorAwskmsCredentialsAssumeRole;
    /**
     * Inherit the credentials from from the delegate.
     */
    inheritFromDelegate?: boolean;
    /**
     * Specify the AWS key and secret used for authenticating.
     */
    manual?: outputs.PlatformConnectorAwskmsCredentialsManual;
}

export interface PlatformConnectorAwskmsCredentialsAssumeRole {
    /**
     * The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
     */
    duration: number;
    /**
     * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
     */
    externalId?: string;
    /**
     * The ARN of the role to assume.
     */
    roleArn: string;
}

export interface PlatformConnectorAwskmsCredentialsManual {
    /**
     * The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    accessKeyRef: string;
    /**
     * The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    secretKeyRef: string;
}

export interface PlatformConnectorAzureCloudCostBillingExportSpec {
    /**
     * Name of the container.
     */
    containerName: string;
    /**
     * Name of the directory.
     */
    directoryName: string;
    /**
     * Name of the report.
     */
    reportName: string;
    /**
     * Name of the storage account.
     */
    storageAccountName: string;
    /**
     * Subsription Id.
     */
    subscriptionId: string;
}

export interface PlatformConnectorAzureCloudProviderCredentials {
    /**
     * Authenticate to Azure Cloud Provider using details inheriting from delegate.
     */
    azureInheritFromDelegateDetails?: outputs.PlatformConnectorAzureCloudProviderCredentialsAzureInheritFromDelegateDetails;
    /**
     * Authenticate to Azure Cloud Provider using manual details.
     */
    azureManualDetails?: outputs.PlatformConnectorAzureCloudProviderCredentialsAzureManualDetails;
    /**
     * Type can either be InheritFromDelegate or ManualConfig.
     */
    type: string;
}

export interface PlatformConnectorAzureCloudProviderCredentialsAzureInheritFromDelegateDetails {
    /**
     * Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
     */
    auth?: outputs.PlatformConnectorAzureCloudProviderCredentialsAzureInheritFromDelegateDetailsAuth;
}

export interface PlatformConnectorAzureCloudProviderCredentialsAzureInheritFromDelegateDetailsAuth {
    /**
     * Azure UserAssigned MSI auth details.
     */
    azureMsiAuthUa?: outputs.PlatformConnectorAzureCloudProviderCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa;
    /**
     * Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
     */
    type: string;
}

export interface PlatformConnectorAzureCloudProviderCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa {
    /**
     * Client Id of the ManagedIdentity resource.
     */
    clientId?: string;
}

export interface PlatformConnectorAzureCloudProviderCredentialsAzureManualDetails {
    /**
     * Application ID of the Azure App.
     */
    applicationId?: string;
    /**
     * Contains Azure auth details.
     */
    auth?: outputs.PlatformConnectorAzureCloudProviderCredentialsAzureManualDetailsAuth;
    /**
     * The Azure Active Directory (AAD) directory ID where you created your application.
     */
    tenantId?: string;
}

export interface PlatformConnectorAzureCloudProviderCredentialsAzureManualDetailsAuth {
    /**
     * Azure client key certificate details.
     */
    azureClientKeyCert?: outputs.PlatformConnectorAzureCloudProviderCredentialsAzureManualDetailsAuthAzureClientKeyCert;
    /**
     * Azure Client Secret Key details.
     */
    azureClientSecretKey?: outputs.PlatformConnectorAzureCloudProviderCredentialsAzureManualDetailsAuthAzureClientSecretKey;
    /**
     * Type can either be Certificate or Secret.
     */
    type?: string;
}

export interface PlatformConnectorAzureCloudProviderCredentialsAzureManualDetailsAuthAzureClientKeyCert {
    /**
     * Reference of the secret for the certificate. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    certificateRef?: string;
}

export interface PlatformConnectorAzureCloudProviderCredentialsAzureManualDetailsAuthAzureClientSecretKey {
    /**
     * Reference of the secret for the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    secretRef?: string;
}

export interface PlatformConnectorBitbucketApiAuthentication {
    /**
     * Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    tokenRef: string;
    /**
     * The username used for connecting to the api.
     */
    username?: string;
    /**
     * The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorBitbucketCredentials {
    /**
     * Authenticate using Username and password over http(s) for the connection.
     */
    http?: outputs.PlatformConnectorBitbucketCredentialsHttp;
    /**
     * Authenticate using SSH for the connection.
     */
    ssh?: outputs.PlatformConnectorBitbucketCredentialsSsh;
}

export interface PlatformConnectorBitbucketCredentialsHttp {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef?: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorBitbucketCredentialsSsh {
    /**
     * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    sshKeyRef: string;
}

export interface PlatformConnectorCustomSecretManagerTemplateInput {
    environmentVariables?: outputs.PlatformConnectorCustomSecretManagerTemplateInputEnvironmentVariable[];
}

export interface PlatformConnectorCustomSecretManagerTemplateInputEnvironmentVariable {
    default?: boolean;
    name: string;
    type: string;
    value: string;
}

export interface PlatformConnectorCustomhealthsourceHeader {
    /**
     * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    encryptedValueRef?: string;
    /**
     * Key.
     */
    key: string;
    /**
     * Value.
     */
    value?: string;
    /**
     * Encrypted value.
     */
    valueEncrypted?: boolean;
}

export interface PlatformConnectorCustomhealthsourceParam {
    /**
     * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    encryptedValueRef?: string;
    /**
     * Key.
     */
    key: string;
    /**
     * Value.
     */
    value?: string;
    /**
     * Encrypted value.
     */
    valueEncrypted?: boolean;
}

export interface PlatformConnectorDockerCredentials {
    /**
     * The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * The username to use for the docker registry.
     */
    username?: string;
    /**
     * The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorElasticsearchApiToken {
    /**
     * The API Key id used for connecting to ElasticSearch.
     */
    clientId: string;
    /**
     * Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientSecretRef: string;
}

export interface PlatformConnectorElasticsearchNoAuthentication {
}

export interface PlatformConnectorElasticsearchUsernamePassword {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username: string;
}

export interface PlatformConnectorGcpCloudCostBillingExportSpec {
    /**
     * Data Set Id.
     */
    dataSetId: string;
    /**
     * Table Id.
     */
    tableId: string;
}

export interface PlatformConnectorGcpInheritFromDelegate {
    /**
     * The delegates to inherit the credentials from.
     */
    delegateSelectors: string[];
}

export interface PlatformConnectorGcpManual {
    /**
     * The delegates to connect with.
     */
    delegateSelectors?: string[];
    /**
     * Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    secretKeyRef: string;
}

export interface PlatformConnectorGcpOidcAuthentication {
    /**
     * The delegates to inherit the credentials from.
     */
    delegateSelectors: string[];
    /**
     * The project number of the GCP project that is used to create the workload identity.
     */
    gcpProjectId: string;
    /**
     * The OIDC provider ID value configured in GCP.
     */
    providerId: string;
    /**
     * The service account linked to workload identity pool while setting GCP workload identity provider.
     */
    serviceAccountEmail: string;
    /**
     * The workload pool ID value created in GCP.
     */
    workloadPoolId: string;
}

export interface PlatformConnectorGitCredentials {
    /**
     * Authenticate using Username and password over http(s) for the connection.
     */
    http?: outputs.PlatformConnectorGitCredentialsHttp;
    /**
     * Authenticate using SSH for the connection.
     */
    ssh?: outputs.PlatformConnectorGitCredentialsSsh;
}

export interface PlatformConnectorGitCredentialsHttp {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorGitCredentialsSsh {
    /**
     * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    sshKeyRef: string;
}

export interface PlatformConnectorGithubApiAuthentication {
    /**
     * Configuration for using the github app for interacting with the github api.
     */
    githubApp?: outputs.PlatformConnectorGithubApiAuthenticationGithubApp;
    /**
     * Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    tokenRef?: string;
}

export interface PlatformConnectorGithubApiAuthenticationGithubApp {
    /**
     * Enter the GitHub App ID from the GitHub App General tab.
     */
    applicationId?: string;
    /**
     * Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    applicationIdRef?: string;
    /**
     * Enter the Installation ID located in the URL of the installed GitHub App.
     */
    installationId?: string;
    /**
     * Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    installationIdRef?: string;
    /**
     * Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    privateKeyRef: string;
}

export interface PlatformConnectorGithubCredentials {
    /**
     * Authenticate using Username and password over http(s) for the connection.
     */
    http?: outputs.PlatformConnectorGithubCredentialsHttp;
    /**
     * Authenticate using SSH for the connection.
     */
    ssh?: outputs.PlatformConnectorGithubCredentialsSsh;
}

export interface PlatformConnectorGithubCredentialsHttp {
    /**
     * Configuration for using the github http anonymous for interacting with the github api.
     */
    anonymouses?: outputs.PlatformConnectorGithubCredentialsHttpAnonymouse[];
    /**
     * Configuration for using the github app for interacting with the github api.
     */
    githubApp?: outputs.PlatformConnectorGithubCredentialsHttpGithubApp;
    /**
     * Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    tokenRef?: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorGithubCredentialsHttpAnonymouse {
}

export interface PlatformConnectorGithubCredentialsHttpGithubApp {
    /**
     * Enter the GitHub App ID from the GitHub App General tab.
     */
    applicationId?: string;
    /**
     * Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    applicationIdRef?: string;
    /**
     * Enter the Installation ID located in the URL of the installed GitHub App.
     */
    installationId?: string;
    /**
     * Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    installationIdRef?: string;
    /**
     * Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    privateKeyRef: string;
}

export interface PlatformConnectorGithubCredentialsSsh {
    /**
     * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    sshKeyRef: string;
}

export interface PlatformConnectorGitlabApiAuthentication {
    /**
     * Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    tokenRef: string;
}

export interface PlatformConnectorGitlabCredentials {
    /**
     * Authenticate using Username and password over http(s) for the connection.
     */
    http?: outputs.PlatformConnectorGitlabCredentialsHttp;
    /**
     * Authenticate using SSH for the connection.
     */
    ssh?: outputs.PlatformConnectorGitlabCredentialsSsh;
}

export interface PlatformConnectorGitlabCredentialsHttp {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef?: string;
    /**
     * Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    tokenRef?: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorGitlabCredentialsSsh {
    /**
     * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    sshKeyRef: string;
}

export interface PlatformConnectorHelmCredentials {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorJdbcCredentials {
    /**
     * The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * The username to use for the database server.
     */
    username?: string;
    /**
     * The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorJenkinsAuth {
    /**
     * Authenticate to App Dynamics using bearer token.
     */
    jenkinsBearerToken?: outputs.PlatformConnectorJenkinsAuthJenkinsBearerToken;
    /**
     * Authenticate to App Dynamics using user name and password.
     */
    jenkinsUserNamePassword?: outputs.PlatformConnectorJenkinsAuthJenkinsUserNamePassword;
    /**
     * Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
     */
    type: string;
}

export interface PlatformConnectorJenkinsAuthJenkinsBearerToken {
    /**
     * Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    tokenRef: string;
}

export interface PlatformConnectorJenkinsAuthJenkinsUserNamePassword {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Username reference to use for authentication.
     */
    usernameRef?: string;
}

export interface PlatformConnectorJiraAuth {
    /**
     * Authentication types for Jira connector
     */
    authType: string;
    /**
     * Authenticate using personal access token.
     */
    personalAccessToken?: outputs.PlatformConnectorJiraAuthPersonalAccessToken;
    /**
     * Authenticate using username password.
     */
    usernamePassword?: outputs.PlatformConnectorJiraAuthUsernamePassword;
}

export interface PlatformConnectorJiraAuthPersonalAccessToken {
    /**
     * Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    patRef: string;
}

export interface PlatformConnectorJiraAuthUsernamePassword {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorKubernetesClientKeyCert {
    /**
     * Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    caCertRef?: string;
    /**
     * Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientCertRef: string;
    /**
     * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
     */
    clientKeyAlgorithm: string;
    /**
     * Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientKeyPassphraseRef?: string;
    /**
     * Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientKeyRef: string;
    /**
     * The URL of the Kubernetes cluster.
     */
    masterUrl: string;
}

export interface PlatformConnectorKubernetesInheritFromDelegate {
    /**
     * Selectors to use for the delegate.
     */
    delegateSelectors: string[];
}

export interface PlatformConnectorKubernetesOpenidConnect {
    /**
     * Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientIdRef: string;
    /**
     * The URL of the OpenID Connect issuer.
     */
    issuerUrl: string;
    /**
     * The URL of the Kubernetes cluster.
     */
    masterUrl: string;
    /**
     * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Scopes to request for the connector.
     */
    scopes?: string[];
    /**
     * Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    secretRef?: string;
    /**
     * Username for the connector.
     */
    username?: string;
    /**
     * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorKubernetesServiceAccount {
    /**
     * Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    caCertRef?: string;
    /**
     * The URL of the Kubernetes cluster.
     */
    masterUrl: string;
    /**
     * Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    serviceAccountTokenRef: string;
}

export interface PlatformConnectorKubernetesUsernamePassword {
    /**
     * The URL of the Kubernetes cluster.
     */
    masterUrl: string;
    /**
     * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username for the connector.
     */
    username?: string;
    /**
     * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorNexusCredentials {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorOciHelmCredentials {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorPdcHost {
    /**
     * attributes for current host
     */
    attributes?: {[key: string]: string};
    /**
     * hostname
     */
    hostname: string;
}

export interface PlatformConnectorPrometheusHeader {
    /**
     * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    encryptedValueRef?: string;
    /**
     * Key.
     */
    key: string;
    /**
     * Value.
     */
    value?: string;
    /**
     * Encrypted value.
     */
    valueEncrypted?: boolean;
}

export interface PlatformConnectorRancherBearerToken {
    /**
     * Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    bearerTokenRef: string;
}

export interface PlatformConnectorServiceNowAuth {
    /**
     * Authenticate using adfs client credentials with certificate.
     */
    adfs?: outputs.PlatformConnectorServiceNowAuthAdfs;
    /**
     * Authentication types for Jira connector
     */
    authType: string;
    /**
     * Authenticate using refresh token grant type.
     */
    refreshToken?: outputs.PlatformConnectorServiceNowAuthRefreshToken;
    /**
     * Authenticate using username password.
     */
    usernamePassword?: outputs.PlatformConnectorServiceNowAuthUsernamePassword;
}

export interface PlatformConnectorServiceNowAuthAdfs {
    /**
     * asdf URL.
     */
    adfsUrl: string;
    /**
     * Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    certificateRef: string;
    /**
     * Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientIdRef: string;
    /**
     * Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    privateKeyRef: string;
    /**
     * Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    resourceIdRef: string;
}

export interface PlatformConnectorServiceNowAuthRefreshToken {
    /**
     * Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientIdRef: string;
    /**
     * Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    clientSecretRef?: string;
    /**
     * Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    refreshTokenRef: string;
    /**
     * Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    scope?: string;
    /**
     * Token url to use for authentication.
     */
    tokenUrl: string;
}

export interface PlatformConnectorServiceNowAuthUsernamePassword {
    /**
     * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorSpotPermanentToken {
    /**
     * Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    apiTokenRef: string;
    /**
     * Connect only using delegates with these tags.
     */
    delegateSelectors?: string[];
    /**
     * Execute on delegate or not.
     */
    executeOnDelegate?: boolean;
    /**
     * Spot account id.
     */
    spotAccountId?: string;
    /**
     * Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    spotAccountIdRef?: string;
}

export interface PlatformConnectorTasCredentials {
    /**
     * Authenticate to Tas using manual details.
     */
    tasManualDetails: outputs.PlatformConnectorTasCredentialsTasManualDetails;
    /**
     * Type can be ManualConfig.
     */
    type: string;
}

export interface PlatformConnectorTasCredentialsTasManualDetails {
    /**
     * URL of the Tas server.
     */
    endpointUrl: string;
    /**
     * Reference of the secret for the password. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    passwordRef: string;
    /**
     * Reference token for authentication.
     */
    referenceToken?: string;
    /**
     * Username to use for authentication.
     */
    username?: string;
    /**
     * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    usernameRef?: string;
}

export interface PlatformConnectorTerraformCloudCredentials {
    /**
     * API token credentials to use for authentication.
     */
    apiToken: outputs.PlatformConnectorTerraformCloudCredentialsApiToken;
}

export interface PlatformConnectorTerraformCloudCredentialsApiToken {
    /**
     * Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    apiTokenRef: string;
}

export interface PlatformDbSchemaSchemaSource {
    /**
     * Connector to repository at which to find details about the database schema
     */
    connector: string;
    /**
     * The path within the specified repository at which to find details about the database schema
     */
    location: string;
    /**
     * If connector url is of account, which repository to connect to using the connector
     */
    repo?: string;
}

export interface PlatformEnvironmentClustersMappingCluster {
    /**
     * agent identifier of the cluster (include scope prefix)
     */
    agentIdentifier?: string;
    /**
     * identifier of the cluster
     */
    identifier?: string;
    /**
     * name of the cluster
     */
    name?: string;
    /**
     * scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
     */
    scope?: string;
}

export interface PlatformEnvironmentGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * import environment from git
     */
    importFromGit: boolean;
    /**
     * force import environment from remote even if same file path already exist
     */
    isForceImport: boolean;
    /**
     * If the gitProvider is HarnessCode
     */
    isHarnesscodeRepo: boolean;
    /**
     * If a new branch creation is requested.
     */
    isNewBranch: boolean;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * If the Entity is to be fetched from cache
     */
    loadFromCache: string;
    /**
     * If the Entity is to be fetched from fallbackBranch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    parentEntityConnectorRef: string;
    /**
     * Name of the repository where parent entity lies.
     */
    parentEntityRepoName: string;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformFeatureFlagEnvironment {
    /**
     * The targeting rules for the flag
     */
    addTargetRules?: outputs.PlatformFeatureFlagEnvironmentAddTargetRule[];
    /**
     * Default variation to be served when flag is 'off'
     */
    defaultOffVariation: string;
    /**
     * Default variation to be served when flag is 'on'
     */
    defaultOnVariation: string;
    /**
     * Identifier of the Environment
     */
    identifier: string;
    /**
     * State of the flag in this environment. Possible values are 'on' and 'off'
     */
    state: string;
}

export interface PlatformFeatureFlagEnvironmentAddTargetRule {
    /**
     * The targets that should be served this variation
     */
    targets?: string[];
    /**
     * The identifier of the variation
     */
    variation?: string;
}

export interface PlatformFeatureFlagTag {
    /**
     * The identifier of the tag
     */
    identifier: string;
}

export interface PlatformFeatureFlagTargetGroupRule {
    /**
     * The attribute to use in the clause.  This can be any target attribute
     */
    attribute: string;
    /**
     * Is the operation negated?
     */
    negate: boolean;
    /**
     * The type of operation such as equals, starts_with, contains
     */
    op: string;
    /**
     * The values that are compared against the operator
     */
    values: string[];
}

export interface PlatformFeatureFlagVariation {
    /**
     * The description of the variation
     */
    description: string;
    /**
     * The identifier of the variation
     */
    identifier: string;
    /**
     * The user friendly name of the variation
     */
    name: string;
    /**
     * The value of the variation
     */
    value: string;
}

export interface PlatformFileStoreFileCreatedBy {
    email: string;
    name: string;
}

export interface PlatformFileStoreFileLastModifiedBy {
    email: string;
    name: string;
}

export interface PlatformFileStoreFolderCreatedBy {
    email: string;
    name: string;
}

export interface PlatformFileStoreFolderLastModifiedBy {
    email: string;
    name: string;
}

export interface PlatformFiltersFilterProperties {
    /**
     * Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
     */
    filterType: string;
    /**
     * Tags to associate with the resource. Tags should be in the form `name:value`.
     */
    tags?: string[];
}

export interface PlatformGitopsAgentMetadata {
    /**
     * Indicates if the agent is deployed in HA mode.
     */
    highAvailability?: boolean;
    /**
     * Indicates if the agent is namespaced.
     */
    isNamespaced?: boolean;
    /**
     * The kubernetes namespace where the agent should be installed.
     */
    namespace?: string;
}

export interface PlatformGitopsAppProjectProject {
    /**
     * Metadata details for the GitOps project.
     */
    metadatas: outputs.PlatformGitopsAppProjectProjectMetadata[];
    /**
     * Specification details for the GitOps project.
     */
    specs: outputs.PlatformGitopsAppProjectProjectSpec[];
}

export interface PlatformGitopsAppProjectProjectMetadata {
    /**
     * Annotations associated with the GitOps project.
     */
    annotations: {[key: string]: string};
    /**
     * Name of the cluster associated with the GitOps project.
     */
    clusterName?: string;
    /**
     * Finalizers associated with the GitOps project.
     */
    finalizers?: string[];
    /**
     * Labels associated with the GitOps project.
     */
    labels?: {[key: string]: string};
    /**
     * Managed fields associated with the GitOps project.
     */
    managedFields?: outputs.PlatformGitopsAppProjectProjectMetadataManagedField[];
    /**
     * Name of the GitOps project.
     */
    name?: string;
    /**
     * Namespace of the GitOps project.
     */
    namespace?: string;
    /**
     * Resource Version for the GitOps project
     */
    resourceVersion: string;
}

export interface PlatformGitopsAppProjectProjectMetadataManagedField {
    /**
     * API version of the operation performed.
     */
    apiVersion: string;
    /**
     * Type of the fields in the GitOps project.
     */
    fieldsType: string;
    /**
     * Raw fields associated with the GitOps project.
     */
    fieldsV1: {[key: string]: string};
    /**
     * Manager responsible for the operation.
     */
    manager: string;
    /**
     * Operation type performed on the GitOps project.
     */
    operation: string;
    /**
     * Subresource associated with the GitOps project.
     */
    subresource: string;
    /**
     * Timestamp of the operation.
     */
    time: {[key: string]: string};
}

export interface PlatformGitopsAppProjectProjectSpec {
    /**
     * Cluster resource blacklist for the GitOps project.
     */
    clusterResourceBlacklists?: outputs.PlatformGitopsAppProjectProjectSpecClusterResourceBlacklist[];
    /**
     * Cluster resource whitelist for the GitOps project.
     */
    clusterResourceWhitelists?: outputs.PlatformGitopsAppProjectProjectSpecClusterResourceWhitelist[];
    /**
     * Description of the GitOps project.
     */
    description?: string;
    /**
     * Destinations for deployment of the GitOps project.
     */
    destinations?: outputs.PlatformGitopsAppProjectProjectSpecDestination[];
    /**
     * Namespace resource blacklist for the GitOps project.
     */
    namespaceResourceBlacklists?: outputs.PlatformGitopsAppProjectProjectSpecNamespaceResourceBlacklist[];
    /**
     * Namespace resource whitelist for the GitOps project.
     */
    namespaceResourceWhitelists?: outputs.PlatformGitopsAppProjectProjectSpecNamespaceResourceWhitelist[];
    /**
     * Orphaned resources configuration for the GitOps project.
     */
    orphanedResources?: outputs.PlatformGitopsAppProjectProjectSpecOrphanedResource[];
    /**
     * Roles associated with the GitOps project.
     */
    roles?: outputs.PlatformGitopsAppProjectProjectSpecRole[];
    /**
     * Signature keys for the GitOps project.
     */
    signatureKeys?: outputs.PlatformGitopsAppProjectProjectSpecSignatureKey[];
    /**
     * Source repositories for the GitOps project.
     */
    sourceRepos?: string[];
    /**
     * Synchronization windows for the GitOps project.
     */
    syncWindows?: outputs.PlatformGitopsAppProjectProjectSpecSyncWindow[];
}

export interface PlatformGitopsAppProjectProjectSpecClusterResourceBlacklist {
    /**
     * Group of the cluster resource blacklist.
     */
    group?: string;
    /**
     * Kind of the cluster resource blacklist.
     */
    kind?: string;
}

export interface PlatformGitopsAppProjectProjectSpecClusterResourceWhitelist {
    /**
     * Group of the cluster resource whitelist.
     */
    group?: string;
    /**
     * Kind of the cluster resource whitelist.
     */
    kind?: string;
}

export interface PlatformGitopsAppProjectProjectSpecDestination {
    /**
     * Name of the destination.
     */
    name?: string;
    /**
     * Namespace of the destination.
     */
    namespace?: string;
    /**
     * Server URL of the destination.
     */
    server?: string;
}

export interface PlatformGitopsAppProjectProjectSpecNamespaceResourceBlacklist {
    /**
     * Group of the namespace resource blacklist.
     */
    group?: string;
    /**
     * Kind of the namespace resource blacklist.
     */
    kind?: string;
}

export interface PlatformGitopsAppProjectProjectSpecNamespaceResourceWhitelist {
    /**
     * Group of the namespace resource whitelist.
     */
    group?: string;
    /**
     * Kind of the namespace resource whitelist.
     */
    kind?: string;
}

export interface PlatformGitopsAppProjectProjectSpecOrphanedResource {
    /**
     * List of ignored orphaned resources.
     */
    ignores?: outputs.PlatformGitopsAppProjectProjectSpecOrphanedResourceIgnore[];
    /**
     * Whether to warn about orphaned resources.
     */
    warn?: boolean;
}

export interface PlatformGitopsAppProjectProjectSpecOrphanedResourceIgnore {
    /**
     * Group of the ignored orphaned resource.
     */
    group?: string;
    /**
     * Kind of the ignored orphaned resource.
     */
    kind?: string;
    /**
     * Name of the ignored orphaned resource.
     */
    name?: string;
}

export interface PlatformGitopsAppProjectProjectSpecRole {
    /**
     * Description of the role.
     */
    description: string;
    /**
     * Groups associated with the role.
     */
    groups: string[];
    /**
     * JWT tokens associated with the role.
     */
    jwtTokens?: outputs.PlatformGitopsAppProjectProjectSpecRoleJwtToken[];
    /**
     * Name of the role.
     */
    name: string;
    /**
     * Policies associated with the role.
     */
    policies?: string[];
}

export interface PlatformGitopsAppProjectProjectSpecRoleJwtToken {
    /**
     * Expiration time of the JWT token.
     */
    exp?: string;
    /**
     * Issued At time of the JWT token.
     */
    iat?: string;
    /**
     * ID of the JWT token.
     */
    id?: string;
}

export interface PlatformGitopsAppProjectProjectSpecSignatureKey {
    /**
     * ID of the signature key.
     */
    keyId?: string;
}

export interface PlatformGitopsAppProjectProjectSpecSyncWindow {
    /**
     * Applications associated with synchronization window.
     */
    applications: string[];
    /**
     * Clusters associated with synchronization window.
     */
    clusters: string[];
    /**
     * Duration of synchronization window.
     */
    duration: string;
    /**
     * Kind of synchronization window.
     */
    kind: string;
    /**
     * Whether manual synchronization is enabled.
     */
    manualSync: boolean;
    /**
     * Namespaces associated with synchronization window.
     */
    namespaces: string[];
    /**
     * Schedule of synchronization window.
     */
    schedule: string;
    /**
     * Time zone of synchronization window.
     */
    timeZone: string;
}

export interface PlatformGitopsApplicationsApplication {
    /**
     * Metadata corresponding to the resources. This includes all the objects a user must create.
     */
    metadatas: outputs.PlatformGitopsApplicationsApplicationMetadata[];
    /**
     * Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
     */
    specs?: outputs.PlatformGitopsApplicationsApplicationSpec[];
}

export interface PlatformGitopsApplicationsApplicationMetadata {
    /**
     * Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
     */
    annotations: {[key: string]: string};
    /**
     * Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
     */
    clusterName: string;
    /**
     * Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
     */
    finalizers: string[];
    /**
     * An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
     */
    generateName?: string;
    /**
     * A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
     */
    generation: string;
    /**
     * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
     */
    labels: {[key: string]: string};
    /**
     * Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
     */
    name?: string;
    /**
     * Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
     */
    namespace: string;
    /**
     * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
     */
    ownerReferences?: outputs.PlatformGitopsApplicationsApplicationMetadataOwnerReference[];
    /**
     * UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
     */
    uid: string;
}

export interface PlatformGitopsApplicationsApplicationMetadataOwnerReference {
    /**
     * API version of the referent.
     */
    apiVersion: string;
    /**
     * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
     */
    blockOwnerDeletion: boolean;
    /**
     * Indicates if the reference points to the managing controller.
     */
    controller: boolean;
    /**
     * Kind of the referent.
     */
    kind: string;
    /**
     * Name of the referent.
     */
    name: string;
    /**
     * UID of the referent.
     */
    uid: string;
}

export interface PlatformGitopsApplicationsApplicationSpec {
    /**
     * Information about the GitOps application's destination.
     */
    destinations?: outputs.PlatformGitopsApplicationsApplicationSpecDestination[];
    /**
     * Contains all information about the source of the GitOps application.
     */
    sources?: outputs.PlatformGitopsApplicationsApplicationSpecSource[];
    /**
     * Controls when a sync will be performed in response to updates in git.
     */
    syncPolicies?: outputs.PlatformGitopsApplicationsApplicationSpecSyncPolicy[];
}

export interface PlatformGitopsApplicationsApplicationSpecDestination {
    /**
     * URL of the target cluster and must be set to the kubernetes control plane API.
     */
    name?: string;
    /**
     * Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
     */
    namespace?: string;
    /**
     * URL of the target cluster server for the GitOps application.
     */
    server?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSource {
    /**
     * Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
     */
    chart?: string;
    /**
     * Options for applications of type plain YAML or Jsonnet.
     */
    directories?: outputs.PlatformGitopsApplicationsApplicationSpecSourceDirectory[];
    /**
     * Holds helm specific options.
     */
    helms?: outputs.PlatformGitopsApplicationsApplicationSpecSourceHelm[];
    /**
     * Ksonnet specific options.
     */
    ksonnets?: outputs.PlatformGitopsApplicationsApplicationSpecSourceKsonnet[];
    /**
     * Options specific to a GitOps application source specific to Kustomize.
     */
    kustomizes?: outputs.PlatformGitopsApplicationsApplicationSpecSourceKustomize[];
    /**
     * Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
     */
    path?: string;
    /**
     * Options specific to config management plugins.
     */
    plugins?: outputs.PlatformGitopsApplicationsApplicationSpecSourcePlugin[];
    /**
     * URL to the repository (git or helm) that contains the GitOps application manifests.
     */
    repoUrl: string;
    /**
     * Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
     */
    targetRevision: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceDirectory {
    /**
     * Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
     */
    exclude?: string;
    /**
     * Glob pattern to match paths against that should be explicitly included during manifest generation.
     */
    include?: string;
    /**
     * Options specific to applications of type Jsonnet.
     */
    jsonnets?: outputs.PlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnet[];
    /**
     * Indicates to scan a directory recursively for manifests.
     */
    recurse?: boolean;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnet {
    /**
     * List of jsonnet external variables.
     */
    extVars?: outputs.PlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar[];
    /**
     * Additional library search dirs.
     */
    libs?: string[];
    /**
     * List of jsonnet top-level arguments(TLAS).
     */
    tlas?: outputs.PlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla[];
}

export interface PlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar {
    /**
     * Code of the external variables of jsonnet application.
     */
    code?: boolean;
    /**
     * Name of the external variables of jsonnet application.
     */
    name?: string;
    /**
     * Value of the external variables of jsonnet application.
     */
    value?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla {
    /**
     * Code of the TLAS of the jsonnet application.
     */
    code?: boolean;
    /**
     * Name of the TLAS of the jsonnet application.
     */
    name?: string;
    /**
     * Value of the TLAS of the jsonnet application.
     */
    value?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceHelm {
    /**
     * File parameters to the helm template.
     */
    fileParameters?: outputs.PlatformGitopsApplicationsApplicationSpecSourceHelmFileParameter[];
    /**
     * List of helm parameters which are passed to the helm template command upon manifest generation.
     */
    parameters?: outputs.PlatformGitopsApplicationsApplicationSpecSourceHelmParameter[];
    /**
     * Indicates if to pass credentials to all domains (helm's --pass-credentials)
     */
    passCredentials?: boolean;
    /**
     * Helm release name to use. If omitted it will use the GitOps application name.
     */
    releaseName?: string;
    /**
     * List of helm value files to use when generating a template.
     */
    valueFiles?: string[];
    /**
     * Helm values to be passed to helm template, typically defined as a block.
     */
    values?: string;
    /**
     * Helm version to use for templating (either "2" or "3")
     */
    version?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceHelmFileParameter {
    /**
     * Name of the helm parameter.
     */
    name?: string;
    /**
     * Path to the file containing the values of the helm parameter.
     */
    path?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceHelmParameter {
    /**
     * Indicates if helm should interpret booleans and numbers as strings.
     */
    forceString?: boolean;
    /**
     * Name of the helm parameter.
     */
    name?: string;
    /**
     * Value of the Helm parameter.
     */
    value?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceKsonnet {
    /**
     * Ksonnet application environment name.
     */
    environment?: string;
    /**
     * List of ksonnet component parameter override values.
     */
    parameters?: outputs.PlatformGitopsApplicationsApplicationSpecSourceKsonnetParameter[];
}

export interface PlatformGitopsApplicationsApplicationSpecSourceKsonnetParameter {
    /**
     * Component of the parameter of the ksonnet application.
     */
    component?: string;
    /**
     * Name of the parameter of the ksonnet application.
     */
    name?: string;
    /**
     * Value of the parameter of the ksonnet application.
     */
    value?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourceKustomize {
    /**
     * List of additional annotations to add to rendered manifests.
     */
    commonAnnotations?: {[key: string]: string};
    /**
     * List of additional labels to add to rendered manifests.
     */
    commonLabels?: {[key: string]: string};
    /**
     * Indicates if to force applying common annotations to resources for kustomize apps.
     */
    forceCommonAnnotations?: boolean;
    /**
     * Indicates if to force apply common labels to resources for kustomize apps.
     */
    forceCommonLabels?: boolean;
    /**
     * List of kustomize image override specifications.
     */
    images?: string[];
    /**
     * Prefix prepended to resources for kustomize apps.
     */
    namePrefix?: string;
    /**
     * Suffix appended to resources for kustomize apps.
     */
    nameSuffix?: string;
    /**
     * Version of kustomize to use for rendering manifests.
     */
    version?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourcePlugin {
    /**
     * Entry in the GitOps application's environment.
     */
    envs?: outputs.PlatformGitopsApplicationsApplicationSpecSourcePluginEnv[];
    /**
     * Name of the plugin.
     */
    name?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSourcePluginEnv {
    /**
     * Name of the variable, usually expressed in uppercase.
     */
    name?: string;
    /**
     * Value of the variable.
     */
    value?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSyncPolicy {
    /**
     * Controls the behavior of an automated sync.
     */
    automateds?: outputs.PlatformGitopsApplicationsApplicationSpecSyncPolicyAutomated[];
    /**
     * Contains information about the strategy to apply when a sync failed.
     */
    retries?: outputs.PlatformGitopsApplicationsApplicationSpecSyncPolicyRetry[];
    /**
     * Options allow you to specify whole app sync-options.
     */
    syncOptions?: string[];
}

export interface PlatformGitopsApplicationsApplicationSpecSyncPolicyAutomated {
    /**
     * Indicates to allows apps to have zero live resources (default: false).
     */
    allowEmpty?: boolean;
    /**
     * Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
     */
    prune?: boolean;
    /**
     * Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
     */
    selfHeal?: boolean;
}

export interface PlatformGitopsApplicationsApplicationSpecSyncPolicyRetry {
    /**
     * Backoff strategy to use on subsequent retries for failing syncs.
     */
    backoffs?: outputs.PlatformGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff[];
    /**
     * Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
     */
    limit?: string;
}

export interface PlatformGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff {
    /**
     * Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
     */
    duration?: string;
    /**
     * Factor to multiply the base duration after each failed retry.
     */
    factor?: string;
    /**
     * Maximum amount of time allowed of the backoff strategy.
     */
    maxDuration?: string;
}

export interface PlatformGitopsClusterRequest {
    /**
     * GitOps cluster details.
     */
    clusters?: outputs.PlatformGitopsClusterRequestCluster[];
    /**
     * Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
     */
    tags?: string[];
    /**
     * Fields which are updated.
     */
    updatedFields: string[];
    /**
     * Indicates if the GitOps cluster should be updated if existing and inserted if not.
     */
    upsert?: boolean;
}

export interface PlatformGitopsClusterRequestCluster {
    /**
     * Annotations for cluster secret metadata.
     */
    annotations?: {[key: string]: string};
    /**
     * Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
     */
    clusterResources?: boolean;
    /**
     * GitOps cluster config.
     */
    configs: outputs.PlatformGitopsClusterRequestClusterConfig[];
    /**
     * Information about cluster cache and state.
     */
    infos: outputs.PlatformGitopsClusterRequestClusterInfo[];
    /**
     * Labels for cluster secret metadata.
     */
    labels?: {[key: string]: string};
    /**
     * Name of the cluster. If omitted, the server address will be used.
     */
    name?: string;
    /**
     * List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
     */
    namespaces: string[];
    /**
     * The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
     */
    project: string;
    /**
     * Time when cluster cache refresh has been requested.
     */
    refreshRequestedAts?: outputs.PlatformGitopsClusterRequestClusterRefreshRequestedAt[];
    /**
     * API server URL of the kubernetes cluster.
     */
    server: string;
    /**
     * Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
     */
    shard?: string;
}

export interface PlatformGitopsClusterRequestClusterConfig {
    /**
     * AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
     */
    awsClusterName?: string;
    /**
     * Bearer authentication token the cluster.
     */
    bearerToken?: string;
    /**
     * Identifies the authentication method used to connect to the cluster.
     */
    clusterConnectionType?: string;
    /**
     * Configuration for an exec provider.
     */
    execProviderConfigs?: outputs.PlatformGitopsClusterRequestClusterConfigExecProviderConfig[];
    /**
     * Password of the server of the cluster.
     */
    password?: string;
    /**
     * Optional role ARN. If set then used for AWS IAM Authenticator.
     */
    roleARN?: string;
    /**
     * Settings to enable transport layer security.
     */
    tlsClientConfigs?: outputs.PlatformGitopsClusterRequestClusterConfigTlsClientConfig[];
    /**
     * Username of the server of the cluster.
     */
    username?: string;
}

export interface PlatformGitopsClusterRequestClusterConfigExecProviderConfig {
    /**
     * Preferred input version of the ExecInfo.
     */
    apiVersion?: string;
    /**
     * Arguments to pass to the command when executing it.
     */
    args: string[];
    /**
     * Command to execute.
     */
    command?: string;
    /**
     * Additional environment variables to expose to the process.
     */
    env?: {[key: string]: string};
    /**
     * Message displayed when the executable is not found.
     */
    installHint?: string;
}

export interface PlatformGitopsClusterRequestClusterConfigTlsClientConfig {
    /**
     * CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
     */
    caData?: string;
    /**
     * Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
     */
    certData?: string;
    /**
     * Indicates if the TLS connection to the cluster should be insecure.
     */
    insecure?: boolean;
    /**
     * Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
     */
    keyData?: string;
    /**
     * Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
     */
    serverName?: string;
}

export interface PlatformGitopsClusterRequestClusterInfo {
    apiVersions: string[];
    applicationsCount: string;
    cacheInfos: outputs.PlatformGitopsClusterRequestClusterInfoCacheInfo[];
    connectionStates: outputs.PlatformGitopsClusterRequestClusterInfoConnectionState[];
    serverVersion: string;
}

export interface PlatformGitopsClusterRequestClusterInfoCacheInfo {
    apisCount: string;
    lastCacheSyncTime: string;
    resourcesCount: string;
}

export interface PlatformGitopsClusterRequestClusterInfoConnectionState {
    attemptedAts: outputs.PlatformGitopsClusterRequestClusterInfoConnectionStateAttemptedAt[];
    message: string;
    status: string;
}

export interface PlatformGitopsClusterRequestClusterInfoConnectionStateAttemptedAt {
    nanos: number;
    seconds: string;
}

export interface PlatformGitopsClusterRequestClusterRefreshRequestedAt {
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     */
    nanos?: number;
    /**
     * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     */
    seconds?: string;
}

export interface PlatformGitopsGnupgRequest {
    /**
     * Public key details.
     */
    publickeys?: outputs.PlatformGitopsGnupgRequestPublickey[];
    /**
     * Indicates if the GnuPG Key should be inserted if not present or updated if present.
     */
    upsert: boolean;
}

export interface PlatformGitopsGnupgRequestPublickey {
    /**
     * Fingerprint is the fingerprint of the key
     */
    fingerprint: string;
    /**
     * KeyData holds the raw key data, in base64 encoded format.
     */
    keyData: string;
    /**
     * KeyID specifies the key ID, in hexadecimal string format.
     */
    keyId: string;
    /**
     * Owner holds the owner identification, e.g. a name and e-mail address
     */
    owner: string;
    /**
     * SubType holds the key's sub type
     */
    subType: string;
    /**
     * Trust holds the level of trust assigned to this key
     */
    trust: string;
}

export interface PlatformGitopsRepoCertRequest {
    /**
     * certificates details.
     */
    certificates?: outputs.PlatformGitopsRepoCertRequestCertificate[];
    /**
     * Indicates if the GitOps repository certificate should be updated if existing and inserted if not.
     */
    upsert?: boolean;
}

export interface PlatformGitopsRepoCertRequestCertificate {
    /**
     * List of certificates to be processed.
     */
    items?: outputs.PlatformGitopsRepoCertRequestCertificateItem[];
    /**
     * metadata details
     */
    metadatas?: outputs.PlatformGitopsRepoCertRequestCertificateMetadata[];
}

export interface PlatformGitopsRepoCertRequestCertificateItem {
    /**
     * CertData contains the actual certificate data, dependent on the certificate type. The value should be base64 encoded
     */
    certData?: string;
    /**
     * CertInfo will hold additional certificate info, dependent on the certificate type .
     */
    certInfo?: string;
    /**
     * CertSubType specifies the sub type of the cert, i.e. ssh-rsa.
     */
    certSubType?: string;
    /**
     * CertType specifies the type of the certificate - currently one of https or ssh.
     */
    certType?: string;
    /**
     * ServerName specifies the DNS name of the server this certificate is intended.
     */
    serverName?: string;
}

export interface PlatformGitopsRepoCertRequestCertificateMetadata {
    /**
     * continue may be set if the user set a limit on the number of items returned.
     */
    continue?: string;
    /**
     * subsequent items in the list.
     */
    remainingItemCount?: string;
    /**
     * Identifies the server's internal version.
     */
    resourceVersion?: string;
    /**
     * selfLink is a URL representing this object.
     */
    selfLink?: string;
}

export interface PlatformGitopsRepoCredCred {
    /**
     * Specifies whether helm-oci support should be enabled for this repo.
     */
    enableOci?: boolean;
    /**
     * Specifies the GitHub API URL for GitHub app authentication.
     */
    githubAppEnterpriseBaseUrl?: string;
    /**
     * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
     */
    githubAppId?: string;
    /**
     * Specifies the ID of the installed GitHub App for GitHub app authentication.
     */
    githubAppInstallationId?: string;
    /**
     * github_app_private_key specifies the private key PEM data for authentication via GitHub app.
     */
    githubAppPrivateKey?: string;
    /**
     * Password or PAT to be used for authenticating the remote repository.
     */
    password?: string;
    /**
     * SSH Key in PEM format for authenticating the repository. Used only for Git repository.
     */
    sshPrivateKey?: string;
    /**
     * Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
     */
    tlsClientCertData?: string;
    /**
     * Private key in PEM format for authenticating at the repo server. This is used for mTLS.
     */
    tlsClientCertKey?: string;
    /**
     * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
     */
    type?: string;
    /**
     * URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
     */
    url?: string;
    /**
     * Username to be used for authenticating the remote repository.
     */
    username?: string;
}

export interface PlatformGitopsRepositoryEcrGen {
    /**
     * JWT authentication specific configuration.
     */
    jwtAuth?: outputs.PlatformGitopsRepositoryEcrGenJwtAuth;
    /**
     * AWS region.
     */
    region?: string;
    /**
     * Secret reference to the AWS credentials.
     */
    secretRef?: outputs.PlatformGitopsRepositoryEcrGenSecretRef;
}

export interface PlatformGitopsRepositoryEcrGenJwtAuth {
    /**
     * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
     */
    audiences?: string[];
    /**
     * The name of the ServiceAccount resource being referred to.
     */
    name?: string;
    /**
     * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
     */
    namespace?: string;
}

export interface PlatformGitopsRepositoryEcrGenSecretRef {
    /**
     * AWS access key id.
     */
    awsAccessKeyId?: string;
    /**
     * AWS secret access key.
     */
    awsSecretAccessKey?: string;
    /**
     * AWS session token.
     */
    awsSessionToken?: string;
}

export interface PlatformGitopsRepositoryGcrGen {
    /**
     * GCP access key.
     */
    accessKey?: string;
    /**
     * GCP project id.
     */
    projectId?: string;
    /**
     * GCP workload identity.
     */
    workloadIdentity?: outputs.PlatformGitopsRepositoryGcrGenWorkloadIdentity;
}

export interface PlatformGitopsRepositoryGcrGenWorkloadIdentity {
    /**
     * Cluster location.
     */
    clusterLocation?: string;
    /**
     * Cluster name.
     */
    clusterName?: string;
    /**
     * Cluster project id.
     */
    clusterProjectId?: string;
    /**
     * Service account reference.
     */
    serviceAccountRef?: outputs.PlatformGitopsRepositoryGcrGenWorkloadIdentityServiceAccountRef;
}

export interface PlatformGitopsRepositoryGcrGenWorkloadIdentityServiceAccountRef {
    /**
     * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
     */
    audiences?: string[];
    /**
     * The name of the ServiceAccount resource being referred to.
     */
    name?: string;
    /**
     * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
     */
    namespace?: string;
}

export interface PlatformGitopsRepositoryRepo {
    /**
     * Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS_ANONYMOUS_CONNECTION_TYPE"
     */
    connectionType: string;
    /**
     * Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
     */
    enableLfs?: boolean;
    /**
     * Indicates if helm-oci support must be enabled for this repo.
     */
    enableOci?: boolean;
    /**
     * Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
     */
    githubAppEnterpriseBaseUrl?: string;
    /**
     * Id of the GitHub app used to access the repo.
     */
    githubAppId?: string;
    /**
     * Installation id of the GitHub app used to access the repo.
     */
    githubAppInstallationId?: string;
    /**
     * GitHub app private key PEM data.
     */
    githubAppPrivateKey?: string;
    /**
     * Indicates if the credentials were inherited from a repository credential.
     */
    inheritedCreds?: boolean;
    /**
     * Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
     */
    insecure?: boolean;
    /**
     * Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
     */
    insecureIgnoreHostKey?: boolean;
    /**
     * Name to be used for this repo. Only used with Helm repos.
     */
    name?: string;
    /**
     * Password or PAT to be used for authenticating the remote repository.
     */
    password?: string;
    /**
     * The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
     */
    project: string;
    /**
     * The HTTP/HTTPS proxy used to access the repo.
     */
    proxy?: string;
    /**
     * URL to the remote repository.
     */
    repo: string;
    /**
     * SSH Key in PEM format for authenticating the repository. Used only for Git repository.
     */
    sshPrivateKey?: string;
    /**
     * Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
     */
    tlsClientCertData?: string;
    /**
     * Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
     */
    tlsClientCertKey?: string;
    /**
     * Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
     */
    type_: string;
    /**
     * Username to be used for authenticating the remote repository.
     */
    username?: string;
}

export interface PlatformGitopsRepositoryUpdateMask {
    /**
     * The set of field mask paths.
     */
    paths?: string[];
}

export interface PlatformInfrastructureGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * import infrastructure from git
     */
    importFromGit: boolean;
    /**
     * force import infrastructure from remote even if same file path already exist
     */
    isForceImport: boolean;
    /**
     * If the gitProvider is HarnessCode
     */
    isHarnesscodeRepo: boolean;
    /**
     * If a new branch creation is requested.
     */
    isNewBranch: boolean;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating infrastructure.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating infrastructure.
     */
    lastObjectId: string;
    /**
     * If the Entity is to be fetched from cache
     */
    loadFromCache: string;
    /**
     * If the Entity is to be fetched from fallbackBranch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    parentEntityConnectorRef: string;
    /**
     * Name of the repository where parent entity lies.
     */
    parentEntityRepoName: string;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformInputSetGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branchName: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    parentEntityConnectorRef: string;
    /**
     * Repository name for Parent Entity (Pipeline).
     */
    parentEntityRepoName: string;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformInputSetGitImportInfo {
    /**
     * Name of the branch.
     */
    branchName?: string;
    /**
     * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef?: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath?: string;
    isForceImport?: boolean;
    /**
     * Name of the repository.
     */
    repoName?: string;
}

export interface PlatformInputSetInputSetImportRequest {
    /**
     * Description of the input set.
     */
    inputSetDescription?: string;
    /**
     * Name of the input set.
     */
    inputSetName?: string;
}

export interface PlatformManualFreezeCurrentOrUpcomingWindow {
    endTime: number;
    startTime: number;
}

export interface PlatformManualFreezeFreezeWindow {
    duration: string;
    endTime: string;
    recurrences: outputs.PlatformManualFreezeFreezeWindowRecurrence[];
    startTime: string;
    timeZone: string;
}

export interface PlatformManualFreezeFreezeWindowRecurrence {
    recurrenceSpecs: outputs.PlatformManualFreezeFreezeWindowRecurrenceRecurrenceSpec[];
    type: string;
}

export interface PlatformManualFreezeFreezeWindowRecurrenceRecurrenceSpec {
    until: string;
    value: number;
}

export interface PlatformMonitoredServiceRequest {
    /**
     * Set of change sources for the monitored service.
     */
    changeSources?: outputs.PlatformMonitoredServiceRequestChangeSource[];
    /**
     * Dependencies of the monitored service.
     */
    dependencies?: outputs.PlatformMonitoredServiceRequestDependency[];
    /**
     * Description for the monitored service.
     */
    description?: string;
    /**
     * Enable or disable the monitored service.
     *
     * @deprecated Deprecated
     */
    enabled?: boolean;
    /**
     * Environment in which the service is deployed.
     */
    environmentRef: string;
    /**
     * Environment reference list for the monitored service.
     */
    environmentRefLists?: string[];
    /**
     * Set of health sources for the monitored service.
     */
    healthSources?: outputs.PlatformMonitoredServiceRequestHealthSource[];
    /**
     * Name for the monitored service.
     */
    name: string;
    /**
     * Notification rule references for the monitored service.
     */
    notificationRuleRefs?: outputs.PlatformMonitoredServiceRequestNotificationRuleRef[];
    /**
     * Service reference for the monitored service.
     */
    serviceRef: string;
    /**
     * Tags for the monitored service. comma-separated key value string pairs.
     */
    tags?: string[];
    /**
     * Template reference for the monitored service.
     */
    templateRef?: string;
    /**
     * Type of the monitored service.
     */
    type: string;
    /**
     * Template version label for the monitored service.
     */
    versionLabel?: string;
}

export interface PlatformMonitoredServiceRequestChangeSource {
    /**
     * Category of the change source.
     */
    category: string;
    /**
     * Enable or disable the change source.
     */
    enabled?: boolean;
    /**
     * Identifier of the change source.
     */
    identifier: string;
    /**
     * Name of the change source.
     */
    name: string;
    /**
     * Specification of the change source. Depends on the type of the change source.
     */
    spec?: string;
    /**
     * Type of the change source.
     */
    type: string;
}

export interface PlatformMonitoredServiceRequestDependency {
    /**
     * Dependency metadata for the monitored service.
     */
    dependencyMetadata?: string;
    /**
     * Monitored service identifier of the dependency.
     */
    monitoredServiceIdentifier: string;
    /**
     * Type of the service dependency.
     */
    type: string;
}

export interface PlatformMonitoredServiceRequestHealthSource {
    /**
     * Identifier of the health source.
     */
    identifier: string;
    /**
     * Name of the health source.
     */
    name: string;
    /**
     * Specification of the health source. Depends on the type of the health source.
     */
    spec: string;
    /**
     * Type of the health source.
     */
    type: string;
    /**
     * Version of the health source.
     */
    version?: string;
}

export interface PlatformMonitoredServiceRequestNotificationRuleRef {
    /**
     * Enable or disable notification rule reference for the monitored service.
     */
    enabled: boolean;
    /**
     * Notification rule reference for the monitored service.
     */
    notificationRuleRef: string;
}

export interface PlatformNotificationRuleRequest {
    /**
     * Notification Rule conditions specification.
     */
    conditions: outputs.PlatformNotificationRuleRequestCondition[];
    /**
     * Name for the Notification Rule.
     */
    name: string;
    /**
     * Notification Method specifications.
     */
    notificationMethod: outputs.PlatformNotificationRuleRequestNotificationMethod;
    /**
     * Type of the Notification Rule.
     */
    type: string;
}

export interface PlatformNotificationRuleRequestCondition {
    /**
     * Specification of the notification condition. Depends on the type of the notification condition.
     */
    spec?: string;
    /**
     * Type of the condition.
     */
    type: string;
}

export interface PlatformNotificationRuleRequestNotificationMethod {
    /**
     * Specification of the notification method. Depends on the type of the notification method.
     */
    spec?: string;
    /**
     * Type of the Notification Method.
     */
    type: string;
}

export interface PlatformOverridesGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * If the repo is in harness code
     */
    isHarnessCodeRepo: boolean;
    /**
     * If the branch being created is new
     */
    isNewBranch: boolean;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating override.
     */
    lastObjectId: string;
    /**
     * Load service yaml from catch
     */
    loadFromCache: boolean;
    /**
     * Load service yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformPipelineFiltersFilterProperties {
    /**
     * description of the pipline filter.
     */
    description?: string;
    /**
     * Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
     */
    filterType: string;
    /**
     * module properties of the pipline filter.
     */
    moduleProperties?: outputs.PlatformPipelineFiltersFilterPropertiesModuleProperties;
    /**
     * Name of the pipeline filter.
     */
    name?: string;
    /**
     * Pipeline identifiers to filter on.
     */
    pipelineIdentifiers?: string[];
    /**
     * Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
     */
    pipelineTags?: {[key: string]: string}[];
    /**
     * Tags to associate with the resource. Tags should be in the form `name:value`.
     */
    tags?: string[];
}

export interface PlatformPipelineFiltersFilterPropertiesModuleProperties {
    /**
     * CD related properties to be filtered on.
     */
    cd?: outputs.PlatformPipelineFiltersFilterPropertiesModulePropertiesCd;
    /**
     * CI related properties to be filtered on.
     */
    ci?: outputs.PlatformPipelineFiltersFilterPropertiesModulePropertiesCi;
}

export interface PlatformPipelineFiltersFilterPropertiesModulePropertiesCd {
    /**
     * Artifact display names of the CD pipeline.
     */
    artifactDisplayNames?: string[];
    /**
     * Deployment type of the CD pipeline, eg. Kubernetes
     */
    deploymentTypes?: string;
    /**
     * Environment names of the CD pipeline.
     */
    environmentNames?: string[];
    /**
     * Service names of the CD pipeline.
     */
    serviceNames?: string[];
}

export interface PlatformPipelineFiltersFilterPropertiesModulePropertiesCi {
    /**
     * Branch which was used while building.
     */
    branch?: string;
    /**
     * Build type of the pipeline. Possible values: branch.
     */
    buildType?: string;
    /**
     * CI execution info for the pipeline.
     */
    ciExecutionInfo?: outputs.PlatformPipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo;
    /**
     * name of the repository used in the pipeline.
     */
    repoNames?: string;
    /**
     * Tags to associate with the CI pipeline resource.
     */
    tag?: string;
}

export interface PlatformPipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo {
    /**
     * Event for the ci execution, Possible values: pullRequest.
     */
    event?: string;
    /**
     * The pull request details of the CI pipeline.
     */
    pullRequest?: outputs.PlatformPipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest;
}

export interface PlatformPipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest {
    /**
     * Source branch of the pull request.
     */
    sourceBranch?: string;
    /**
     * Target branch of the pull request.
     */
    targetBranch?: string;
}

export interface PlatformPipelineGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branchName: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformPipelineGitImportInfo {
    /**
     * Name of the branch.
     */
    branchName?: string;
    /**
     * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef?: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath?: string;
    /**
     * Name of the repository.
     */
    repoName?: string;
}

export interface PlatformPipelinePipelineImportRequest {
    /**
     * Description of the pipeline.
     */
    pipelineDescription?: string;
    /**
     * Name of the pipeline.
     */
    pipelineName?: string;
}

export interface PlatformPolicysetPolicy {
    /**
     * Account Identifier of the account
     */
    identifier: string;
    /**
     * Policy failure response - 'warning' for continuation, 'error' for exit
     */
    severity: string;
}

export interface PlatformRepoRuleBranchBypass {
    /**
     * Allow users with repository edit permission to bypass.
     */
    repoOwners?: boolean;
    /**
     * List of user ids with who can bypass.
     */
    userIds?: string[];
}

export interface PlatformRepoRuleBranchPattern {
    /**
     * Should rule apply to default branch of the repository.
     */
    defaultBranch?: boolean;
    /**
     * Globstar branch patterns on which rules will NOT be applied.
     */
    excludes?: string[];
    /**
     * Globstar branch patterns on which rules will be applied.
     */
    includes?: string[];
}

export interface PlatformRepoRuleBranchPolicy {
    /**
     * Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
     */
    allowMergeStrategies?: string[];
    /**
     * Only allow users with bypass permission to create matching branches.
     */
    blockBranchCreation?: boolean;
    /**
     * Only allow users with bypass permission to delete matching branches.
     */
    blockBranchDeletion?: boolean;
    /**
     * Automatically delete the source branch of a pull request after it is merged.
     */
    deleteBranchOnMerge?: boolean;
    /**
     * Require approval on pull requests from one reviewer for each codeowner rule.
     */
    requireCodeOwners?: boolean;
    /**
     * Require re-approval when there are new changes in the pull request.
     */
    requireLatestCommitApproval?: boolean;
    /**
     * Require approval on pull requests from a minimum number of reviewers.
     */
    requireMinimumApprovalCount?: number;
    /**
     * Require all request for changes have been resolved.
     */
    requireNoChangeRequest?: boolean;
    /**
     * Do not allow any changes to matching branches without a pull request.
     */
    requirePullRequest?: boolean;
    /**
     * All comments on a pull request must be resolved before it can be merged.
     */
    requireResolveAllComments?: boolean;
    /**
     * Selected status checks must pass before a pull request can be merged.
     */
    requireStatusChecks?: string[];
}

export interface PlatformRepoSource {
    /**
     * The host URL for the import source.
     */
    host?: string;
    /**
     * The password for authentication when importing.
     */
    password?: string;
    /**
     * The full identifier of the repository on the SCM provider's platform.
     */
    repo?: string;
    /**
     * The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
     */
    type?: string;
    /**
     * The username for authentication when importing.
     */
    username?: string;
}

export interface PlatformResourceGroupIncludedScope {
    /**
     * Account Identifier of the account
     */
    accountId?: string;
    /**
     * Can be one of these 2 EXCLUDING_CHILD_SCOPES or INCLUDING_CHILD_SCOPES
     */
    filter: string;
    /**
     * Organization Identifier
     */
    orgId?: string;
    /**
     * Project Identifier
     */
    projectId?: string;
}

export interface PlatformResourceGroupResourceFilter {
    /**
     * Include all resource or not
     */
    includeAllResources?: boolean;
    /**
     * Resources for a resource group
     */
    resources?: outputs.PlatformResourceGroupResourceFilterResource[];
}

export interface PlatformResourceGroupResourceFilterResource {
    /**
     * Used to filter resources on their attributes
     */
    attributeFilters?: outputs.PlatformResourceGroupResourceFilterResourceAttributeFilter[];
    /**
     * List of the identifiers
     */
    identifiers?: string[];
    /**
     * Type of the resource
     */
    resourceType: string;
}

export interface PlatformResourceGroupResourceFilterResourceAttributeFilter {
    /**
     * Name of the attribute. Valid values are `category` or `type`.
     */
    attributeName?: string;
    /**
     * Value of the attributes.Valid values for `category` are [ARTIFACTORY,CLOUD_COST,CLOUD_PROVIDER,CODE_REPO,MONITORING,SECRET_MANAGER,TICKETING] and for `type` are [Production,PreProduction]
     */
    attributeValues?: string[];
}

export interface PlatformRoleAssignmentsPrincipal {
    /**
     * Identifier.
     */
    identifier?: string;
    /**
     * Scope level.
     */
    scopeLevel: string;
    /**
     * Type.
     */
    type: string;
}

export interface PlatformSecretSshkeyKerberos {
    /**
     * Username to use for authentication.
     */
    principal: string;
    /**
     * Reference to a secret containing the password to use for authentication.
     */
    realm: string;
    /**
     * Method to generate tgt
     */
    tgtGenerationMethod?: string;
    /**
     * Authenticate to App Dynamics using username and password.
     */
    tgtKeyTabFilePathSpec?: outputs.PlatformSecretSshkeyKerberosTgtKeyTabFilePathSpec;
    /**
     * Authenticate to App Dynamics using username and password.
     */
    tgtPasswordSpec?: outputs.PlatformSecretSshkeyKerberosTgtPasswordSpec;
}

export interface PlatformSecretSshkeyKerberosTgtKeyTabFilePathSpec {
    /**
     * key path
     */
    keyPath?: string;
}

export interface PlatformSecretSshkeyKerberosTgtPasswordSpec {
    /**
     * password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
     */
    password?: string;
}

export interface PlatformSecretSshkeySsh {
    /**
     * This specifies SSH credential type as Password, KeyPath or KeyReference
     */
    credentialType: string;
    /**
     * SSH credential of type keyReference
     */
    sshPasswordCredential?: outputs.PlatformSecretSshkeySshSshPasswordCredential;
    /**
     * SSH credential of type keyPath
     */
    sshkeyPathCredential?: outputs.PlatformSecretSshkeySshSshkeyPathCredential;
    /**
     * SSH credential of type keyReference
     */
    sshkeyReferenceCredential?: outputs.PlatformSecretSshkeySshSshkeyReferenceCredential;
}

export interface PlatformSecretSshkeySshSshPasswordCredential {
    /**
     * SSH Password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
     */
    password: string;
    /**
     * SSH Username.
     */
    userName: string;
}

export interface PlatformSecretSshkeySshSshkeyPathCredential {
    /**
     * Encrypted Passphrase . To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
     */
    encryptedPassphrase?: string;
    /**
     * Path of the key file.
     */
    keyPath: string;
    /**
     * SSH Username.
     */
    userName: string;
}

export interface PlatformSecretSshkeySshSshkeyReferenceCredential {
    /**
     * Encrypted Passphrase. To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
     */
    encryptedPassphrase?: string;
    /**
     * SSH key. To reference a key at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a key at the account scope, prefix 'account` to the expression: account.{identifier}
     */
    key: string;
    /**
     * SSH Username.
     */
    userName: string;
}

export interface PlatformSecretTextAdditionalMetadata {
    values?: outputs.PlatformSecretTextAdditionalMetadataValue[];
}

export interface PlatformSecretTextAdditionalMetadataValue {
    version?: string;
}

export interface PlatformServiceGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * If the repo is in harness code
     */
    isHarnessCodeRepo: boolean;
    /**
     * If the branch being created is new
     */
    isNewBranch: boolean;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * Load service yaml from catch
     */
    loadFromCache: boolean;
    /**
     * Load service yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformServiceOverridesV2GitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branch: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * If the repo is in harness code
     */
    isHarnessCodeRepo: boolean;
    /**
     * If the branch being created is new
     */
    isNewBranch: boolean;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating override.
     */
    lastObjectId: string;
    /**
     * Load service yaml from catch
     */
    loadFromCache: boolean;
    /**
     * Load service yaml from fallback branch
     */
    loadFromFallbackBranch: boolean;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformSloRequest {
    /**
     * Description for the SLO.
     */
    description?: string;
    /**
     * Name for the SLO.
     */
    name: string;
    /**
     * Notification rule references for the SLO.
     */
    notificationRuleRefs?: outputs.PlatformSloRequestNotificationRuleRef[];
    /**
     * SLO Target specification.
     */
    sloTarget: outputs.PlatformSloRequestSloTarget;
    /**
     * Specification of the SLO.
     */
    spec: string;
    /**
     * Tags for the SLO. comma-separated key value string pairs.
     */
    tags?: string[];
    /**
     * Type of the SLO.
     */
    type: string;
    /**
     * User journey reference list for the SLO.
     */
    userJourneyRefs: string[];
}

export interface PlatformSloRequestNotificationRuleRef {
    /**
     * Enable or disable notification rule reference for the SLO.
     */
    enabled: boolean;
    /**
     * Notification rule reference for the SLO.
     */
    notificationRuleRef: string;
}

export interface PlatformSloRequestSloTarget {
    /**
     * Target percentage for the SLO.
     */
    sloTargetPercentage: number;
    /**
     * Specification of the SLO Target.
     */
    spec: string;
    /**
     * Type of the SLO target.
     */
    type: string;
}

export interface PlatformTemplateFiltersFilterProperties {
    /**
     * Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
     */
    filterType: string;
    /**
     * Tags to associate with the resource. Tags should be in the form `name:value`.
     */
    tags?: string[];
}

export interface PlatformTemplateGitDetails {
    /**
     * Name of the default branch (this checks out a new branch titled by branch_name).
     */
    baseBranch: string;
    /**
     * Name of the branch.
     */
    branchName: string;
    /**
     * Commit message used for the merge commit.
     */
    commitMessage: string;
    /**
     * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath: string;
    /**
     * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
     */
    lastCommitId: string;
    /**
     * Last object identifier (for Github). To be provided only when updating Pipeline.
     */
    lastObjectId: string;
    /**
     * Name of the repository.
     */
    repoName: string;
    /**
     * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
     */
    storeType: string;
}

export interface PlatformTemplateGitImportDetails {
    /**
     * Name of the branch.
     */
    branchName?: string;
    /**
     * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
     */
    connectorRef?: string;
    /**
     * File path of the Entity in the repository.
     */
    filePath?: string;
    isForceImport?: boolean;
    /**
     * Name of the repository.
     */
    repoName?: string;
}

export interface PlatformTemplateTemplateImportRequest {
    /**
     * Description of the template.
     */
    templateDescription?: string;
    /**
     * Name of the template.
     */
    templateName?: string;
    /**
     * Version of the template.
     */
    templateVersion?: string;
}

export interface PlatformUserRoleBinding {
    /**
     * Managed Role of the user.
     */
    managedRole?: boolean;
    /**
     * Resource Group Identifier of the user.
     */
    resourceGroupIdentifier?: string;
    /**
     * Resource Group Name of the user.
     */
    resourceGroupName?: string;
    /**
     * Role Identifier of the user.
     */
    roleIdentifier?: string;
    /**
     * Role Name Identifier of the user.
     */
    roleName?: string;
}

export interface PlatformUsergroupNotificationConfig {
    /**
     * Group email.
     */
    groupEmail?: string;
    /**
     * Url of Microsoft teams webhook.
     */
    microsoftTeamsWebhookUrl?: string;
    /**
     * Pager duty key.
     */
    pagerDutyKey?: string;
    /**
     * Send email to all the group members.
     */
    sendEmailToAllUsers: boolean;
    /**
     * Url of slack webhook.
     */
    slackWebhookUrl?: string;
    /**
     * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
     */
    type?: string;
}

export interface PlatformVariablesSpec {
    /**
     * FixedValue of the variable
     */
    fixedValue: string;
    /**
     * Type of Value of the Variable. For now only FIXED is supported
     */
    valueType: string;
}

export interface PlatformWorkspaceEnvironmentVariable {
    /**
     * Key is the identifier for the variable. Must be unique within the workspace.
     */
    key: string;
    /**
     * Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
     */
    value: string;
    /**
     * Value type indicates the value type of the variable. Currently we support string and secret.
     */
    valueType: string;
}

export interface PlatformWorkspaceTerraformVariable {
    /**
     * Key is the identifier for the variable. Must be unique within the workspace.
     */
    key: string;
    /**
     * Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
     */
    value: string;
    /**
     * Value type indicates the value type of the variable. Currently we support string and secret.
     */
    valueType: string;
}

export interface PlatformWorkspaceTerraformVariableFile {
    /**
     * Repository is the name of the repository to fetch the code from.
     */
    repository: string;
    /**
     * Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit is set
     */
    repositoryBranch?: string;
    /**
     * Repository commit is commit or tag to fetch the variables from. This cannot be set if repository branch is set.
     */
    repositoryCommit?: string;
    /**
     * Repository connector is the reference to the connector used to fetch the variables.
     */
    repositoryConnector: string;
    /**
     * Repository path is the path in which the variables reside.
     */
    repositoryPath?: string;
}

export interface ServiceAmiVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceAwsCodedeployVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceAwsLambdaVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceEcsVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceHelmVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceKubernetesVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceSshVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceTanzuVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface ServiceWinrmVariable {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
     */
    type: string;
    /**
     * Value of the variable
     */
    value: string;
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: number;
    /**
     * Name of the principal for authentication
     */
    principal: string;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: string;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: outputs.SshCredentialKerberosAuthenticationTgtGenerationMethod;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    /**
     * The id of the encrypted text secret
     */
    kerberosPasswordId?: string;
    /**
     * The path to the key tab file
     */
    keyTabFilePath?: string;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphrase_secret_id` or `ssh_key_file_id` should be used
     */
    inlineSsh?: outputs.SshCredentialSshAuthenticationInlineSsh;
    /**
     * The port to connect to
     */
    port: number;
    /**
     * Server password authentication configuration
     */
    serverPassword?: outputs.SshCredentialSshAuthenticationServerPassword;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: outputs.SshCredentialSshAuthenticationSshKeyFile;
    /**
     * The username to use when connecting to ssh
     */
    username: string;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    /**
     * The id of the encrypted secret to use
     */
    passphraseSecretId?: string;
    /**
     * The id of the secret containing the SSH key
     */
    sshKeyFileId: string;
}

export interface SshCredentialSshAuthenticationServerPassword {
    /**
     * The id of the encrypted secret
     */
    passwordSecretId: string;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    /**
     * The id of the secret containing the password to use for the ssh key
     */
    passphraseSecretId?: string;
    /**
     * The path to the key file on the delegate
     */
    path: string;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
     */
    environmentId?: string;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: string;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: string[];
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: string;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: boolean;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: boolean;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: string;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: string;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER_OTHER_ACCOUNT_FUNCTIONS, CREATE_AND_DELETE_APPLICATION, CREATE_CUSTOM_DASHBOARDS, MANAGE_ALERT_NOTIFICATION_RULES, MANAGE_API_KEYS, MANAGE_APPLICATION_STACKS, MANAGE_AUTHENTICATION_SETTINGS, MANAGE_CLOUD_PROVIDERS, MANAGE_CONFIG_AS_CODE, MANAGE_CONNECTORS, MANAGE_CUSTOM_DASHBOARDS, MANAGE_DELEGATE_PROFILES, MANAGE_DELEGATES, MANAGE_DEPLOYMENT_FREEZES, MANAGE_IP_WHITELIST, MANAGE_PIPELINE_GOVERNANCE_STANDARDS, MANAGE_RESTRICTED_ACCESS, MANAGE_SECRET_MANAGERS, MANAGE_SECRETS, MANAGE_SSH_AND_WINRM, MANAGE_TAGS, MANAGE_TEMPLATE_LIBRARY, MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS, MANAGE_USERS_AND_GROUPS, READ_USERS_AND_GROUPS, VIEW_AUDITS, VIEW_USER_AND_USER_GROUPS_AND_API_KEYS
     */
    accountPermissions?: string[];
    /**
     * Application specific permissions
     */
    appPermissions?: outputs.UserGroupPermissionsAppPermissions;
}

export interface UserGroupPermissionsAppPermissions {
    /**
     * The permission to perform actions against all resources.
     */
    alls?: outputs.UserGroupPermissionsAppPermissionsAll[];
    /**
     * Permission configuration to perform actions against deployments.
     */
    deployments?: outputs.UserGroupPermissionsAppPermissionsDeployment[];
    /**
     * Permission configuration to perform actions against workflows.
     */
    environments?: outputs.UserGroupPermissionsAppPermissionsEnvironment[];
    /**
     * Permission configuration to perform actions against pipelines.
     */
    pipelines?: outputs.UserGroupPermissionsAppPermissionsPipeline[];
    /**
     * Permission configuration to perform actions against provisioners.
     */
    provisioners?: outputs.UserGroupPermissionsAppPermissionsProvisioner[];
    /**
     * Permission configuration to perform actions against services.
     */
    services?: outputs.UserGroupPermissionsAppPermissionsService[];
    /**
     * Permission configuration to perform actions against templates.
     */
    templates?: outputs.UserGroupPermissionsAppPermissionsTemplate[];
    /**
     * Permission configuration to perform actions against workflows.
     */
    workflows?: outputs.UserGroupPermissionsAppPermissionsWorkflow[];
}

export interface UserGroupPermissionsAppPermissionsAll {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE, EXECUTE_WORKFLOW, EXECUTE_PIPELINE, ROLLBACK_WORKFLOW
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    /**
     * The actions allowed to be performed. Valid options are READ, EXECUTE_WORKFLOW, EXECUTE_PIPELINE, ROLLBACK_WORKFLOW, ABORT_WORKFLOW
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
    /**
     * The environment IDs to which the permission applies. Leave empty to apply to all environments.
     */
    envIds?: string[];
    /**
     * The filters to apply to the action. Valid options are: NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    filters?: string[];
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
    /**
     * The environment IDs to which the permission applies. Leave empty to apply to all environments.
     */
    envIds?: string[];
    /**
     * The filters to apply to the action. Valid options are: NON_PRODUCTION_ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    filters?: string[];
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    /**
     * The actions allowed to be performed. Valid options are [CREATE READ UPDATE DELETE]
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
    /**
     * The environment IDs to which the permission applies. Leave empty to apply to all environments.
     */
    envIds?: string[];
    /**
     * The filters to apply to the action. Valid options are: NON_PRODUCTION_PIPELINES, PRODUCTION_PIPELINES.
     */
    filters?: string[];
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
    /**
     * The provisioner IDs to which the permission applies. Leave empty to apply to all provisioners.
     */
    provisionerIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsService {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
    /**
     * The service IDs to which the permission applies. Leave empty to apply to all services.
     */
    serviceIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
    /**
     * The template IDs to which the permission applies. Leave empty to apply to all environments.
     */
    templateIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: string[];
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: string[];
    /**
     * The filters to apply to the action. Valid options are: NON_PRODUCTION_WORKFLOWS, PRODUCTION_WORKFLOWS, WORKFLOW_TEMPLATES.
     */
    filters?: string[];
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

