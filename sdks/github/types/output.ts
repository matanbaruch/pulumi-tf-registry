// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ActionsOrganizationPermissionsAllowedActionsConfig {
    /**
     * Whether GitHub-owned actions are allowed in the organization.
     */
    githubOwnedAllowed: boolean;
    /**
     * Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, 'monalisa/octocat@', 'monalisa/octocat@v2', 'monalisa/'.
     */
    patternsAlloweds?: string[];
    /**
     * Whether actions in GitHub Marketplace from verified creators are allowed. Set to 'true' to allow all GitHub Marketplace actions by verified creators.
     */
    verifiedAllowed?: boolean;
}

export interface ActionsOrganizationPermissionsEnabledRepositoriesConfig {
    /**
     * List of repository IDs to enable for GitHub Actions.
     */
    repositoryIds: number[];
}

export interface ActionsRepositoryPermissionsAllowedActionsConfig {
    /**
     * Whether GitHub-owned actions are allowed in the repository.
     */
    githubOwnedAllowed: boolean;
    /**
     * Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, 'monalisa/octocat@', 'monalisa/octocat@v2', 'monalisa/'.
     */
    patternsAlloweds?: string[];
    /**
     * Whether actions in GitHub Marketplace from verified creators are allowed. Set to 'true' to allow all GitHub Marketplace actions by verified creators.
     */
    verifiedAllowed?: boolean;
}

export interface BranchProtectionRequiredPullRequestReview {
    /**
     * Dismiss approved reviews automatically when a new commit is pushed.
     */
    dismissStaleReviews?: boolean;
    /**
     * The list of actor Names/IDs with dismissal access. If not empty, 'restrict_dismissals' is ignored. Actor names must either begin with a '/' for users or the organization name followed by a '/' for teams.
     */
    dismissalRestrictions?: string[];
    /**
     * The list of actor Names/IDs that are allowed to bypass pull request requirements. Actor names must either begin with a '/' for users or the organization name followed by a '/' for teams.
     */
    pullRequestBypassers?: string[];
    /**
     * Require an approved review in pull requests including files with a designated code owner.
     */
    requireCodeOwnerReviews?: boolean;
    /**
     * Require that The most recent push must be approved by someone other than the last pusher.
     */
    requireLastPushApproval?: boolean;
    /**
     * Require 'x' number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6.
     */
    requiredApprovingReviewCount?: number;
    /**
     * Restrict pull request review dismissals.
     */
    restrictDismissals?: boolean;
}

export interface BranchProtectionRequiredStatusCheck {
    /**
     * The list of status checks to require in order to merge into this branch. No status checks are required by default.
     */
    contexts?: string[];
    /**
     * Require branches to be up to date before merging.
     */
    strict?: boolean;
}

export interface BranchProtectionRestrictPush {
    /**
     * Restrict pushes that create matching branches.
     */
    blocksCreations?: boolean;
    /**
     * The list of actor Names/IDs that may push to the branch. Actor names must either begin with a '/' for users or the organization name followed by a '/' for teams.
     */
    pushAllowances?: string[];
}

export interface BranchProtectionV3RequiredPullRequestReviews {
    bypassPullRequestAllowances?: outputs.BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowances;
    /**
     * Dismiss approved reviews automatically when a new commit is pushed.
     */
    dismissStaleReviews?: boolean;
    /**
     * The list of apps slugs with dismissal access. Always use slug of the app, not its name. Each app already has to have access to the repository.
     */
    dismissalApps?: string[];
    /**
     * The list of team slugs with dismissal access. Always use slug of the team, not its name. Each team already has to have access to the repository.
     */
    dismissalTeams?: string[];
    /**
     * The list of user logins with dismissal access.
     */
    dismissalUsers?: string[];
    /**
     * @deprecated Deprecated
     */
    includeAdmins?: boolean;
    /**
     * Require an approved review in pull requests including files with a designated code owner.
     */
    requireCodeOwnerReviews?: boolean;
    /**
     * Require that the most recent push must be approved by someone other than the last pusher.
     */
    requireLastPushApproval?: boolean;
    /**
     * Require 'x' number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6.
     */
    requiredApprovingReviewCount?: number;
}

export interface BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowances {
    apps?: string[];
    teams?: string[];
    users?: string[];
}

export interface BranchProtectionV3RequiredStatusChecks {
    /**
     * The list of status checks to require in order to merge into this branch. No status checks are required by default. Checks should be strings containing the 'context' and 'app_id' like so 'context:app_id'
     */
    checks?: string[];
    /**
     * @deprecated Deprecated
     */
    contexts?: string[];
    /**
     * @deprecated Deprecated
     */
    includeAdmins?: boolean;
    /**
     * Require branches to be up to date before merging.
     */
    strict?: boolean;
}

export interface BranchProtectionV3Restrictions {
    /**
     * The list of app slugs with push access.
     */
    apps?: string[];
    /**
     * The list of team slugs with push access. Always use slug of the team, not its name. Each team already has to have access to the repository.
     */
    teams?: string[];
    /**
     * The list of user logins with push access.
     */
    users?: string[];
}

export interface EnterpriseActionsPermissionsAllowedActionsConfig {
    /**
     * Whether GitHub-owned actions are allowed in the enterprise.
     */
    githubOwnedAllowed: boolean;
    /**
     * Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, 'monalisa/octocat@', 'monalisa/octocat@v2', 'monalisa/'.
     */
    patternsAlloweds?: string[];
    /**
     * Whether actions in GitHub Marketplace from verified creators are allowed. Set to 'true' to allow all GitHub Marketplace actions by verified creators.
     */
    verifiedAllowed?: boolean;
}

export interface EnterpriseActionsPermissionsEnabledOrganizationsConfig {
    /**
     * List of organization IDs to enable for GitHub Actions.
     */
    organizationIds: number[];
}

export interface GetActionsEnvironmentSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
}

export interface GetActionsEnvironmentVariablesVariable {
    createdAt: string;
    name: string;
    updatedAt: string;
    value: string;
}

export interface GetActionsOrganizationSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
    visibility: string;
}

export interface GetActionsOrganizationVariablesVariable {
    createdAt: string;
    name: string;
    updatedAt: string;
    value: string;
    visibility: string;
}

export interface GetActionsSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
}

export interface GetActionsVariablesVariable {
    createdAt: string;
    name: string;
    updatedAt: string;
    value: string;
}

export interface GetBranchProtectionRulesRule {
    pattern: string;
}

export interface GetCodespacesOrganizationSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
    visibility: string;
}

export interface GetCodespacesSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
}

export interface GetCodespacesUserSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
    visibility: string;
}

export interface GetCollaboratorsCollaborator {
    eventsUrl: string;
    followersUrl: string;
    followingUrl: string;
    gistsUrl: string;
    htmlUrl: string;
    id: number;
    login: string;
    organizationsUrl: string;
    permission: string;
    receivedEventsUrl: string;
    reposUrl: string;
    siteAdmin: boolean;
    starredUrl: string;
    subscriptionsUrl: string;
    type: string;
    url: string;
}

export interface GetDependabotOrganizationSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
    visibility: string;
}

export interface GetDependabotSecretsSecret {
    createdAt: string;
    name: string;
    updatedAt: string;
}

export interface GetExternalGroupsExternalGroup {
    groupId: number;
    groupName: string;
    updatedAt: string;
}

export interface GetIssueLabelsLabel {
    color: string;
    description: string;
    name: string;
    url: string;
}

export interface GetOrganizationExternalIdentitiesIdentity {
    login: string;
    samlIdentity: {[key: string]: string};
    scimIdentity: {[key: string]: string};
}

export interface GetOrganizationIpAllowListIpAllowList {
    allowListValue: string;
    createdAt: string;
    id: string;
    isActive: boolean;
    name: string;
    updatedAt: string;
}

export interface GetOrganizationTeamSyncGroupsGroup {
    groupDescription: string;
    groupId: string;
    groupName: string;
}

export interface GetOrganizationTeamsTeam {
    description: string;
    id: number;
    members: string[];
    name: string;
    nodeId: string;
    parent: {[key: string]: string};
    privacy: string;
    repositories: string[];
    slug: string;
}

export interface GetOrganizationWebhooksWebhook {
    active: boolean;
    id: number;
    name: string;
    type: string;
    url: string;
}

export interface GetReleaseAsset {
    browserDownloadUrl: string;
    contentType: string;
    createdAt: string;
    id: number;
    label: string;
    name: string;
    nodeId: string;
    size: number;
    updatedAt: string;
    url: string;
}

export interface GetRepositoryAutolinkReferencesAutolinkReference {
    isAlphanumeric: boolean;
    keyPrefix: string;
    targetUrlTemplate: string;
}

export interface GetRepositoryBranchesBranch {
    name: string;
    protected: boolean;
}

export interface GetRepositoryDeployKeysKey {
    id: number;
    key: string;
    title: string;
    verified: boolean;
}

export interface GetRepositoryDeploymentBranchPoliciesDeploymentBranchPolicy {
    id: string;
    name: string;
}

export interface GetRepositoryEnvironmentsEnvironment {
    name: string;
    nodeId: string;
}

export interface GetRepositoryPage {
    buildType: string;
    cname: string;
    custom404: boolean;
    htmlUrl: string;
    sources: outputs.GetRepositoryPageSource[];
    status: string;
    url: string;
}

export interface GetRepositoryPageSource {
    branch: string;
    path: string;
}

export interface GetRepositoryPullRequestsResult {
    baseRef: string;
    baseSha: string;
    body: string;
    draft: boolean;
    headOwner: string;
    headRef: string;
    headRepository: string;
    headSha: string;
    labels: string[];
    maintainerCanModify: boolean;
    number: number;
    openedAt: number;
    openedBy: string;
    state: string;
    title: string;
    updatedAt: number;
}

export interface GetRepositoryRepositoryLicense {
    content: string;
    downloadUrl: string;
    encoding: string;
    gitUrl: string;
    htmlUrl: string;
    licenses: outputs.GetRepositoryRepositoryLicenseLicense[];
    name: string;
    path: string;
    sha: string;
    size: number;
    type: string;
    url: string;
}

export interface GetRepositoryRepositoryLicenseLicense {
    body: string;
    conditions: string[];
    description: string;
    featured: boolean;
    htmlUrl: string;
    implementation: string;
    key: string;
    limitations: string[];
    name: string;
    permissions: string[];
    spdxId: string;
    url: string;
}

export interface GetRepositoryTeamsTeam {
    name: string;
    permission: string;
    slug: string;
}

export interface GetRepositoryTemplate {
    owner: string;
    repository: string;
}

export interface GetRepositoryWebhooksWebhook {
    active: boolean;
    id: number;
    name: string;
    type: string;
    url: string;
}

export interface GetTeamRepositoriesDetailed {
    repoId: number;
    roleName: string;
}

export interface GetTreeEntry {
    mode: string;
    path: string;
    sha: string;
    size: number;
    type: string;
}

export interface IssueLabelsLabel {
    /**
     * A 6 character hex code, without the leading '#', identifying the color of the label.
     */
    color: string;
    /**
     * A short description of the label.
     */
    description?: string;
    /**
     * The name of the label.
     */
    name: string;
    /**
     * The URL to the issue label.
     */
    url: string;
}

export interface OrganizationRulesetBypassActor {
    /**
     * The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
     */
    actorId: number;
    /**
     * The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
     */
    actorType: string;
    /**
     * When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
     */
    bypassMode: string;
}

export interface OrganizationRulesetConditions {
    refName: outputs.OrganizationRulesetConditionsRefName;
    /**
     * The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
     */
    repositoryIds?: number[];
    repositoryName?: outputs.OrganizationRulesetConditionsRepositoryName;
}

export interface OrganizationRulesetConditionsRefName {
    /**
     * Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
     */
    excludes: string[];
    /**
     * Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
     */
    includes: string[];
}

export interface OrganizationRulesetConditionsRepositoryName {
    /**
     * Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
     */
    excludes: string[];
    /**
     * Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
     */
    includes: string[];
    /**
     * Whether renaming of target repositories is prevented.
     */
    protected?: boolean;
}

export interface OrganizationRulesetRules {
    /**
     * Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
     */
    branchNamePattern?: outputs.OrganizationRulesetRulesBranchNamePattern;
    /**
     * Parameters to be used for the commit_author_email_pattern rule.
     */
    commitAuthorEmailPattern?: outputs.OrganizationRulesetRulesCommitAuthorEmailPattern;
    /**
     * Parameters to be used for the commit_message_pattern rule.
     */
    commitMessagePattern?: outputs.OrganizationRulesetRulesCommitMessagePattern;
    /**
     * Parameters to be used for the committer_email_pattern rule.
     */
    committerEmailPattern?: outputs.OrganizationRulesetRulesCommitterEmailPattern;
    /**
     * Only allow users with bypass permission to create matching refs.
     */
    creation?: boolean;
    /**
     * Only allow users with bypass permissions to delete matching refs.
     */
    deletion?: boolean;
    /**
     * Prevent users with push access from force pushing to branches.
     */
    nonFastForward?: boolean;
    /**
     * Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
     */
    pullRequest?: outputs.OrganizationRulesetRulesPullRequest;
    /**
     * Prevent merge commits from being pushed to matching branches.
     */
    requiredLinearHistory?: boolean;
    /**
     * Commits pushed to matching branches must have verified signatures.
     */
    requiredSignatures?: boolean;
    /**
     * Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
     */
    requiredStatusChecks?: outputs.OrganizationRulesetRulesRequiredStatusChecks;
    /**
     * Choose which Actions workflows must pass before branches can be merged into a branch that matches this rule.
     */
    requiredWorkflows?: outputs.OrganizationRulesetRulesRequiredWorkflows;
    /**
     * Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
     */
    tagNamePattern?: outputs.OrganizationRulesetRulesTagNamePattern;
    /**
     * Only allow users with bypass permission to update matching refs.
     */
    update?: boolean;
}

export interface OrganizationRulesetRulesBranchNamePattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface OrganizationRulesetRulesCommitAuthorEmailPattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface OrganizationRulesetRulesCommitMessagePattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface OrganizationRulesetRulesCommitterEmailPattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface OrganizationRulesetRulesPullRequest {
    /**
     * New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
     */
    dismissStaleReviewsOnPush?: boolean;
    /**
     * Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
     */
    requireCodeOwnerReview?: boolean;
    /**
     * Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
     */
    requireLastPushApproval?: boolean;
    /**
     * The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
     */
    requiredApprovingReviewCount?: number;
    /**
     * All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
     */
    requiredReviewThreadResolution?: boolean;
}

export interface OrganizationRulesetRulesRequiredStatusChecks {
    /**
     * Status checks that are required. Several can be defined.
     */
    requiredChecks: outputs.OrganizationRulesetRulesRequiredStatusChecksRequiredCheck[];
    /**
     * Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
     */
    strictRequiredStatusChecksPolicy?: boolean;
}

export interface OrganizationRulesetRulesRequiredStatusChecksRequiredCheck {
    /**
     * The status check context name that must be present on the commit.
     */
    context: string;
    /**
     * The optional integration ID that this status check must originate from.
     */
    integrationId?: number;
}

export interface OrganizationRulesetRulesRequiredWorkflows {
    /**
     * Actions workflows that are required. Several can be defined.
     */
    requiredWorkflows: outputs.OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflow[];
}

export interface OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflow {
    /**
     * The path to the workflow YAML definition file.
     */
    path: string;
    /**
     * The ref (branch or tag) of the workflow file to use.
     */
    ref?: string;
    /**
     * The repository in which the workflow is defined.
     */
    repositoryId: number;
}

export interface OrganizationRulesetRulesTagNamePattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface OrganizationWebhookConfiguration {
    /**
     * The content type for the payload. Valid values are either 'form' or 'json'.
     */
    contentType?: string;
    /**
     * Insecure SSL boolean toggle. Defaults to 'false'.
     */
    insecureSsl?: boolean;
    /**
     * The shared secret for the webhook
     */
    secret?: string;
    /**
     * The URL of the webhook.
     */
    url: string;
}

export interface RepositoryCollaboratorsTeam {
    permission?: string;
    /**
     * Team ID or slug to add to the repository as a collaborator.
     */
    teamId: string;
}

export interface RepositoryCollaboratorsUser {
    permission?: string;
    /**
     * (Required) The user to add to the repository as a collaborator.
     */
    username: string;
}

export interface RepositoryEnvironmentDeploymentBranchPolicy {
    /**
     * Whether only branches that match the specified name patterns can deploy to this environment.
     */
    customBranchPolicies: boolean;
    /**
     * Whether only branches with branch protection rules can deploy to this environment.
     */
    protectedBranches: boolean;
}

export interface RepositoryEnvironmentReviewer {
    /**
     * Up to 6 IDs for teams who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
     */
    teams?: number[];
    /**
     * Up to 6 IDs for users who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
     */
    users?: number[];
}

export interface RepositoryPages {
    /**
     * The type the page should be sourced.
     */
    buildType?: string;
    /**
     * The custom domain for the repository. This can only be set after the repository has been created.
     */
    cname?: string;
    /**
     * Whether the rendered GitHub Pages site has a custom 404 page
     */
    custom404: boolean;
    /**
     * URL to the repository on the web.
     */
    htmlUrl: string;
    /**
     * The source branch and directory for the rendered Pages site.
     */
    source?: outputs.RepositoryPagesSource;
    /**
     * The GitHub Pages site's build status e.g. building or built.
     */
    status: string;
    url: string;
}

export interface RepositoryPagesSource {
    /**
     * The repository branch used to publish the site's source files. (i.e. 'main' or 'gh-pages')
     */
    branch: string;
    /**
     * The repository directory from which the site publishes (Default: '/')
     */
    path?: string;
}

export interface RepositoryRulesetBypassActor {
    /**
     * The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
     */
    actorId: number;
    /**
     * The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
     */
    actorType: string;
    /**
     * When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
     */
    bypassMode: string;
}

export interface RepositoryRulesetConditions {
    refName: outputs.RepositoryRulesetConditionsRefName;
}

export interface RepositoryRulesetConditionsRefName {
    /**
     * Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
     */
    excludes: string[];
    /**
     * Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
     */
    includes: string[];
}

export interface RepositoryRulesetRules {
    /**
     * Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
     */
    branchNamePattern?: outputs.RepositoryRulesetRulesBranchNamePattern;
    /**
     * Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
     */
    commitAuthorEmailPattern?: outputs.RepositoryRulesetRulesCommitAuthorEmailPattern;
    /**
     * Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
     */
    commitMessagePattern?: outputs.RepositoryRulesetRulesCommitMessagePattern;
    /**
     * Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
     */
    committerEmailPattern?: outputs.RepositoryRulesetRulesCommitterEmailPattern;
    /**
     * Only allow users with bypass permission to create matching refs.
     */
    creation?: boolean;
    /**
     * Only allow users with bypass permissions to delete matching refs.
     */
    deletion?: boolean;
    /**
     * Prevent users with push access from force pushing to branches.
     */
    nonFastForward?: boolean;
    /**
     * Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
     */
    pullRequest?: outputs.RepositoryRulesetRulesPullRequest;
    /**
     * Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule.
     */
    requiredDeployments?: outputs.RepositoryRulesetRulesRequiredDeployments;
    /**
     * Prevent merge commits from being pushed to matching branches.
     */
    requiredLinearHistory?: boolean;
    /**
     * Commits pushed to matching branches must have verified signatures.
     */
    requiredSignatures?: boolean;
    /**
     * Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
     */
    requiredStatusChecks?: outputs.RepositoryRulesetRulesRequiredStatusChecks;
    /**
     * Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
     */
    tagNamePattern?: outputs.RepositoryRulesetRulesTagNamePattern;
    /**
     * Only allow users with bypass permission to update matching refs.
     */
    update?: boolean;
    /**
     * Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`.
     */
    updateAllowsFetchAndMerge?: boolean;
}

export interface RepositoryRulesetRulesBranchNamePattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface RepositoryRulesetRulesCommitAuthorEmailPattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface RepositoryRulesetRulesCommitMessagePattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface RepositoryRulesetRulesCommitterEmailPattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface RepositoryRulesetRulesPullRequest {
    /**
     * New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
     */
    dismissStaleReviewsOnPush?: boolean;
    /**
     * Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
     */
    requireCodeOwnerReview?: boolean;
    /**
     * Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
     */
    requireLastPushApproval?: boolean;
    /**
     * The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
     */
    requiredApprovingReviewCount?: number;
    /**
     * All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
     */
    requiredReviewThreadResolution?: boolean;
}

export interface RepositoryRulesetRulesRequiredDeployments {
    /**
     * The environments that must be successfully deployed to before branches can be merged.
     */
    requiredDeploymentEnvironments: string[];
}

export interface RepositoryRulesetRulesRequiredStatusChecks {
    /**
     * Status checks that are required. Several can be defined.
     */
    requiredChecks: outputs.RepositoryRulesetRulesRequiredStatusChecksRequiredCheck[];
    /**
     * Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
     */
    strictRequiredStatusChecksPolicy?: boolean;
}

export interface RepositoryRulesetRulesRequiredStatusChecksRequiredCheck {
    /**
     * The status check context name that must be present on the commit.
     */
    context: string;
    /**
     * The optional integration ID that this status check must originate from.
     */
    integrationId?: number;
}

export interface RepositoryRulesetRulesTagNamePattern {
    /**
     * How this rule will appear to users.
     */
    name?: string;
    /**
     * If true, the rule will fail if the pattern matches.
     */
    negate?: boolean;
    /**
     * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
     */
    operator: string;
    /**
     * The pattern to match with.
     */
    pattern: string;
}

export interface RepositorySecurityAndAnalysis {
    /**
     * The advanced security configuration for the repository. If a repository's visibility is 'public', advanced security is always enabled and cannot be changed, so this setting cannot be supplied.
     */
    advancedSecurity?: outputs.RepositorySecurityAndAnalysisAdvancedSecurity;
    /**
     * The secret scanning configuration for the repository.
     */
    secretScanning?: outputs.RepositorySecurityAndAnalysisSecretScanning;
    /**
     * The secret scanning push protection configuration for the repository.
     */
    secretScanningPushProtection?: outputs.RepositorySecurityAndAnalysisSecretScanningPushProtection;
}

export interface RepositorySecurityAndAnalysisAdvancedSecurity {
    /**
     * Set to 'enabled' to enable advanced security features on the repository. Can be 'enabled' or 'disabled'.
     */
    status: string;
}

export interface RepositorySecurityAndAnalysisSecretScanning {
    /**
     * Set to 'enabled' to enable secret scanning on the repository. Can be 'enabled' or 'disabled'. If set to 'enabled', the repository's visibility must be 'public' or 'security_and_analysis[0].advanced_security[0].status' must also be set to 'enabled'.
     */
    status: string;
}

export interface RepositorySecurityAndAnalysisSecretScanningPushProtection {
    /**
     * Set to 'enabled' to enable secret scanning push protection on the repository. Can be 'enabled' or 'disabled'. If set to 'enabled', the repository's visibility must be 'public' or 'security_and_analysis[0].advanced_security[0].status' must also be set to 'enabled'.
     */
    status: string;
}

export interface RepositoryTemplate {
    /**
     * Whether the new repository should include all the branches from the template repository (defaults to 'false', which includes only the default branch from the template).
     */
    includeAllBranches?: boolean;
    /**
     * The GitHub organization or user the template repository is owned by.
     */
    owner: string;
    /**
     * The name of the template repository.
     */
    repository: string;
}

export interface RepositoryWebhookConfiguration {
    /**
     * The content type for the payload. Valid values are either 'form' or 'json'.
     */
    contentType?: string;
    /**
     * Insecure SSL boolean toggle. Defaults to 'false'.
     */
    insecureSsl?: boolean;
    /**
     * The shared secret for the webhook
     */
    secret?: string;
    /**
     * The URL of the webhook.
     */
    url: string;
}

export interface TeamMembersMember {
    /**
     * The role of the user within the team. Must be one of 'member' or 'maintainer'.
     */
    role?: string;
    /**
     * The user to add to the team.
     */
    username: string;
}

export interface TeamSettingsReviewRequestDelegation {
    /**
     * The algorithm to use when assigning pull requests to team members. Supported values are 'ROUND_ROBIN' and 'LOAD_BALANCE'.
     */
    algorithm?: string;
    /**
     * The number of team members to assign to a pull request.
     */
    memberCount?: number;
    /**
     * whether to notify the entire team when at least one member is also assigned to the pull request.
     */
    notify?: boolean;
}

export interface TeamSyncGroupMappingGroup {
    /**
     * The description of the IdP group.
     */
    groupDescription: string;
    /**
     * The ID of the IdP group.
     */
    groupId: string;
    /**
     * The name of the IdP group.
     */
    groupName: string;
}

export namespace config {
    export interface AppAuth {
        /**
         * The GitHub App ID.
         */
        id: string;
        /**
         * The GitHub App installation instance ID.
         */
        installationId: string;
        /**
         * The GitHub App PEM file contents.
         */
        pemFile: string;
    }

}
