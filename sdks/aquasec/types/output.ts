// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AcknowledgeIssue {
    /**
     * The user who acknowledged the issue.
     */
    author: string;
    /**
     * The date and time of the acknowledgment.
     */
    date: string;
    dockerId?: string;
    /**
     * The current dat and time when the expiration was set
     */
    expirationConfiguredAt: string;
    /**
     * The user who set the expiration of the issue.
     */
    expirationConfiguredBy: string;
    /**
     * Number of days until expiration of the acknowledgement. The value must be integer from 1 to 999, inclusive.
     */
    expirationDays?: number;
    /**
     * The version of the package that having a fix for the issue.
     */
    fixVersion?: string;
    /**
     * Only acknowledge the issue in the context of the specified image (also requires 'registry_name')
     */
    imageName?: string;
    /**
     * The name of the security issue (the CVE or security advisory for vulnerabilities, name of malware or type of sensitive data)
     */
    issueName: string;
    /**
     * The type of the security issue (either 'vulnerability', 'sensitive_data' or 'malware')
     */
    issueType: string;
    /**
     * When the resource_type is 'package', the operating system is required (e.g., 'ubuntu', 'alpine').
     */
    os?: string;
    /**
     * When the resource_type is 'package', the operating system version is required.
     */
    osVersion?: string;
    /**
     * The permissions of the user who acknowledged the issue.
     */
    permission: string;
    /**
     * Only acknowledge the issue in the context of the specified repository (also requires 'registry_name').
     */
    registryName?: string;
    /**
     * The CPE of the resource as listed in the issue by the Aqua API. This is required for resources of type 'executable'. For packages and files, the next parameters can be specified instead.
     */
    resourceCpe?: string;
    /**
     * The format of the resource.
     */
    resourceFormat?: string;
    /**
     * When the resource_type is 'file', the hash of the file is required
     */
    resourceHash?: string;
    /**
     * When the resource_type is 'package', the name of the package is required.
     */
    resourceName?: string;
    /**
     * The path of the resource. This is required for resources of type 'file' and 'executable'.
     */
    resourcePath?: string;
    /**
     * The type of the resource where the issue was detected (either 'package', 'file' or 'executable')
     */
    resourceType: string;
    /**
     * When the resource_type is 'package', the version of the package is required
     */
    resourceVersion?: string;
}

export interface ApplicationScopeCategory {
    /**
     * An artifact is an application. It can be an image (for a container, not a CF application); a serverless function; or a Tanzu Application Service (TAS) droplet.
     */
    artifacts?: outputs.ApplicationScopeCategoryArtifact[];
    entityScopes: outputs.ApplicationScopeCategoryEntityScope[];
    /**
     * An infrastructure resource is an element of a computing environment on which a workload is orchestrated and run. It can be a host (VM) or a Kubernetes cluster.
     */
    infrastructures?: outputs.ApplicationScopeCategoryInfrastructure[];
    /**
     * A workload is a running container. It can run in a Kubernetes cluster, on a VM (no orchestrator), or under Tanzu Application Service (TAS).
     */
    workloads?: outputs.ApplicationScopeCategoryWorkload[];
}

export interface ApplicationScopeCategoryArtifact {
    cfs?: outputs.ApplicationScopeCategoryArtifactCf[];
    /**
     * Function name
     */
    functions?: outputs.ApplicationScopeCategoryArtifactFunction[];
    /**
     * Name of a registry as defined in Aqua
     */
    images?: outputs.ApplicationScopeCategoryArtifactImage[];
}

export interface ApplicationScopeCategoryArtifactCf {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactCfVariable[];
}

export interface ApplicationScopeCategoryArtifactCfVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryArtifactFunction {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactFunctionVariable[];
}

export interface ApplicationScopeCategoryArtifactFunctionVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryArtifactImage {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactImageVariable[];
}

export interface ApplicationScopeCategoryArtifactImageVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryEntityScope {
    expression: string;
    variables: outputs.ApplicationScopeCategoryEntityScopeVariable[];
}

export interface ApplicationScopeCategoryEntityScopeVariable {
    attribute: string;
    value: string;
}

export interface ApplicationScopeCategoryInfrastructure {
    kubernetes?: outputs.ApplicationScopeCategoryInfrastructureKubernete[];
    os?: outputs.ApplicationScopeCategoryInfrastructureO[];
}

export interface ApplicationScopeCategoryInfrastructureKubernete {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryInfrastructureKuberneteVariable[];
}

export interface ApplicationScopeCategoryInfrastructureKuberneteVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryInfrastructureO {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryInfrastructureOVariable[];
}

export interface ApplicationScopeCategoryInfrastructureOVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkload {
    cfs?: outputs.ApplicationScopeCategoryWorkloadCf[];
    kubernetes?: outputs.ApplicationScopeCategoryWorkloadKubernete[];
    os?: outputs.ApplicationScopeCategoryWorkloadO[];
}

export interface ApplicationScopeCategoryWorkloadCf {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadCfVariable[];
}

export interface ApplicationScopeCategoryWorkloadCfVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkloadKubernete {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadKuberneteVariable[];
}

export interface ApplicationScopeCategoryWorkloadKuberneteVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkloadO {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadOVariable[];
}

export interface ApplicationScopeCategoryWorkloadOVariable {
    attribute?: string;
    value?: string;
}

export interface ContainerRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface ContainerRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface ContainerRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface ContainerRuntimePolicyBlacklistedOsUsers {
    enabled?: boolean;
    groupBlackLists?: string[];
    userBlackLists?: string[];
}

export interface ContainerRuntimePolicyBypassScope {
    /**
     * Whether bypassing the scope is enabled.
     */
    enabled?: boolean;
    /**
     * Scope configuration.
     */
    scopes?: outputs.ContainerRuntimePolicyBypassScopeScope[];
}

export interface ContainerRuntimePolicyBypassScopeScope {
    /**
     * Scope expression.
     */
    expression?: string;
    /**
     * List of variables in the scope.
     */
    variables?: outputs.ContainerRuntimePolicyBypassScopeScopeVariable[];
}

export interface ContainerRuntimePolicyBypassScopeScopeVariable {
    /**
     * Variable attribute.
     */
    attribute?: string;
    /**
     * Variable value.
     */
    value?: string;
}

export interface ContainerRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface ContainerRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface ContainerRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface ContainerRuntimePolicyFailedKubernetesChecks {
    enabled?: boolean;
    failedChecks?: string[];
}

export interface ContainerRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface ContainerRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface ContainerRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface ContainerRuntimePolicyLinuxCapabilities {
    enabled?: boolean;
    removeLinuxCapabilities?: string[];
}

export interface ContainerRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface ContainerRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface ContainerRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface ContainerRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface ContainerRuntimePolicyReadonlyRegistry {
    enabled?: boolean;
    exceptionalReadonlyRegistryPaths?: string[];
    exceptionalReadonlyRegistryProcesses?: string[];
    exceptionalReadonlyRegistryUsers?: string[];
    readonlyRegistryPaths?: string[];
    readonlyRegistryProcesses?: string[];
    readonlyRegistryUsers?: string[];
}

export interface ContainerRuntimePolicyRegistryAccessMonitoring {
    enabled?: boolean;
    exceptionalMonitoredRegistryPaths?: string[];
    exceptionalMonitoredRegistryProcesses?: string[];
    exceptionalMonitoredRegistryUsers?: string[];
    monitoredRegistryAttributes?: boolean;
    monitoredRegistryCreate?: boolean;
    monitoredRegistryDelete?: boolean;
    monitoredRegistryModify?: boolean;
    monitoredRegistryPaths?: string[];
    monitoredRegistryProcesses?: string[];
    monitoredRegistryRead?: boolean;
    monitoredRegistryUsers?: string[];
}

export interface ContainerRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface ContainerRuntimePolicyReverseShell {
    blockReverseShell?: boolean;
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
    reverseShellProcWhiteLists?: string[];
}

export interface ContainerRuntimePolicyScope {
    /**
     * Scope expression.
     */
    expression: string;
    /**
     * List of variables in the scope.
     */
    variables: outputs.ContainerRuntimePolicyScopeVariable[];
}

export interface ContainerRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface ContainerRuntimePolicySystemIntegrityProtection {
    auditSystemtimeChange?: boolean;
    enabled?: boolean;
    monitorAuditLogIntegrity?: boolean;
    windowsServicesMonitoring?: boolean;
}

export interface ContainerRuntimePolicyTripwire {
    applyOns?: string[];
    enabled?: boolean;
    serverlessApp?: string;
    userId?: string;
    userPassword?: string;
}

export interface ContainerRuntimePolicyWhitelistedOsUsers {
    enabled?: boolean;
    groupWhiteLists?: string[];
    userWhiteLists?: string[];
}

export interface EnforcerGroupsCommand {
    default: string;
    kubernetes: string;
    swarm: string;
    windows: string;
}

export interface EnforcerGroupsOrchestrator {
    master?: boolean;
    /**
     * May be specified for these orchestrators: Kubernetes, Kubernetes GKE, VMware Tanzu Kubernetes Grid Integrated Edition (PKS).
     */
    namespace?: string;
    /**
     * May be specified for these orchestrators: Kubernetes, Kubernetes GKE, OpenShift, VMware Tanzu Kubernetes Grid Integrated Edition (PKS).
     */
    serviceAccount?: string;
    type?: string;
}

export interface FirewallPolicyInboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to pass in data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource
     */
    resourceType: string;
}

export interface FirewallPolicyOutboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to receive data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource.
     */
    resourceType: string;
}

export interface FunctionAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface FunctionAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface FunctionAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface FunctionAssurancePolicyKubernetesControl {
    avdId?: string;
    description?: string;
    enabled?: boolean;
    kind?: string;
    name?: string;
    ootb?: boolean;
    scriptId?: number;
    severity?: string;
}

export interface FunctionAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface FunctionAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface FunctionAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface FunctionAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface FunctionAssurancePolicyScope {
    expression: string;
    variables?: outputs.FunctionAssurancePolicyScopeVariable[];
}

export interface FunctionAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface FunctionAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface FunctionRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface FunctionRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface FunctionRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface FunctionRuntimePolicyBlacklistedOsUsers {
    enabled?: boolean;
    groupBlackLists?: string[];
    userBlackLists?: string[];
}

export interface FunctionRuntimePolicyBypassScope {
    /**
     * Whether bypassing the scope is enabled.
     */
    enabled?: boolean;
    /**
     * Scope configuration.
     */
    scopes?: outputs.FunctionRuntimePolicyBypassScopeScope[];
}

export interface FunctionRuntimePolicyBypassScopeScope {
    /**
     * Scope expression.
     */
    expression?: string;
    /**
     * List of variables in the scope.
     */
    variables?: outputs.FunctionRuntimePolicyBypassScopeScopeVariable[];
}

export interface FunctionRuntimePolicyBypassScopeScopeVariable {
    /**
     * Variable attribute.
     */
    attribute?: string;
    /**
     * Variable value.
     */
    value?: string;
}

export interface FunctionRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface FunctionRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface FunctionRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface FunctionRuntimePolicyFailedKubernetesChecks {
    enabled?: boolean;
    failedChecks?: string[];
}

export interface FunctionRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface FunctionRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface FunctionRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface FunctionRuntimePolicyLinuxCapabilities {
    enabled?: boolean;
    removeLinuxCapabilities?: string[];
}

export interface FunctionRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface FunctionRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface FunctionRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface FunctionRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface FunctionRuntimePolicyReadonlyRegistry {
    enabled?: boolean;
    exceptionalReadonlyRegistryPaths?: string[];
    exceptionalReadonlyRegistryProcesses?: string[];
    exceptionalReadonlyRegistryUsers?: string[];
    readonlyRegistryPaths?: string[];
    readonlyRegistryProcesses?: string[];
    readonlyRegistryUsers?: string[];
}

export interface FunctionRuntimePolicyRegistryAccessMonitoring {
    enabled?: boolean;
    exceptionalMonitoredRegistryPaths?: string[];
    exceptionalMonitoredRegistryProcesses?: string[];
    exceptionalMonitoredRegistryUsers?: string[];
    monitoredRegistryAttributes?: boolean;
    monitoredRegistryCreate?: boolean;
    monitoredRegistryDelete?: boolean;
    monitoredRegistryModify?: boolean;
    monitoredRegistryPaths?: string[];
    monitoredRegistryProcesses?: string[];
    monitoredRegistryRead?: boolean;
    monitoredRegistryUsers?: string[];
}

export interface FunctionRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface FunctionRuntimePolicyReverseShell {
    blockReverseShell?: boolean;
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
    reverseShellProcWhiteLists?: string[];
}

export interface FunctionRuntimePolicyScope {
    /**
     * Scope expression.
     */
    expression: string;
    /**
     * List of variables in the scope.
     */
    variables: outputs.FunctionRuntimePolicyScopeVariable[];
}

export interface FunctionRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface FunctionRuntimePolicySystemIntegrityProtection {
    auditSystemtimeChange?: boolean;
    enabled?: boolean;
    monitorAuditLogIntegrity?: boolean;
    windowsServicesMonitoring?: boolean;
}

export interface FunctionRuntimePolicyTripwire {
    applyOns?: string[];
    enabled?: boolean;
    serverlessApp?: string;
    userId?: string;
    userPassword?: string;
}

export interface FunctionRuntimePolicyWhitelistedOsUsers {
    enabled?: boolean;
    groupWhiteLists?: string[];
    userWhiteLists?: string[];
}

export interface GetAcknowledgesAcknowledge {
    author: string;
    comment: string;
    date: string;
    dockerId: string;
    expirationConfiguredAt: string;
    expirationConfiguredBy: string;
    expirationDays: number;
    fixVersion: string;
    imageName: string;
    issueName: string;
    issueType: string;
    os: string;
    osVersion: string;
    permission: string;
    registryName: string;
    resourceCpe: string;
    resourceFormat: string;
    resourceHash: string;
    resourceName: string;
    resourcePath: string;
    resourceType: string;
    resourceVersion: string;
}

export interface GetApplicationScopeCategory {
    artifacts?: outputs.GetApplicationScopeCategoryArtifact[];
    entityScopes?: outputs.GetApplicationScopeCategoryEntityScope[];
    infrastructures?: outputs.GetApplicationScopeCategoryInfrastructure[];
    workloads?: outputs.GetApplicationScopeCategoryWorkload[];
}

export interface GetApplicationScopeCategoryArtifact {
    cfs?: outputs.GetApplicationScopeCategoryArtifactCf[];
    functions?: outputs.GetApplicationScopeCategoryArtifactFunction[];
    images?: outputs.GetApplicationScopeCategoryArtifactImage[];
}

export interface GetApplicationScopeCategoryArtifactCf {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactCfVariable[];
}

export interface GetApplicationScopeCategoryArtifactCfVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryArtifactFunction {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactFunctionVariable[];
}

export interface GetApplicationScopeCategoryArtifactFunctionVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryArtifactImage {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactImageVariable[];
}

export interface GetApplicationScopeCategoryArtifactImageVariable {
    attribute?: string;
    value?: string;
}

export interface GetApplicationScopeCategoryEntityScope {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryEntityScopeVariable[];
}

export interface GetApplicationScopeCategoryEntityScopeVariable {
    attribute: string;
    value: string;
}

export interface GetApplicationScopeCategoryInfrastructure {
    kubernetes?: outputs.GetApplicationScopeCategoryInfrastructureKubernete[];
    os?: outputs.GetApplicationScopeCategoryInfrastructureO[];
}

export interface GetApplicationScopeCategoryInfrastructureKubernete {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryInfrastructureKuberneteVariable[];
}

export interface GetApplicationScopeCategoryInfrastructureKuberneteVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryInfrastructureO {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryInfrastructureOVariable[];
}

export interface GetApplicationScopeCategoryInfrastructureOVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkload {
    cfs?: outputs.GetApplicationScopeCategoryWorkloadCf[];
    kubernetes?: outputs.GetApplicationScopeCategoryWorkloadKubernete[];
    os?: outputs.GetApplicationScopeCategoryWorkloadO[];
}

export interface GetApplicationScopeCategoryWorkloadCf {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadCfVariable[];
}

export interface GetApplicationScopeCategoryWorkloadCfVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkloadKubernete {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadKuberneteVariable[];
}

export interface GetApplicationScopeCategoryWorkloadKuberneteVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkloadO {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadOVariable[];
}

export interface GetApplicationScopeCategoryWorkloadOVariable {
    attribute: string;
    value?: string;
}

export interface GetAquaLabelsAquaLabel {
    author: string;
    created: string;
    description: string;
    name: string;
}

export interface GetContainerRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface GetContainerRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface GetContainerRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface GetContainerRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface GetContainerRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface GetContainerRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface GetContainerRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface GetContainerRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface GetContainerRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface GetContainerRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface GetContainerRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface GetContainerRuntimePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetEnforcerGroupsCommand {
    default: string;
    kubernetes: string;
    swarm: string;
    windows: string;
}

export interface GetEnforcerGroupsOrchestrator {
    master: boolean;
    namespace: string;
    serviceAccount: string;
    type: string;
}

export interface GetFirewallPolicyInboundNetwork {
    allow: boolean;
    portRange: string;
    resource: string;
    resourceType: string;
}

export interface GetFirewallPolicyOutboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to receive data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource.
     */
    resourceType: string;
}

export interface GetFunctionAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetFunctionAssurancePolicyCustomCheck {
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetFunctionAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetFunctionAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetFunctionAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetFunctionAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetFunctionAssurancePolicyScope {
    expression: string;
    variables: outputs.GetFunctionAssurancePolicyScopeVariable[];
}

export interface GetFunctionAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetFunctionAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetFunctionRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface GetFunctionRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface GetFunctionRuntimePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetGatewaysGateway {
    description: string;
    grpcAddress: string;
    hostname: string;
    id: string;
    logicalname: string;
    publicAddress: string;
    status: string;
    version: string;
}

export interface GetGroupsGroup {
    created: string;
    groupId: string;
    name: string;
}

export interface GetHostAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetHostAssurancePolicyCustomCheck {
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetHostAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetHostAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetHostAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetHostAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetHostAssurancePolicyScope {
    expression: string;
    variables: outputs.GetHostAssurancePolicyScopeVariable[];
}

export interface GetHostAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetHostAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetHostRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface GetHostRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface GetHostRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface GetHostRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface GetHostRuntimePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetHostRuntimePolicyWindowsRegistryMonitoring {
    excludedPaths: string[];
    excludedProcesses: string[];
    excludedUsers: string[];
    monitorAttributes: boolean;
    monitorCreate: boolean;
    monitorDelete: boolean;
    monitorModify: boolean;
    monitorRead: boolean;
    monitoredPaths: string[];
    monitoredProcesses: string[];
    monitoredUsers: string[];
}

export interface GetHostRuntimePolicyWindowsRegistryProtection {
    excludedPaths: string[];
    excludedProcesses: string[];
    excludedUsers: string[];
    protectedPaths: string[];
    protectedProcesses: string[];
    protectedUsers: string[];
}

export interface GetImageAssuranceChecksPerformed {
    assuranceType: string;
    blocking: boolean;
    control: string;
    dtaSkipped: boolean;
    dtaSkippedReason: string;
    failed: boolean;
    policyName: string;
}

export interface GetImageAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetImageAssurancePolicyCustomCheck {
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetImageAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetImageAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetImageAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetImageAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetImageAssurancePolicyScope {
    expression: string;
    variables: outputs.GetImageAssurancePolicyScopeVariable[];
}

export interface GetImageAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetImageAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetImageHistory {
    comment: string;
    created: string;
    createdBy: string;
    id: string;
    size: number;
}

export interface GetImageVulnerability {
    ackAuthor: string;
    ackComment: string;
    ackExpirationConfiguredAt: string;
    ackExpirationConfiguredBy: string;
    ackExpirationDays: number;
    ackScope: string;
    acknowledgeDate: string;
    ancestorPkg: string;
    aquaScore: number;
    aquaScoreClassification: string;
    aquaScoringSystem: string;
    aquaSeverity: string;
    aquaSeverityClassification: string;
    aquaVectors: string;
    auditEventsCount: number;
    blockEventsCount: number;
    classification: string;
    description: string;
    digest: string;
    exploitReference: string;
    exploitType: string;
    firstFoundDate: string;
    fixVersion: string;
    imageName: string;
    lastFoundDate: string;
    modificationDate: string;
    name: string;
    nvdCvss2Score: number;
    nvdCvss2Vectors: string;
    nvdCvss3Score: number;
    nvdCvss3Severity: string;
    nvdCvss3Vectors: string;
    nvdSeverity: string;
    nvdUrl: string;
    os: string;
    osVersion: string;
    permission: string;
    publishDate: string;
    registry: string;
    repository: string;
    resourceArchitecture: string;
    resourceCpe: string;
    resourceFormat: string;
    resourceHash: string;
    resourceLicenses: string[];
    resourceName: string;
    resourcePath: string;
    resourceType: string;
    resourceVersion: string;
    severityClassification: string;
    solution: string;
    temporalVector: string;
    vPatchAppliedBy: string;
    vPatchAppliedOn: string;
    vPatchEnforcedBy: string;
    vPatchEnforcedOn: string;
    vPatchPolicyEnforce: boolean;
    vPatchPolicyName: string;
    vPatchRevertedBy: string;
    vPatchRevertedOn: string;
    vPatchStatus: string;
    vendorCvss2Score: number;
    vendorCvss2Vectors: string;
    vendorSeverity: string;
    vendorStatement: string;
    vendorUrl: string;
}

export interface GetIntegrationRegistriesOption {
    option?: string;
    value?: string;
}

export interface GetIntegrationRegistriesWebhook {
    authToken?: string;
    enabled?: boolean;
    unQuarantine?: boolean;
    url?: string;
}

export interface GetKubernetesAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetKubernetesAssurancePolicyCustomCheck {
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetKubernetesAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetKubernetesAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetKubernetesAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetKubernetesAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetKubernetesAssurancePolicyScope {
    expression: string;
    variables: outputs.GetKubernetesAssurancePolicyScopeVariable[];
}

export interface GetKubernetesAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetKubernetesAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetNotificationsEmail {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsJira {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsServicenow {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsSlack {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsSplunk {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsTeam {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsWebhook {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetPermissionsSetsPermissionsSet {
    actions: string[];
    author: string;
    description: string;
    isSuper: boolean;
    name: string;
    uiAccess: boolean;
    updatedAt: string;
}

export interface GetRolesMappingLdap {
    roleMapping: {[key: string]: string};
}

export interface GetRolesMappingOauth2 {
    roleMapping: {[key: string]: string};
}

export interface GetRolesMappingOpenid {
    roleMapping: {[key: string]: string};
}

export interface GetRolesMappingSaasRolesMapping {
    accountId: number;
    created: string;
    cspRole: string;
    id: number;
    samlGroups: string[];
}

export interface GetRolesMappingSaml {
    roleMapping: {[key: string]: string};
}

export interface GetRolesRole {
    description: string;
    name: string;
    permission: string;
    scopes: string[];
    updatedAt: string;
}

export interface GetServiceScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetUsersSaasUser {
    accountAdmin: boolean;
    confirmed: boolean;
    created: string;
    cspRoles: string[];
    dashboard: boolean;
    email: string;
    groups: outputs.GetUsersSaasUserGroup[];
    logins: outputs.GetUsersSaasUserLogin[];
    multiaccount: boolean;
    passwordReset: boolean;
    provider: string;
    sendAnnouncements: boolean;
    sendNewPlugins: boolean;
    sendNewRisks: boolean;
    sendScanResults: boolean;
    userId: string;
}

export interface GetUsersSaasUserGroup {
    created: string;
    id: number;
    name: string;
}

export interface GetUsersSaasUserLogin {
    created: string;
    id: number;
    ipAddress: string;
    userId: number;
}

export interface GetUsersUser {
    email: string;
    firstTime: boolean;
    isSuper: boolean;
    name: string;
    plan: string;
    role: string;
    roles: string[];
    type: string;
    uiAccess: boolean;
    userId: string;
}

export interface HostAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface HostAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface HostAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface HostAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface HostAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface HostAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface HostAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface HostAssurancePolicyScope {
    expression: string;
    variables?: outputs.HostAssurancePolicyScopeVariable[];
}

export interface HostAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface HostAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface HostRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface HostRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface HostRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface HostRuntimePolicyBlacklistedOsUsers {
    enabled?: boolean;
    groupBlackLists?: string[];
    userBlackLists?: string[];
}

export interface HostRuntimePolicyBypassScope {
    /**
     * Whether bypassing the scope is enabled.
     */
    enabled?: boolean;
    /**
     * Scope configuration.
     */
    scopes?: outputs.HostRuntimePolicyBypassScopeScope[];
}

export interface HostRuntimePolicyBypassScopeScope {
    /**
     * Scope expression.
     */
    expression?: string;
    /**
     * List of variables in the scope.
     */
    variables?: outputs.HostRuntimePolicyBypassScopeScopeVariable[];
}

export interface HostRuntimePolicyBypassScopeScopeVariable {
    /**
     * Variable attribute.
     */
    attribute?: string;
    /**
     * Variable value.
     */
    value?: string;
}

export interface HostRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface HostRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface HostRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface HostRuntimePolicyFailedKubernetesChecks {
    enabled?: boolean;
    failedChecks?: string[];
}

export interface HostRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface HostRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface HostRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface HostRuntimePolicyLinuxCapabilities {
    enabled?: boolean;
    removeLinuxCapabilities?: string[];
}

export interface HostRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface HostRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface HostRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface HostRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface HostRuntimePolicyReadonlyRegistry {
    enabled?: boolean;
    exceptionalReadonlyRegistryPaths?: string[];
    exceptionalReadonlyRegistryProcesses?: string[];
    exceptionalReadonlyRegistryUsers?: string[];
    readonlyRegistryPaths?: string[];
    readonlyRegistryProcesses?: string[];
    readonlyRegistryUsers?: string[];
}

export interface HostRuntimePolicyRegistryAccessMonitoring {
    enabled?: boolean;
    exceptionalMonitoredRegistryPaths?: string[];
    exceptionalMonitoredRegistryProcesses?: string[];
    exceptionalMonitoredRegistryUsers?: string[];
    monitoredRegistryAttributes?: boolean;
    monitoredRegistryCreate?: boolean;
    monitoredRegistryDelete?: boolean;
    monitoredRegistryModify?: boolean;
    monitoredRegistryPaths?: string[];
    monitoredRegistryProcesses?: string[];
    monitoredRegistryRead?: boolean;
    monitoredRegistryUsers?: string[];
}

export interface HostRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface HostRuntimePolicyReverseShell {
    blockReverseShell?: boolean;
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
    reverseShellProcWhiteLists?: string[];
}

export interface HostRuntimePolicyScope {
    /**
     * Scope expression.
     */
    expression: string;
    /**
     * List of variables in the scope.
     */
    variables: outputs.HostRuntimePolicyScopeVariable[];
}

export interface HostRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface HostRuntimePolicySystemIntegrityProtection {
    auditSystemtimeChange?: boolean;
    enabled?: boolean;
    monitorAuditLogIntegrity?: boolean;
    windowsServicesMonitoring?: boolean;
}

export interface HostRuntimePolicyTripwire {
    applyOns?: string[];
    enabled?: boolean;
    serverlessApp?: string;
    userId?: string;
    userPassword?: string;
}

export interface HostRuntimePolicyWhitelistedOsUsers {
    enabled?: boolean;
    groupWhiteLists?: string[];
    userWhiteLists?: string[];
}

export interface ImageAssuranceChecksPerformed {
    assuranceType: string;
    blocking: boolean;
    control: string;
    dtaSkipped: boolean;
    dtaSkippedReason: string;
    failed: boolean;
    policyName: string;
}

export interface ImageAssurancePolicyAutoScanTime {
    iteration?: number;
    iterationType?: string;
    time?: string;
    weekDays?: string[];
}

export interface ImageAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface ImageAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface ImageAssurancePolicyKubernetesControls {
    avdId?: string;
    description?: string;
    enabled?: boolean;
    kind?: string;
    name?: string;
    ootb?: boolean;
    scriptId?: number;
    severity?: string;
}

export interface ImageAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface ImageAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface ImageAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface ImageAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface ImageAssurancePolicyScope {
    expression: string;
    variables?: outputs.ImageAssurancePolicyScopeVariable[];
}

export interface ImageAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface ImageAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface ImageHistory {
    comment: string;
    created: string;
    createdBy: string;
    id: string;
    size: number;
}

export interface ImageVulnerability {
    ackAuthor: string;
    ackComment: string;
    ackExpirationConfiguredAt: string;
    ackExpirationConfiguredBy: string;
    ackExpirationDays: number;
    ackScope: string;
    acknowledgeDate: string;
    ancestorPkg: string;
    aquaScore: number;
    aquaScoreClassification: string;
    aquaScoringSystem: string;
    aquaSeverity: string;
    aquaSeverityClassification: string;
    aquaVectors: string;
    auditEventsCount: number;
    blockEventsCount: number;
    classification: string;
    description: string;
    digest: string;
    exploitReference: string;
    exploitType: string;
    firstFoundDate: string;
    fixVersion: string;
    imageName: string;
    lastFoundDate: string;
    modificationDate: string;
    name: string;
    nvdCvss2Score: number;
    nvdCvss2Vectors: string;
    nvdCvss3Score: number;
    nvdCvss3Severity: string;
    nvdCvss3Vectors: string;
    nvdSeverity: string;
    nvdUrl: string;
    os: string;
    osVersion: string;
    permission: string;
    publishDate: string;
    registry: string;
    repository: string;
    resourceArchitecture: string;
    resourceCpe: string;
    resourceFormat: string;
    resourceHash: string;
    resourceLicenses: string[];
    resourceName: string;
    resourcePath: string;
    resourceType: string;
    resourceVersion: string;
    severityClassification: string;
    solution: string;
    temporalVector: string;
    vPatchAppliedBy: string;
    vPatchAppliedOn: string;
    vPatchEnforcedBy: string;
    vPatchEnforcedOn: string;
    vPatchPolicyEnforce: boolean;
    vPatchPolicyName: string;
    vPatchRevertedBy: string;
    vPatchRevertedOn: string;
    vPatchStatus: string;
    vendorCvss2Score: number;
    vendorCvss2Vectors: string;
    vendorSeverity: string;
    vendorStatement: string;
    vendorUrl: string;
}

export interface IntegrationRegistryOption {
    option?: string;
    value?: string;
}

export interface IntegrationRegistryWebhook {
    authToken?: string;
    enabled: boolean;
    unQuarantine: boolean;
    url?: string;
}

export interface KubernetesAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface KubernetesAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface KubernetesAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface KubernetesAssurancePolicyKubernetesControl {
    /**
     * AVD ID.
     */
    avdId?: string;
    /**
     * Description of the control.
     */
    description?: string;
    /**
     * Is the control enabled?
     */
    enabled?: boolean;
    /**
     * Kind of the control.
     */
    kind?: string;
    /**
     * Name of the control.
     */
    name?: string;
    /**
     * Out-of-the-box status of the control.
     */
    ootb?: boolean;
    /**
     * Script ID.
     */
    scriptId?: number;
    /**
     * Severity of the control.
     */
    severity?: string;
}

export interface KubernetesAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface KubernetesAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface KubernetesAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface KubernetesAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface KubernetesAssurancePolicyScope {
    expression: string;
    variables?: outputs.KubernetesAssurancePolicyScopeVariable[];
}

export interface KubernetesAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface KubernetesAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface RoleMappingLdap {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface RoleMappingOauth2 {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface RoleMappingOpenid {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface RoleMappingSaml {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface ServiceScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute?: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value?: string;
}

export interface UserSaasGroup {
    groupAdmin?: boolean;
    name?: string;
}

export interface UserSaasLogin {
    created: string;
    id: number;
    ipAddress: string;
    userId: number;
}

export interface VmwareAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface VmwareAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface VmwareAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface VmwareAssurancePolicyKubernetesControl {
    avdId?: string;
    description?: string;
    enabled?: boolean;
    kind?: string;
    name?: string;
    ootb?: boolean;
    scriptId?: number;
    severity?: string;
}

export interface VmwareAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface VmwareAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface VmwareAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface VmwareAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface VmwareAssurancePolicyScope {
    expression: string;
    variables?: outputs.VmwareAssurancePolicyScopeVariable[];
}

export interface VmwareAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface VmwareAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

