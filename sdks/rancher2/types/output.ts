// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AppTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AppV2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CatalogTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CatalogV2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CertificateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudCredentialAmazonec2CredentialConfig {
    /**
     * AWS Access Key
     */
    accessKey: string;
    /**
     * AWS default region
     */
    defaultRegion?: string;
    /**
     * AWS Secret Key
     */
    secretKey: string;
}

export interface CloudCredentialAzureCredentialConfig {
    /**
     * Azure Service Principal Account ID
     */
    clientId: string;
    /**
     * Azure Service Principal Account password
     */
    clientSecret: string;
    /**
     * Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
     */
    environment: string;
    /**
     * Azure Subscription ID
     */
    subscriptionId: string;
    /**
     * Azure Tenant ID
     */
    tenantId: string;
}

export interface CloudCredentialDigitaloceanCredentialConfig {
    /**
     * Digital Ocean access token
     */
    accessToken: string;
}

export interface CloudCredentialGoogleCredentialConfig {
    /**
     * Google auth encoded json
     */
    authEncodedJson: string;
}

export interface CloudCredentialHarvesterCredentialConfig {
    /**
     * The cluster id of imported Harvester cluster
     */
    clusterId?: string;
    /**
     * Harvester cluster type. must be imported or external
     */
    clusterType: string;
    /**
     * Harvester cluster kubeconfig content
     */
    kubeconfigContent: string;
}

export interface CloudCredentialLinodeCredentialConfig {
    /**
     * Linode API token
     */
    token: string;
}

export interface CloudCredentialOpenstackCredentialConfig {
    /**
     * OpenStack password
     */
    password: string;
}

export interface CloudCredentialS3CredentialConfig {
    /**
     * AWS Access Key
     */
    accessKey: string;
    /**
     * AWS default bucket
     */
    defaultBucket?: string;
    /**
     * AWS default endpoint
     */
    defaultEndpoint?: string;
    /**
     * AWS default endpoint CA
     */
    defaultEndpointCa?: string;
    /**
     * AWS default folder
     */
    defaultFolder?: string;
    /**
     * AWS default region
     */
    defaultRegion?: string;
    /**
     * AWS default skip ssl verify
     */
    defaultSkipSslVerify?: boolean;
    /**
     * AWS Secret Key
     */
    secretKey: string;
}

export interface CloudCredentialTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudCredentialVsphereCredentialConfig {
    /**
     * vSphere password
     */
    password: string;
    /**
     * vSphere username
     */
    username: string;
    /**
     * vSphere IP/hostname for vCenter
     */
    vcenter: string;
    /**
     * vSphere Port for vCenter
     */
    vcenterPort?: string;
}

export interface ClusterAgentEnvVar {
    name: string;
    value: string;
}

export interface ClusterAksConfig {
    /**
     * The secret of an Azure Active Directory server application
     */
    aadServerAppSecret?: string;
    /**
     * The ID of an Azure Active Directory tenant
     */
    aadTenantId?: string;
    /**
     * The ID of an Azure Active Directory client application of type "Native". This application is for user login via kubectl
     */
    addClientAppId?: string;
    /**
     * The ID of an Azure Active Directory server application of type "Web app/API". This application represents the managed cluster's apiserver (Server application)
     */
    addServerAppId?: string;
    /**
     * The administrator username to use for Linux hosts
     */
    adminUsername?: string;
    /**
     * DNS prefix to be used to create the FQDN for the agent pool
     */
    agentDnsPrefix: string;
    /**
     * GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the "agent vm size" specified
     */
    agentOsDiskSize?: number;
    /**
     * Name for the agent pool, upto 12 alphanumeric characters
     */
    agentPoolName?: string;
    /**
     * Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]
     */
    agentStorageProfile?: string;
    /**
     * Size of machine in the agent pool
     */
    agentVmSize?: string;
    /**
     * Different authentication API url to use
     */
    authBaseUrl?: string;
    /**
     * Different resource management API url to use
     */
    baseUrl?: string;
    /**
     * Azure client ID to use
     */
    clientId: string;
    /**
     * Azure client secret associated with the "client id"
     */
    clientSecret: string;
    /**
     * Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive)
     */
    count?: number;
    /**
     * An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in "service cidr"
     */
    dnsServiceIp?: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in "service cidr"
     */
    dockerBridgeCidr?: string;
    /**
     * Enable the Kubernetes ingress with automatic public DNS name creation
     */
    enableHttpApplicationRouting?: boolean;
    /**
     * Turn on Azure Log Analytics monitoring. Uses the Log Analytics "Default" workspace if it exists, else creates one. if using an existing workspace, specifies "log analytics workspace resource id"
     */
    enableMonitoring?: boolean;
    /**
     * Specify the version of Kubernetes
     */
    kubernetesVersion: string;
    /**
     * Load balancer type (basic | standard). Must be standard for auto-scaling
     */
    loadBalancerSku: string;
    /**
     * Azure Kubernetes cluster location
     */
    location?: string;
    /**
     * The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}'
     */
    logAnalyticsWorkspace?: string;
    /**
     * The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group
     */
    logAnalyticsWorkspaceResourceGroup?: string;
    /**
     * DNS prefix to use the Kubernetes cluster control pane
     */
    masterDnsPrefix: string;
    /**
     * Maximum number of pods that can run on a node
     */
    maxPods?: number;
    /**
     * Network plugin used for building Kubernetes network. Chooses from [azure kubenet]
     */
    networkPlugin?: string;
    /**
     * Network policy used for building Kubernetes network. Chooses from [calico]
     */
    networkPolicy?: string;
    /**
     * A CIDR notation IP range from which to assign Kubernetes Pod IPs when "network plugin" is specified in "kubenet".
     */
    podCidr?: string;
    /**
     * The name of the Cluster resource group
     */
    resourceGroup: string;
    /**
     * A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges
     */
    serviceCidr?: string;
    /**
     * Contents of the SSH public key used to authenticate with Linux hosts
     */
    sshPublicKeyContents: string;
    /**
     * The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID
     */
    subnet: string;
    /**
     * Subscription credentials which uniquely identify Microsoft Azure subscription
     */
    subscriptionId: string;
    /**
     * Tags for Kubernetes cluster. For example, foo=bar
     *
     * @deprecated Deprecated
     */
    tag: {[key: string]: string};
    /**
     * Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]`
     */
    tags: string[];
    /**
     * Azure tenant ID to use
     */
    tenantId: string;
    /**
     * The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
     */
    virtualNetwork: string;
    /**
     * The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
     */
    virtualNetworkResourceGroup: string;
}

export interface ClusterAksConfigV2 {
    /**
     * The AKS auth base url
     */
    authBaseUrl?: string;
    /**
     * The AKS authorized ip ranges
     */
    authorizedIpRanges?: string[];
    /**
     * The AKS base url
     */
    baseUrl?: string;
    /**
     * The AKS Cloud Credential ID to use
     */
    cloudCredentialId: string;
    /**
     * The AKS dns prefix. Required if `import=false`
     */
    dnsPrefix?: string;
    /**
     * Enable AKS http application routing?
     */
    httpApplicationRouting: boolean;
    /**
     * Is AKS cluster imported?
     */
    imported?: boolean;
    /**
     * The kubernetes master version. Required if `import=false`
     */
    kubernetesVersion?: string;
    /**
     * The AKS linux admin username
     */
    linuxAdminUsername: string;
    /**
     * The AKS linux ssh public key
     */
    linuxSshPublicKey: string;
    /**
     * The AKS load balancer sku
     */
    loadBalancerSku: string;
    /**
     * The AKS log analytics workspace group
     */
    logAnalyticsWorkspaceGroup: string;
    /**
     * The AKS log analytics workspace name
     */
    logAnalyticsWorkspaceName: string;
    /**
     * Is AKS cluster monitoring enabled?
     */
    monitoring: boolean;
    /**
     * The AKS cluster name
     */
    name: string;
    /**
     * The AKS network dns service ip
     */
    networkDnsServiceIp: string;
    /**
     * The AKS network docker bridge cidr
     */
    networkDockerBridgeCidr: string;
    /**
     * The AKS network plugin. Required if `import=false`
     */
    networkPlugin?: string;
    /**
     * The AKS network pod cidr
     */
    networkPodCidr: string;
    /**
     * The AKS network policy
     */
    networkPolicy: string;
    /**
     * The AKS network service cidr
     */
    networkServiceCidr: string;
    /**
     * The AKS node pools to use. Required if `import=false`
     */
    nodePools?: outputs.ClusterAksConfigV2NodePool[];
    /**
     * The AKS node resource group name
     */
    nodeResourceGroup: string;
    /**
     * Is AKS cluster private?
     */
    privateCluster: boolean;
    /**
     * The AKS resource group
     */
    resourceGroup: string;
    /**
     * The AKS resource location
     */
    resourceLocation: string;
    /**
     * The AKS subnet
     */
    subnet: string;
    /**
     * The AKS cluster tags
     */
    tags: {[key: string]: string};
    /**
     * The AKS virtual network
     */
    virtualNetwork: string;
    /**
     * The AKS virtual network resource group
     */
    virtualNetworkResourceGroup: string;
}

export interface ClusterAksConfigV2NodePool {
    /**
     * The AKS node pool availability zones
     */
    availabilityZones?: string[];
    /**
     * The AKS node pool count
     */
    count?: number;
    /**
     * Is AKS node pool auto scaling enabled?
     */
    enableAutoScaling?: boolean;
    /**
     * The AKS node pool labels
     */
    labels: {[key: string]: string};
    /**
     * The AKS node pool max count
     */
    maxCount?: number;
    /**
     * The AKS node pool max pods
     */
    maxPods?: number;
    /**
     * The AKS node pool max surge
     */
    maxSurge?: string;
    /**
     * The AKS node pool min count
     */
    minCount?: number;
    /**
     * The AKS node pool mode
     */
    mode?: string;
    /**
     * The AKS node group name
     */
    name: string;
    /**
     * The AKS node pool orchestrator version
     */
    orchestratorVersion?: string;
    /**
     * The AKS node pool os disk size gb
     */
    osDiskSizeGb?: number;
    /**
     * The AKS node pool os disk type
     */
    osDiskType?: string;
    /**
     * Enable AKS node pool os type
     */
    osType?: string;
    /**
     * The AKS node pool taints
     */
    taints: string[];
    /**
     * The AKS node pool vm size
     */
    vmSize: string;
}

export interface ClusterClusterAgentDeploymentCustomization {
    /**
     * User defined tolerations to append to agent
     */
    appendTolerations?: outputs.ClusterClusterAgentDeploymentCustomizationAppendToleration[];
    /**
     * User defined affinity to override default agent affinity
     */
    overrideAffinity?: string;
    /**
     * User defined resource requirements to set on the agent
     */
    overrideResourceRequirements?: outputs.ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement[];
}

export interface ClusterClusterAgentDeploymentCustomizationAppendToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement {
    /**
     * The maximum CPU limit for agent
     */
    cpuLimit?: string;
    /**
     * The minimum CPU required for agent
     */
    cpuRequest?: string;
    /**
     * The maximum memory limit for agent
     */
    memoryLimit?: string;
    /**
     * The minimum memory required for agent
     */
    memoryRequest?: string;
}

export interface ClusterClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface ClusterClusterRegistrationToken {
    annotations: {[key: string]: string};
    clusterId: string;
    command: string;
    id: string;
    insecureCommand: string;
    insecureNodeCommand: string;
    insecureWindowsNodeCommand: string;
    labels: {[key: string]: string};
    manifestUrl: string;
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface ClusterClusterTemplateAnswers {
    /**
     * Cluster ID for answer
     */
    clusterId: string;
    /**
     * Project ID for answer
     */
    projectId: string;
    /**
     * Key/values for answer
     */
    values: {[key: string]: string};
}

export interface ClusterClusterTemplateQuestion {
    /**
     * Default variable value
     */
    default: string;
    /**
     * Required variable
     */
    required?: boolean;
    /**
     * Variable type
     */
    type?: string;
    /**
     * Variable name
     */
    variable: string;
}

export interface ClusterDriverTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterEksConfig {
    /**
     * The AWS Client ID to use
     */
    accessKey: string;
    /**
     * A custom AMI ID to use for the worker nodes instead of the default
     */
    ami?: string;
    /**
     * Associate public ip EKS worker nodes
     */
    associateWorkerNodePublicIp?: boolean;
    /**
     * The desired number of worker nodes
     */
    desiredNodes?: number;
    /**
     * Enables EBS encryption of worker nodes
     */
    ebsEncryption?: boolean;
    /**
     * The type of machine to use for worker nodes
     */
    instanceType?: string;
    /**
     * Allow user to specify key name to use
     */
    keyPairName?: string;
    /**
     * The kubernetes master version
     */
    kubernetesVersion: string;
    /**
     * The maximum number of worker nodes
     */
    maximumNodes?: number;
    /**
     * The minimum number of worker nodes
     */
    minimumNodes?: number;
    /**
     * The volume size for each node
     */
    nodeVolumeSize?: number;
    /**
     * The AWS Region to create the EKS cluster in
     */
    region?: string;
    /**
     * The AWS Client Secret associated with the Client ID
     */
    secretKey: string;
    /**
     * List of security groups to use for the cluster
     */
    securityGroups?: string[];
    /**
     * The service role to use to perform the cluster operations in AWS
     */
    serviceRole?: string;
    /**
     * A session token to use with the client key and secret if applicable
     */
    sessionToken?: string;
    /**
     * List of subnets in the virtual network to use
     */
    subnets?: string[];
    /**
     * Pass user-data to the nodes to perform automated configuration tasks
     */
    userData: string;
    /**
     * The name of the virtual network to use
     */
    virtualNetwork?: string;
}

export interface ClusterEksConfigV2 {
    /**
     * The AWS Cloud Credential ID to use
     */
    cloudCredentialId: string;
    /**
     * Is EKS cluster imported?
     */
    imported?: boolean;
    /**
     * The AWS kms key to use
     */
    kmsKey?: string;
    /**
     * The kubernetes master version
     */
    kubernetesVersion: string;
    /**
     * The AWS logging types
     */
    loggingTypes?: string[];
    /**
     * The EKS cluster name
     */
    name: string;
    /**
     * The AWS node groups to use
     */
    nodeGroups?: outputs.ClusterEksConfigV2NodeGroup[];
    /**
     * The EKS cluster has private access
     */
    privateAccess: boolean;
    /**
     * The EKS cluster has public access
     */
    publicAccess: boolean;
    /**
     * The EKS cluster public access sources
     */
    publicAccessSources: string[];
    /**
     * The AWS Region to create the EKS cluster in
     */
    region?: string;
    /**
     * Enable EKS cluster secret encryption
     */
    secretsEncryption: boolean;
    /**
     * List of security groups to use for the cluster
     */
    securityGroups?: string[];
    /**
     * The AWS service role to use
     */
    serviceRole?: string;
    /**
     * List of subnets in the virtual network to use
     */
    subnets?: string[];
    /**
     * The EKS cluster tags
     */
    tags?: {[key: string]: string};
}

export interface ClusterEksConfigV2NodeGroup {
    /**
     * The EKS node group desired size
     */
    desiredSize?: number;
    /**
     * The EKS node group disk size
     */
    diskSize?: number;
    /**
     * The EKS node group ssh key
     */
    ec2SshKey?: string;
    /**
     * Is EKS cluster using gpu?
     */
    gpu?: boolean;
    /**
     * The EKS node group image ID
     */
    imageId?: string;
    /**
     * The EKS node group instance type
     */
    instanceType?: string;
    /**
     * The EKS node group tags
     */
    labels?: {[key: string]: string};
    /**
     * The EKS node groups launch template
     */
    launchTemplates?: outputs.ClusterEksConfigV2NodeGroupLaunchTemplate[];
    /**
     * The EKS node group maximum size
     */
    maxSize?: number;
    /**
     * The EKS node group minimum size
     */
    minSize?: number;
    /**
     * The EKS node group name
     */
    name: string;
    /**
     * The EKS node group node role ARN
     */
    nodeRole?: string;
    /**
     * Enable EKS node group request spot instances
     */
    requestSpotInstances?: boolean;
    /**
     * The EKS node group resource tags
     */
    resourceTags?: {[key: string]: string};
    /**
     * The EKS node group spot instance types
     */
    spotInstanceTypes?: string[];
    /**
     * The EKS node group subnets
     */
    subnets: string[];
    /**
     * The EKS node group tags
     */
    tags?: {[key: string]: string};
    /**
     * The EKS node group user data
     */
    userData: string;
    /**
     * The EKS node group k8s version
     */
    version: string;
}

export interface ClusterEksConfigV2NodeGroupLaunchTemplate {
    /**
     * The EKS node group launch template ID
     */
    id: string;
    /**
     * The EKS node group launch template name
     */
    name: string;
    /**
     * The EKS node group launch template version
     */
    version?: number;
}

export interface ClusterFleetAgentDeploymentCustomization {
    /**
     * User defined tolerations to append to agent
     */
    appendTolerations?: outputs.ClusterFleetAgentDeploymentCustomizationAppendToleration[];
    /**
     * User defined affinity to override default agent affinity
     */
    overrideAffinity?: string;
    /**
     * User defined resource requirements to set on the agent
     */
    overrideResourceRequirements?: outputs.ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement[];
}

export interface ClusterFleetAgentDeploymentCustomizationAppendToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement {
    /**
     * The maximum CPU limit for agent
     */
    cpuLimit?: string;
    /**
     * The minimum CPU required for agent
     */
    cpuRequest?: string;
    /**
     * The maximum memory limit for agent
     */
    memoryLimit?: string;
    /**
     * The minimum memory required for agent
     */
    memoryRequest?: string;
}

export interface ClusterGkeConfig {
    /**
     * The IP address range of the container pods
     */
    clusterIpv4Cidr: string;
    /**
     * The contents of the GC credential file
     */
    credential: string;
    /**
     * An optional description of this cluster
     */
    description?: string;
    /**
     * Size of the disk attached to each node
     */
    diskSizeGb?: number;
    /**
     * Type of the disk attached to each node
     */
    diskType: string;
    /**
     * To enable kubernetes alpha feature
     */
    enableAlphaFeature?: boolean;
    /**
     * Specifies whether the node auto-repair is enabled for the node pool
     */
    enableAutoRepair?: boolean;
    /**
     * Specifies whether node auto-upgrade is enabled for the node pool
     */
    enableAutoUpgrade?: boolean;
    /**
     * Enable horizontal pod autoscaling for the cluster
     */
    enableHorizontalPodAutoscaling?: boolean;
    /**
     * Enable http load balancing for the cluster
     */
    enableHttpLoadBalancing?: boolean;
    /**
     * Whether to enable the kubernetes dashboard
     */
    enableKubernetesDashboard?: boolean;
    /**
     * Whether to enable legacy abac on the cluster
     */
    enableLegacyAbac?: boolean;
    /**
     * Whether or not master authorized network is enabled
     */
    enableMasterAuthorizedNetwork?: boolean;
    /**
     * Enable network policy config for the cluster
     */
    enableNetworkPolicyConfig?: boolean;
    /**
     * Enable nodepool autoscaling
     */
    enableNodepoolAutoscaling?: boolean;
    /**
     * Whether the master's internal IP address is used as the cluster endpoint
     */
    enablePrivateEndpoint?: boolean;
    /**
     * Whether nodes have internal IP address only
     */
    enablePrivateNodes?: boolean;
    /**
     * Enable stackdriver logging
     */
    enableStackdriverLogging?: boolean;
    /**
     * Enable stackdriver monitoring
     */
    enableStackdriverMonitoring?: boolean;
    /**
     * The image to use for the worker nodes
     */
    imageType: string;
    /**
     * The IP address range for the cluster pod IPs
     */
    ipPolicyClusterIpv4CidrBlock: string;
    /**
     * The name of the secondary range to be used for the cluster CIDR block
     */
    ipPolicyClusterSecondaryRangeName: string;
    /**
     * Whether a new subnetwork will be created automatically for the cluster
     */
    ipPolicyCreateSubnetwork?: boolean;
    /**
     * The IP address range of the instance IPs in this cluster
     */
    ipPolicyNodeIpv4CidrBlock: string;
    /**
     * The IP address range of the services IPs in this cluster
     */
    ipPolicyServicesIpv4CidrBlock: string;
    /**
     * The name of the secondary range to be used for the services CIDR block
     */
    ipPolicyServicesSecondaryRangeName: string;
    /**
     * A custom subnetwork name to be used if createSubnetwork is true
     */
    ipPolicySubnetworkName: string;
    /**
     * Issue a client certificate
     */
    issueClientCertificate?: boolean;
    /**
     * Enable the kubernetes dashboard
     */
    kubernetesDashboard?: boolean;
    /**
     * The map of Kubernetes labels (key/value pairs) to be applied to each node
     */
    labels: {[key: string]: string};
    /**
     * The number of local SSD disks to be attached to the node
     */
    localSsdCount?: number;
    /**
     * Locations to use for the cluster
     */
    locations: string[];
    /**
     * The machine type to use for the worker nodes
     */
    machineType: string;
    /**
     * When to performance updates on the nodes, in 24-hour time
     */
    maintenanceWindow: string;
    /**
     * Define up to 10 external networks that could access Kubernetes master through HTTPS
     */
    masterAuthorizedNetworkCidrBlocks?: string[];
    /**
     * The IP range in CIDR notation to use for the hosted master network
     */
    masterIpv4CidrBlock: string;
    /**
     * The kubernetes master version
     */
    masterVersion: string;
    /**
     * Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster
     */
    maxNodeCount?: number;
    /**
     * Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount
     */
    minNodeCount?: number;
    /**
     * The network to use for the cluster
     */
    network: string;
    /**
     * The number of nodes to create in this cluster
     */
    nodeCount?: number;
    /**
     * The ID of the cluster node pool
     */
    nodePool: string;
    /**
     * The version of kubernetes to use on the nodes
     */
    nodeVersion: string;
    /**
     * The set of Google API scopes to be made available on all of the node VMs under the default service account
     */
    oauthScopes: string[];
    /**
     * Whether the nodes are created as preemptible VM instances
     */
    preemptible?: boolean;
    /**
     * The ID of your project to use when creating a cluster
     */
    projectId: string;
    /**
     * The region to launch the cluster. Region or zone should be used
     */
    region?: string;
    /**
     * The map of Kubernetes labels (key/value pairs) to be applied to each cluster
     */
    resourceLabels: {[key: string]: string};
    /**
     * The Google Cloud Platform Service Account to be used by the node VMs
     */
    serviceAccount: string;
    /**
     * The sub-network to use for the cluster
     */
    subNetwork: string;
    /**
     * List of kubernetes taints to be applied to each node
     */
    taints?: string[];
    /**
     * Whether alias IPs will be used for pod IPs in the cluster
     */
    useIpAliases?: boolean;
    /**
     * The zone to launch the cluster. Zone or region should be used
     */
    zone?: string;
}

export interface ClusterGkeConfigV2 {
    /**
     * The GKE cluster addons
     */
    clusterAddons?: outputs.ClusterGkeConfigV2ClusterAddons;
    /**
     * The GKE ip v4 cidr block
     */
    clusterIpv4CidrBlock: string;
    /**
     * The GKE cluster description
     */
    description: string;
    /**
     * Enable Kubernetes alpha
     */
    enableKubernetesAlpha: boolean;
    /**
     * Google credential secret
     */
    googleCredentialSecret: string;
    /**
     * Is GKE cluster imported?
     */
    imported?: boolean;
    /**
     * The GKE ip allocation policy
     */
    ipAllocationPolicy?: outputs.ClusterGkeConfigV2IpAllocationPolicy;
    /**
     * The kubernetes master version
     */
    kubernetesVersion: string;
    /**
     * The GKE cluster labels
     */
    labels: {[key: string]: string};
    /**
     * The GKE cluster locations
     */
    locations: string[];
    /**
     * The GKE cluster logging service
     */
    loggingService: string;
    /**
     * The GKE cluster maintenance window
     */
    maintenanceWindow: string;
    /**
     * The GKE cluster master authorized networks config
     */
    masterAuthorizedNetworksConfig?: outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfig;
    /**
     * The GKE cluster monitoring service
     */
    monitoringService: string;
    /**
     * The GKE cluster name
     */
    name: string;
    /**
     * The GKE cluster network
     */
    network: string;
    /**
     * Is GKE cluster network policy enabled?
     */
    networkPolicyEnabled: boolean;
    /**
     * The GKE cluster node pools
     */
    nodePools?: outputs.ClusterGkeConfigV2NodePool[];
    /**
     * The GKE private cluster config
     */
    privateClusterConfig?: outputs.ClusterGkeConfigV2PrivateClusterConfig;
    /**
     * The GKE project id
     */
    projectId: string;
    /**
     * The GKE cluster region. Required if `zone` is empty
     */
    region: string;
    /**
     * The GKE cluster subnetwork
     */
    subnetwork: string;
    /**
     * The GKE cluster zone. Required if `region` is empty
     */
    zone: string;
}

export interface ClusterGkeConfigV2ClusterAddons {
    /**
     * Enable GKE horizontal pod autoscaling
     */
    horizontalPodAutoscaling: boolean;
    /**
     * Enable GKE HTTP load balancing
     */
    httpLoadBalancing: boolean;
    /**
     * Enable GKE network policy config
     */
    networkPolicyConfig: boolean;
}

export interface ClusterGkeConfigV2IpAllocationPolicy {
    /**
     * The GKE cluster ip v4 allocation cidr block
     */
    clusterIpv4CidrBlock: string;
    /**
     * The GKE cluster ip v4 allocation secondary range name
     */
    clusterSecondaryRangeName: string;
    /**
     * Create GKE subnetwork?
     */
    createSubnetwork: boolean;
    /**
     * The GKE node ip v4 allocation cidr block
     */
    nodeIpv4CidrBlock: string;
    /**
     * The GKE services ip v4 allocation cidr block
     */
    servicesIpv4CidrBlock: string;
    /**
     * The GKE services ip v4 allocation secondary range name
     */
    servicesSecondaryRangeName: string;
    /**
     * The GKE cluster subnetwork name
     */
    subnetworkName: string;
    /**
     * Use GKE ip aliases?
     */
    useIpAliases: boolean;
}

export interface ClusterGkeConfigV2MasterAuthorizedNetworksConfig {
    /**
     * The GKE master authorized network config cidr blocks
     */
    cidrBlocks: outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock[];
    /**
     * Enable GKE master authorized network config
     */
    enabled?: boolean;
}

export interface ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock {
    /**
     * The GKE master authorized network config cidr block
     */
    cidrBlock: string;
    /**
     * The GKE master authorized network config cidr block dispaly name
     */
    displayName?: string;
}

export interface ClusterGkeConfigV2NodePool {
    /**
     * The GKE node pool config autoscaling
     */
    autoscaling?: outputs.ClusterGkeConfigV2NodePoolAutoscaling;
    /**
     * The GKE node pool node config
     */
    config?: outputs.ClusterGkeConfigV2NodePoolConfig;
    /**
     * The GKE node pool config initial node count
     */
    initialNodeCount: number;
    /**
     * The GKE node pool config management
     */
    management?: outputs.ClusterGkeConfigV2NodePoolManagement;
    /**
     * The GKE node pool config max pods constraint
     */
    maxPodsConstraint: number;
    /**
     * The GKE node pool config name
     */
    name: string;
    /**
     * The GKE node pool config version
     */
    version: string;
}

export interface ClusterGkeConfigV2NodePoolAutoscaling {
    /**
     * Enable GKE node pool config autoscaling
     */
    enabled?: boolean;
    /**
     * The GKE node pool config max node count
     */
    maxNodeCount: number;
    /**
     * The GKE node pool config min node count
     */
    minNodeCount: number;
}

export interface ClusterGkeConfigV2NodePoolConfig {
    /**
     * The GKE node config disk size (Gb)
     */
    diskSizeGb?: number;
    /**
     * The GKE node config disk type
     */
    diskType?: string;
    /**
     * The GKE node config image type
     */
    imageType?: string;
    /**
     * The GKE node config labels
     */
    labels: {[key: string]: string};
    /**
     * The GKE node config local ssd count
     */
    localSsdCount?: number;
    /**
     * The GKE node config machine type
     */
    machineType?: string;
    /**
     * The GKE node config oauth scopes
     */
    oauthScopes: string[];
    /**
     * Enable GKE node config preemptible
     */
    preemptible?: boolean;
    /**
     * The GKE node config tags
     */
    tags: string[];
    /**
     * The GKE node config taints
     */
    taints?: outputs.ClusterGkeConfigV2NodePoolConfigTaint[];
}

export interface ClusterGkeConfigV2NodePoolConfigTaint {
    effect: string;
    key: string;
    value: string;
}

export interface ClusterGkeConfigV2NodePoolManagement {
    /**
     * Enable GKE node pool config management auto repair
     */
    autoRepair: boolean;
    /**
     * Enable GKE node pool config management auto upgrade
     */
    autoUpgrade: boolean;
}

export interface ClusterGkeConfigV2PrivateClusterConfig {
    /**
     * Enable GKE cluster private endpoint
     */
    enablePrivateEndpoint?: boolean;
    /**
     * Enable GKE cluster private nodes
     */
    enablePrivateNodes?: boolean;
    /**
     * The GKE cluster private master ip v4 cidr block
     */
    masterIpv4CidrBlock: string;
}

export interface ClusterK3sConfig {
    /**
     * The K3S upgrade strategy
     */
    upgradeStrategy?: outputs.ClusterK3sConfigUpgradeStrategy;
    /**
     * The K3S kubernetes version
     */
    version: string;
}

export interface ClusterK3sConfigUpgradeStrategy {
    /**
     * Drain server nodes
     */
    drainServerNodes?: boolean;
    /**
     * Drain worker nodes
     */
    drainWorkerNodes?: boolean;
    /**
     * Server concurrency
     */
    serverConcurrency?: number;
    /**
     * Worker concurrency
     */
    workerConcurrency?: number;
}

export interface ClusterOkeConfig {
    /**
     * The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
     */
    compartmentId: string;
    /**
     * An optional custom boot volume size (in GB) for the nodes
     */
    customBootVolumeSize?: number;
    /**
     * An optional description of this cluster
     */
    description?: string;
    /**
     * Enable the kubernetes dashboard
     */
    enableKubernetesDashboard?: boolean;
    /**
     * Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
     */
    enablePrivateControlPlane?: boolean;
    /**
     * Whether worker nodes are deployed into a new private subnet
     */
    enablePrivateNodes?: boolean;
    /**
     * The fingerprint corresponding to the specified user's private API Key
     */
    fingerprint: string;
    /**
     * Optional number of OCPUs for nodes (requires flexible node_shape)
     */
    flexOcpus?: number;
    /**
     * Optional specify the OCID of the KMS Vault master key
     */
    kmsKeyId?: string;
    /**
     * The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
     */
    kubernetesVersion: string;
    /**
     * Optional limit on the total number of nodes in the pool
     */
    limitNodeCount?: number;
    /**
     * The name of the first existing subnet to use for Kubernetes services / LB
     */
    loadBalancerSubnetName1?: string;
    /**
     * The (optional) name of a second existing subnet to use for Kubernetes services / LB
     */
    loadBalancerSubnetName2?: string;
    /**
     * The OS for the node image
     */
    nodeImage: string;
    /**
     * Optional name for DNS domain of node pool subnet
     */
    nodePoolDnsDomainName?: string;
    /**
     * Optional name for node pool subnet
     */
    nodePoolSubnetName?: string;
    /**
     * The contents of the SSH public key file to use for the nodes
     */
    nodePublicKeyContents?: string;
    /**
     * The shape of the node (determines number of CPUs and  amount of memory on each node)
     */
    nodeShape: string;
    /**
     * Optional specify the pod CIDR, defaults to 10.244.0.0/16
     */
    podCidr?: string;
    /**
     * The private API key file contents for the specified user, in PEM format
     */
    privateKeyContents: string;
    /**
     * The passphrase of the private key for the OKE cluster
     */
    privateKeyPassphrase?: string;
    /**
     * Number of node subnets (defaults to creating 1 regional subnet)
     */
    quantityOfNodeSubnets?: number;
    /**
     * Number of worker nodes in each subnet / availability domain
     */
    quantityPerSubnet?: number;
    /**
     * The availability domain within the region to host the OKE cluster
     */
    region: string;
    /**
     * Optional specify the service CIDR, defaults to 10.96.0.0/16
     */
    serviceCidr?: string;
    /**
     * Optional name for DNS domain of service subnet
     */
    serviceDnsDomainName?: string;
    /**
     * Whether to skip deleting VCN
     */
    skipVcnDelete?: boolean;
    /**
     * The OCID of the tenancy in which to create resources
     */
    tenancyId: string;
    /**
     * The OCID of a user who has access to the tenancy/compartment
     */
    userOcid: string;
    /**
     * The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
     */
    vcnCompartmentId?: string;
    /**
     * The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
     */
    vcnName?: string;
    /**
     * Additional CIDR from which to allow ingress to worker nodes
     */
    workerNodeIngressCidr?: string;
}

export interface ClusterRke2Config {
    /**
     * The RKE2 upgrade strategy
     */
    upgradeStrategy?: outputs.ClusterRke2ConfigUpgradeStrategy;
    /**
     * The RKE2 kubernetes version
     */
    version: string;
}

export interface ClusterRke2ConfigUpgradeStrategy {
    /**
     * Drain server nodes
     */
    drainServerNodes?: boolean;
    /**
     * Drain worker nodes
     */
    drainWorkerNodes?: boolean;
    /**
     * Server concurrency
     */
    serverConcurrency?: number;
    /**
     * Worker concurrency
     */
    workerConcurrency?: number;
}

export interface ClusterRkeConfig {
    /**
     * Optional duration in seconds of addon job.
     */
    addonJobTimeout: number;
    /**
     * Optional addons descripton to deploy on rke cluster.
     */
    addons?: string;
    /**
     * Optional addons yaml manisfest to deploy on rke cluster.
     */
    addonsIncludes?: string[];
    /**
     * Kubernetes cluster authentication
     */
    authentication?: outputs.ClusterRkeConfigAuthentication;
    /**
     * Kubernetes cluster authorization
     */
    authorization?: outputs.ClusterRkeConfigAuthorization;
    /**
     * RKE bastion host
     */
    bastionHost?: outputs.ClusterRkeConfigBastionHost;
    cloudProvider?: outputs.ClusterRkeConfigCloudProvider;
    dns?: outputs.ClusterRkeConfigDns;
    /**
     * Enable/disable using cri-dockerd
     */
    enableCriDockerd?: boolean;
    /**
     * Optional ignore docker version on nodes
     */
    ignoreDockerVersion?: boolean;
    /**
     * Kubernetes ingress configuration
     */
    ingress?: outputs.ClusterRkeConfigIngress;
    /**
     * Optional kubernetes version to deploy
     */
    kubernetesVersion: string;
    /**
     * Kubernetes cluster monitoring
     */
    monitoring?: outputs.ClusterRkeConfigMonitoring;
    /**
     * Kubernetes cluster networking
     */
    network?: outputs.ClusterRkeConfigNetwork;
    /**
     * Optional RKE cluster nodes
     */
    nodes?: outputs.ClusterRkeConfigNode[];
    /**
     * Optional prefix to customize kubernetes path
     */
    prefixPath: string;
    /**
     * Optional private registries for docker images
     */
    privateRegistries?: outputs.ClusterRkeConfigPrivateRegistry[];
    /**
     * Kubernetes cluster services
     */
    services?: outputs.ClusterRkeConfigServices;
    /**
     * Optional use ssh agent auth
     */
    sshAgentAuth?: boolean;
    /**
     * Optional cluster level SSH certificate path
     */
    sshCertPath: string;
    /**
     * Optional cluster level SSH private key path
     */
    sshKeyPath: string;
    /**
     * RKE upgrade strategy
     */
    upgradeStrategy?: outputs.ClusterRkeConfigUpgradeStrategy;
    /**
     * Optional prefix to customize kubernetes path for windows
     */
    winPrefixPath: string;
}

export interface ClusterRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface ClusterRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: string};
}

export interface ClusterRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterRkeConfigCloudProvider {
    awsCloudProvider?: outputs.ClusterRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.ClusterRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    name?: string;
    openstackCloudProvider?: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.ClusterRkeConfigCloudProviderVsphereCloudProvider;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProvider {
    global?: outputs.ClusterRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface ClusterRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    /**
     * Load balancer type (basic | standard). Must be standard for auto-scaling
     */
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage?: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer?: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata?: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route?: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProvider {
    disk?: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderDisk;
    global?: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network?: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    gracefulShutdownTimeout?: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface ClusterRkeConfigDns {
    /**
     * Linear Autoscaler Params
     */
    linearAutoscalerParams?: outputs.ClusterRkeConfigDnsLinearAutoscalerParams;
    nodeSelector: {[key: string]: string};
    /**
     * Nodelocal dns
     */
    nodelocal?: outputs.ClusterRkeConfigDnsNodelocal;
    options: {[key: string]: string};
    provider?: string;
    reverseCidrs: string[];
    /**
     * DNS service tolerations
     */
    tolerations?: outputs.ClusterRkeConfigDnsToleration[];
    /**
     * Update deployment strategy
     */
    updateStrategy?: outputs.ClusterRkeConfigDnsUpdateStrategy;
    upstreamNameservers: string[];
}

export interface ClusterRkeConfigDnsLinearAutoscalerParams {
    coresPerReplica?: number;
    max?: number;
    min?: number;
    nodesPerReplica?: number;
    preventSinglePointFailure?: boolean;
}

export interface ClusterRkeConfigDnsNodelocal {
    ipAddress?: string;
    /**
     * Node selector key pair
     */
    nodeSelector?: {[key: string]: string};
}

export interface ClusterRkeConfigDnsToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterRkeConfigDnsUpdateStrategy {
    /**
     * Rolling update for update strategy
     */
    rollingUpdate?: outputs.ClusterRkeConfigDnsUpdateStrategyRollingUpdate;
    /**
     * Strategy
     */
    strategy?: string;
}

export interface ClusterRkeConfigDnsUpdateStrategyRollingUpdate {
    /**
     * Rolling update max surge
     */
    maxSurge?: number;
    /**
     * Rolling update max unavailable
     */
    maxUnavailable?: number;
}

export interface ClusterRkeConfigIngress {
    defaultBackend?: boolean;
    dnsPolicy: string;
    extraArgs: {[key: string]: string};
    httpPort: number;
    httpsPort: number;
    networkMode: string;
    nodeSelector: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    /**
     * Ingress add-on tolerations
     */
    tolerations?: outputs.ClusterRkeConfigIngressToleration[];
    /**
     * Update daemon set strategy
     */
    updateStrategy?: outputs.ClusterRkeConfigIngressUpdateStrategy;
}

export interface ClusterRkeConfigIngressToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterRkeConfigIngressUpdateStrategy {
    /**
     * Rolling update for update strategy
     */
    rollingUpdate?: outputs.ClusterRkeConfigIngressUpdateStrategyRollingUpdate;
    /**
     * Strategy
     */
    strategy?: string;
}

export interface ClusterRkeConfigIngressUpdateStrategyRollingUpdate {
    /**
     * Rolling update max unavailable
     */
    maxUnavailable?: number;
}

export interface ClusterRkeConfigMonitoring {
    nodeSelector?: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    replicas: number;
    /**
     * Monitoring add-on tolerations
     */
    tolerations?: outputs.ClusterRkeConfigMonitoringToleration[];
    /**
     * Update deployment strategy
     */
    updateStrategy?: outputs.ClusterRkeConfigMonitoringUpdateStrategy;
}

export interface ClusterRkeConfigMonitoringToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterRkeConfigMonitoringUpdateStrategy {
    /**
     * Rolling update for update strategy
     */
    rollingUpdate?: outputs.ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate;
    /**
     * Strategy
     */
    strategy?: string;
}

export interface ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
    /**
     * Rolling update max surge
     */
    maxSurge?: number;
    /**
     * Rolling update max unavailable
     */
    maxUnavailable?: number;
}

export interface ClusterRkeConfigNetwork {
    aciNetworkProvider?: outputs.ClusterRkeConfigNetworkAciNetworkProvider;
    calicoNetworkProvider?: outputs.ClusterRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.ClusterRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.ClusterRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: string};
    plugin: string;
    /**
     * Network add-on tolerations
     */
    tolerations?: outputs.ClusterRkeConfigNetworkToleration[];
    weaveNetworkProvider?: outputs.ClusterRkeConfigNetworkWeaveNetworkProvider;
}

export interface ClusterRkeConfigNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicRefreshTickerAdjust?: string;
    apicRefreshTime?: string;
    apicSubscriptionDelay?: string;
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    capic?: string;
    controllerLogLevel?: string;
    disablePeriodicSnatGlobalInfoSync?: string;
    disableWaitForNetwork?: string;
    dropLogEnable?: string;
    durationWaitForNetwork?: string;
    enableEndpointSlice?: string;
    encapType: string;
    epRegistry?: string;
    externDynamic: string;
    externStatic: string;
    gbpPodSubnet?: string;
    hostAgentLogLevel?: string;
    imagePullPolicy?: string;
    imagePullSecret?: string;
    infraVlan?: string;
    installIstio?: string;
    istioProfile?: string;
    kafkaBrokers?: string[];
    kafkaClientCrt?: string;
    kafkaClientKey?: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    maxNodesSvcGraph?: string;
    mcastRangeEnd: string;
    mcastRangeStart: string;
    mtuHeadRoom?: string;
    multusDisable?: string;
    noPriorityClass?: string;
    nodePodIfEnable?: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    opflexClientSsl?: string;
    opflexDeviceDeleteTimeout?: string;
    opflexLogLevel?: string;
    opflexMode?: string;
    opflexServerPort?: string;
    overlayVrfName?: string;
    ovsMemoryLimit?: string;
    pbrTrackingNonSnat?: string;
    podSubnetChunkSize?: string;
    runGbpContainer?: string;
    runOpflexServerContainer?: string;
    serviceMonitorInterval?: string;
    serviceVlan: string;
    snatContractScope?: string;
    snatNamespace?: string;
    snatPortRangeEnd?: string;
    snatPortRangeStart?: string;
    snatPortsPerNode?: string;
    sriovEnable?: string;
    subnetDomainName?: string;
    systemId: string;
    tenant?: string;
    token: string;
    useAciAnywhereCrd?: string;
    useAciCniPriorityClass?: string;
    useClusterRole?: string;
    useHostNetnsVolume?: string;
    useOpflexServerVolume?: string;
    usePrivilegedContainer?: string;
    vmmController?: string;
    vmmDomain?: string;
    vrfName: string;
    vrfTenant: string;
}

export interface ClusterRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface ClusterRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface ClusterRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface ClusterRkeConfigNetworkToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface ClusterRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    labels?: {[key: string]: string};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterRkeConfigPrivateRegistry {
    /**
     * ECR credential plugin config
     */
    ecrCredentialPlugin?: outputs.ClusterRkeConfigPrivateRegistryEcrCredentialPlugin;
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface ClusterRkeConfigPrivateRegistryEcrCredentialPlugin {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    awsSessionToken?: string;
}

export interface ClusterRkeConfigServices {
    etcd?: outputs.ClusterRkeConfigServicesEtcd;
    kubeApi?: outputs.ClusterRkeConfigServicesKubeApi;
    kubeController?: outputs.ClusterRkeConfigServicesKubeController;
    kubelet?: outputs.ClusterRkeConfigServicesKubelet;
    kubeproxy?: outputs.ClusterRkeConfigServicesKubeproxy;
    scheduler?: outputs.ClusterRkeConfigServicesScheduler;
}

export interface ClusterRkeConfigServicesEtcd {
    backupConfig?: outputs.ClusterRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface ClusterRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface ClusterRkeConfigServicesKubeApi {
    /**
     * Cluster admission configuration
     */
    admissionConfiguration?: outputs.ClusterRkeConfigServicesKubeApiAdmissionConfiguration;
    alwaysPullImages?: boolean;
    auditLog?: outputs.ClusterRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.ClusterRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    secretsEncryptionConfig?: outputs.ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface ClusterRkeConfigServicesKubeApiAdmissionConfiguration {
    /**
     * Admission configuration ApiVersion
     */
    apiVersion?: string;
    /**
     * Admission configuration Kind
     */
    kind?: string;
    /**
     * Admission configuration plugins
     */
    plugins?: outputs.ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugin[];
}

export interface ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugin {
    /**
     * Plugin configuration
     */
    configuration: string;
    /**
     * Plugin name
     */
    name: string;
    /**
     * Plugin path
     */
    path?: string;
}

export interface ClusterRkeConfigServicesKubeApiAuditLog {
    configuration?: outputs.ClusterRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface ClusterRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: string;
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface ClusterRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface ClusterRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterRkeConfigServicesScheduler {
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput?: outputs.ClusterRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface ClusterRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface ClusterRoleTemplateBindingTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterSyncNode {
    annotations: {[key: string]: string};
    capacity: {[key: string]: string};
    clusterId: string;
    externalIpAddress: string;
    hostname: string;
    id: string;
    ipAddress: string;
    labels: {[key: string]: string};
    name: string;
    nodePoolId: string;
    nodeTemplateId: string;
    providerId: string;
    requestedHostname: string;
    roles: string[];
    sshUser: string;
    systemInfo: {[key: string]: string};
}

export interface ClusterSyncTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterTemplateMember {
    /**
     * Member access type: member, owner, read-only
     */
    accessType?: string;
    /**
     * Member group principal id
     */
    groupPrincipalId?: string;
    /**
     * Member user principal id
     */
    userPrincipalId?: string;
}

export interface ClusterTemplateTemplateRevision {
    /**
     * Annotations of the resource
     */
    annotations: {[key: string]: string};
    /**
     * Cluster configuration
     */
    clusterConfig: outputs.ClusterTemplateTemplateRevisionClusterConfig;
    /**
     * Cluster template ID
     */
    clusterTemplateId: string;
    /**
     * Default cluster template revision
     */
    default?: boolean;
    /**
     * Enable cluster template revision
     */
    enabled?: boolean;
    /**
     * Cluster template revision ID
     */
    id: string;
    /**
     * Labels of the resource
     */
    labels: {[key: string]: string};
    /**
     * Cluster template revision name
     */
    name: string;
    /**
     * Cluster template questions
     */
    questions?: outputs.ClusterTemplateTemplateRevisionQuestion[];
}

export interface ClusterTemplateTemplateRevisionClusterConfig {
    /**
     * Local cluster auth endpoint
     */
    clusterAuthEndpoint?: outputs.ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint;
    /**
     * Default cluster role for project members
     */
    defaultClusterRoleForProjectMembers: string;
    /**
     * Default pod security admission configuration template name
     */
    defaultPodSecurityAdmissionConfigurationTemplateName: string;
    /**
     * Desired agent image
     */
    desiredAgentImage: string;
    /**
     * Desired auth image
     */
    desiredAuthImage: string;
    /**
     * Docker Root Dir
     */
    dockerRootDir: string;
    /**
     * Enable project network isolation
     */
    enableNetworkPolicy?: boolean;
    /**
     * Rancher Kubernetes Engine Config
     */
    rkeConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfig;
    /**
     * Windows prefered cluster
     */
    windowsPreferedCluster?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfig {
    /**
     * Optional duration in seconds of addon job.
     */
    addonJobTimeout: number;
    /**
     * Optional addons descripton to deploy on rke cluster.
     */
    addons?: string;
    /**
     * Optional addons yaml manisfest to deploy on rke cluster.
     */
    addonsIncludes?: string[];
    /**
     * Kubernetes cluster authentication
     */
    authentication?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication;
    /**
     * Kubernetes cluster authorization
     */
    authorization?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization;
    /**
     * RKE bastion host
     */
    bastionHost?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost;
    cloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider;
    dns?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns;
    /**
     * Enable/disable using cri-dockerd
     */
    enableCriDockerd?: boolean;
    /**
     * Optional ignore docker version on nodes
     */
    ignoreDockerVersion?: boolean;
    /**
     * Kubernetes ingress configuration
     */
    ingress?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress;
    /**
     * Optional kubernetes version to deploy
     */
    kubernetesVersion: string;
    /**
     * Kubernetes cluster monitoring
     */
    monitoring?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring;
    /**
     * Kubernetes cluster networking
     */
    network?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork;
    /**
     * Optional RKE cluster nodes
     */
    nodes?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode[];
    /**
     * Optional prefix to customize kubernetes path
     */
    prefixPath: string;
    /**
     * Optional private registries for docker images
     */
    privateRegistries?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry[];
    /**
     * Kubernetes cluster services
     */
    services?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices;
    /**
     * Optional use ssh agent auth
     */
    sshAgentAuth?: boolean;
    /**
     * Optional cluster level SSH certificate path
     */
    sshCertPath: string;
    /**
     * Optional cluster level SSH private key path
     */
    sshKeyPath: string;
    /**
     * RKE upgrade strategy
     */
    upgradeStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy;
    /**
     * Optional prefix to customize kubernetes path for windows
     */
    winPrefixPath: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: string};
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider {
    awsCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    name?: string;
    openstackCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider {
    global?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    /**
     * Load balancer type (basic | standard). Must be standard for auto-scaling
     */
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider {
    disk?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk;
    global?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    gracefulShutdownTimeout?: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns {
    /**
     * Linear Autoscaler Params
     */
    linearAutoscalerParams?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams;
    nodeSelector: {[key: string]: string};
    /**
     * Nodelocal dns
     */
    nodelocal?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal;
    options: {[key: string]: string};
    provider?: string;
    reverseCidrs: string[];
    /**
     * DNS service tolerations
     */
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration[];
    /**
     * Update deployment strategy
     */
    updateStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy;
    upstreamNameservers: string[];
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams {
    coresPerReplica?: number;
    max?: number;
    min?: number;
    nodesPerReplica?: number;
    preventSinglePointFailure?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal {
    ipAddress?: string;
    /**
     * Node selector key pair
     */
    nodeSelector?: {[key: string]: string};
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy {
    /**
     * Rolling update for update strategy
     */
    rollingUpdate?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate;
    /**
     * Strategy
     */
    strategy?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate {
    /**
     * Rolling update max surge
     */
    maxSurge?: number;
    /**
     * Rolling update max unavailable
     */
    maxUnavailable?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress {
    defaultBackend?: boolean;
    dnsPolicy: string;
    extraArgs: {[key: string]: string};
    httpPort: number;
    httpsPort: number;
    networkMode: string;
    nodeSelector: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    /**
     * Ingress add-on tolerations
     */
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration[];
    /**
     * Update daemon set strategy
     */
    updateStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy {
    /**
     * Rolling update for update strategy
     */
    rollingUpdate?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate;
    /**
     * Strategy
     */
    strategy?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate {
    /**
     * Rolling update max unavailable
     */
    maxUnavailable?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring {
    nodeSelector?: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    replicas: number;
    /**
     * Monitoring add-on tolerations
     */
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration[];
    /**
     * Update deployment strategy
     */
    updateStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy {
    /**
     * Rolling update for update strategy
     */
    rollingUpdate?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate;
    /**
     * Strategy
     */
    strategy?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate {
    /**
     * Rolling update max surge
     */
    maxSurge?: number;
    /**
     * Rolling update max unavailable
     */
    maxUnavailable?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork {
    aciNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider;
    calicoNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: string};
    plugin: string;
    /**
     * Network add-on tolerations
     */
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration[];
    weaveNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicRefreshTickerAdjust?: string;
    apicRefreshTime?: string;
    apicSubscriptionDelay?: string;
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    capic?: string;
    controllerLogLevel?: string;
    disablePeriodicSnatGlobalInfoSync?: string;
    disableWaitForNetwork?: string;
    dropLogEnable?: string;
    durationWaitForNetwork?: string;
    enableEndpointSlice?: string;
    encapType: string;
    epRegistry?: string;
    externDynamic: string;
    externStatic: string;
    gbpPodSubnet?: string;
    hostAgentLogLevel?: string;
    imagePullPolicy?: string;
    imagePullSecret?: string;
    infraVlan?: string;
    installIstio?: string;
    istioProfile?: string;
    kafkaBrokers?: string[];
    kafkaClientCrt?: string;
    kafkaClientKey?: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    maxNodesSvcGraph?: string;
    mcastRangeEnd: string;
    mcastRangeStart: string;
    mtuHeadRoom?: string;
    multusDisable?: string;
    noPriorityClass?: string;
    nodePodIfEnable?: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    opflexClientSsl?: string;
    opflexDeviceDeleteTimeout?: string;
    opflexLogLevel?: string;
    opflexMode?: string;
    opflexServerPort?: string;
    overlayVrfName?: string;
    ovsMemoryLimit?: string;
    pbrTrackingNonSnat?: string;
    podSubnetChunkSize?: string;
    runGbpContainer?: string;
    runOpflexServerContainer?: string;
    serviceMonitorInterval?: string;
    serviceVlan: string;
    snatContractScope?: string;
    snatNamespace?: string;
    snatPortRangeEnd?: string;
    snatPortRangeStart?: string;
    snatPortsPerNode?: string;
    sriovEnable?: string;
    subnetDomainName?: string;
    systemId: string;
    tenant?: string;
    token: string;
    useAciAnywhereCrd?: string;
    useAciCniPriorityClass?: string;
    useClusterRole?: string;
    useHostNetnsVolume?: string;
    useOpflexServerVolume?: string;
    usePrivilegedContainer?: string;
    vmmController?: string;
    vmmDomain?: string;
    vrfName: string;
    vrfTenant: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    labels?: {[key: string]: string};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry {
    /**
     * ECR credential plugin config
     */
    ecrCredentialPlugin?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin;
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    awsSessionToken?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices {
    etcd?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd;
    kubeApi?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi;
    kubeController?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController;
    kubelet?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet;
    kubeproxy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy;
    scheduler?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd {
    backupConfig?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi {
    /**
     * Cluster admission configuration
     */
    admissionConfiguration?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration;
    alwaysPullImages?: boolean;
    auditLog?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    secretsEncryptionConfig?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration {
    /**
     * Admission configuration ApiVersion
     */
    apiVersion?: string;
    /**
     * Admission configuration Kind
     */
    kind?: string;
    /**
     * Admission configuration plugins
     */
    plugins?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPlugin[];
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPlugin {
    /**
     * Plugin configuration
     */
    configuration: string;
    /**
     * Plugin name
     */
    name: string;
    /**
     * Plugin path
     */
    path?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog {
    configuration?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: string;
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler {
    extraArgs: {[key: string]: string};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface ClusterTemplateTemplateRevisionQuestion {
    /**
     * Default variable value
     */
    default: string;
    /**
     * Required variable
     */
    required?: boolean;
    /**
     * Variable type
     */
    type?: string;
    /**
     * Variable name
     */
    variable: string;
}

export interface ClusterTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterV2AgentEnvVar {
    name: string;
    value: string;
}

export interface ClusterV2ClusterAgentDeploymentCustomization {
    /**
     * User defined tolerations to append to agent
     */
    appendTolerations?: outputs.ClusterV2ClusterAgentDeploymentCustomizationAppendToleration[];
    /**
     * User defined affinity to override default agent affinity
     */
    overrideAffinity?: string;
    /**
     * User defined resource requirements to set on the agent
     */
    overrideResourceRequirements?: outputs.ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement[];
}

export interface ClusterV2ClusterAgentDeploymentCustomizationAppendToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement {
    /**
     * The maximum CPU limit for agent
     */
    cpuLimit?: string;
    /**
     * The minimum CPU required for agent
     */
    cpuRequest?: string;
    /**
     * The maximum memory limit for agent
     */
    memoryLimit?: string;
    /**
     * The minimum memory required for agent
     */
    memoryRequest?: string;
}

export interface ClusterV2ClusterRegistrationToken {
    annotations: {[key: string]: string};
    clusterId: string;
    command: string;
    id: string;
    insecureCommand: string;
    insecureNodeCommand: string;
    insecureWindowsNodeCommand: string;
    labels: {[key: string]: string};
    manifestUrl: string;
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface ClusterV2FleetAgentDeploymentCustomization {
    /**
     * User defined tolerations to append to agent
     */
    appendTolerations?: outputs.ClusterV2FleetAgentDeploymentCustomizationAppendToleration[];
    /**
     * User defined affinity to override default agent affinity
     */
    overrideAffinity?: string;
    /**
     * User defined resource requirements to set on the agent
     */
    overrideResourceRequirements?: outputs.ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement[];
}

export interface ClusterV2FleetAgentDeploymentCustomizationAppendToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement {
    /**
     * The maximum CPU limit for agent
     */
    cpuLimit?: string;
    /**
     * The minimum CPU required for agent
     */
    cpuRequest?: string;
    /**
     * The maximum memory limit for agent
     */
    memoryLimit?: string;
    /**
     * The minimum memory required for agent
     */
    memoryRequest?: string;
}

export interface ClusterV2LocalAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface ClusterV2RkeConfig {
    /**
     * Cluster V2 additional manifest
     */
    additionalManifest?: string;
    /**
     * Cluster V2 chart values. It should be in YAML format
     */
    chartValues?: string;
    /**
     * Cluster V2 etcd
     */
    etcd?: outputs.ClusterV2RkeConfigEtcd;
    /**
     * Cluster V2 etcd snapshot create
     */
    etcdSnapshotCreate?: outputs.ClusterV2RkeConfigEtcdSnapshotCreate;
    /**
     * Cluster V2 etcd snapshot restore
     */
    etcdSnapshotRestore?: outputs.ClusterV2RkeConfigEtcdSnapshotRestore;
    /**
     * Cluster V2 local auth endpoint
     *
     * @deprecated Deprecated
     */
    localAuthEndpoint?: outputs.ClusterV2RkeConfigLocalAuthEndpoint;
    /**
     * Cluster V2 machine global config
     */
    machineGlobalConfig?: string;
    /**
     * Default values for machine pool configurations if unset
     */
    machinePoolDefaults?: outputs.ClusterV2RkeConfigMachinePoolDefault[];
    /**
     * Cluster V2 machine pools
     */
    machinePools?: outputs.ClusterV2RkeConfigMachinePool[];
    /**
     * Cluster V2 machine selector config
     */
    machineSelectorConfigs?: outputs.ClusterV2RkeConfigMachineSelectorConfig[];
    /**
     * Cluster V2 machine selector files
     */
    machineSelectorFiles?: outputs.ClusterV2RkeConfigMachineSelectorFile[];
    /**
     * Cluster V2 registries
     */
    registries?: outputs.ClusterV2RkeConfigRegistries;
    /**
     * Cluster V2 certificate rotation
     */
    rotateCertificates?: outputs.ClusterV2RkeConfigRotateCertificates;
    /**
     * Cluster V2 upgrade strategy
     */
    upgradeStrategy?: outputs.ClusterV2RkeConfigUpgradeStrategy;
}

export interface ClusterV2RkeConfigEtcd {
    /**
     * Disable ETCD snapshots
     */
    disableSnapshots?: boolean;
    /**
     * ETCD snapshot S3 config
     */
    s3Config?: outputs.ClusterV2RkeConfigEtcdS3Config;
    /**
     * ETCD snapshot retention
     */
    snapshotRetention?: number;
    /**
     * ETCD snapshot schedule cron (e.g `"0 *&#47;5 * * *"`)
     */
    snapshotScheduleCron?: string;
}

export interface ClusterV2RkeConfigEtcdS3Config {
    /**
     * ETCD snapshot S3 bucket
     */
    bucket: string;
    /**
     * ETCD snapshot S3 cloud credential name
     */
    cloudCredentialName?: string;
    /**
     * ETCD snapshot S3 endpoint
     */
    endpoint: string;
    /**
     * ETCD snapshot S3 endpoint CA
     */
    endpointCa?: string;
    /**
     * ETCD snapshot S3 folder
     */
    folder?: string;
    /**
     * ETCD snapshot S3 region
     */
    region?: string;
    /**
     * Disable ETCD skip ssl verify
     */
    skipSslVerify?: boolean;
}

export interface ClusterV2RkeConfigEtcdSnapshotCreate {
    /**
     * ETCD generation to initiate a snapshot
     */
    generation: number;
}

export interface ClusterV2RkeConfigEtcdSnapshotRestore {
    /**
     * ETCD snapshot desired generation
     */
    generation: number;
    /**
     * ETCD snapshot name to restore
     */
    name: string;
    /**
     * ETCD restore RKE config (set to none, all, or kubernetesVersion)
     */
    restoreRkeConfig?: string;
}

export interface ClusterV2RkeConfigLocalAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface ClusterV2RkeConfigMachinePool {
    /**
     * Annotations of the resource
     */
    annotations: {[key: string]: string};
    /**
     * Machine pool cloud credential secret name
     */
    cloudCredentialSecretName?: string;
    /**
     * Machine pool control plane role
     */
    controlPlaneRole?: boolean;
    /**
     * Machine pool drain before delete
     */
    drainBeforeDelete?: boolean;
    /**
     * Machine pool etcd role
     */
    etcdRole?: boolean;
    /**
     * maximum length for autogenerated hostname
     */
    hostnameLengthLimit?: number;
    /**
     * Labels of the resource
     */
    labels: {[key: string]: string};
    /**
     * Machine config data
     */
    machineConfig: outputs.ClusterV2RkeConfigMachinePoolMachineConfig;
    /**
     * Labels of the machine
     */
    machineLabels: {[key: string]: string};
    /**
     * max unhealthy nodes for automated replacement to be allowed
     */
    maxUnhealthy?: string;
    /**
     * Machine pool name
     */
    name: string;
    /**
     * seconds to wait for machine pool drain to complete before machine deletion
     */
    nodeDrainTimeout?: number;
    /**
     * seconds a new node has to become active before it is replaced
     */
    nodeStartupTimeoutSeconds?: number;
    /**
     * Machine pool paused
     */
    paused?: boolean;
    /**
     * Machine pool quantity
     */
    quantity?: number;
    /**
     * Machine pool rolling update
     */
    rollingUpdate?: outputs.ClusterV2RkeConfigMachinePoolRollingUpdate;
    /**
     * Machine pool taints
     */
    taints?: outputs.ClusterV2RkeConfigMachinePoolTaint[];
    /**
     * seconds an unhealthy node has to become active before it is replaced
     */
    unhealthyNodeTimeoutSeconds?: number;
    /**
     * range of unhealthy nodes for automated replacement to be allowed
     */
    unhealthyRange?: string;
    /**
     * Machine pool worker role
     */
    workerRole?: boolean;
}

export interface ClusterV2RkeConfigMachinePoolDefault {
    /**
     * maximum length for autogenerated hostname
     */
    hostnameLengthLimit?: number;
}

export interface ClusterV2RkeConfigMachinePoolMachineConfig {
    /**
     * Machine config API version
     */
    apiVersion?: string;
    /**
     * Machine config kind
     */
    kind: string;
    /**
     * Machine config name
     */
    name: string;
}

export interface ClusterV2RkeConfigMachinePoolRollingUpdate {
    /**
     * Rolling update max surge
     */
    maxSurge?: string;
    /**
     * Rolling update max unavailable
     */
    maxUnavailable?: string;
}

export interface ClusterV2RkeConfigMachinePoolTaint {
    effect?: string;
    key: string;
    value: string;
}

export interface ClusterV2RkeConfigMachineSelectorConfig {
    /**
     * Machine selector config
     */
    config?: string;
    /**
     * Machine label selector
     */
    machineLabelSelector?: outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector;
}

export interface ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector {
    /**
     * Label selector match expressions
     */
    matchExpressions?: outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression[];
    /**
     * Label selector match labels
     */
    matchLabels?: {[key: string]: string};
}

export interface ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression {
    /**
     * Label selector requirement key
     */
    key?: string;
    /**
     * Label selector operator
     */
    operator?: string;
    /**
     * Label selector requirement values
     */
    values?: string[];
}

export interface ClusterV2RkeConfigMachineSelectorFile {
    /**
     * File sources
     */
    fileSources?: outputs.ClusterV2RkeConfigMachineSelectorFileFileSource[];
    /**
     * Machine label selector
     */
    machineLabelSelector?: outputs.ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector;
}

export interface ClusterV2RkeConfigMachineSelectorFileFileSource {
    /**
     * The configmap which is the source of files
     */
    configmap?: outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap;
    /**
     * The secret which is the source of files
     */
    secret?: outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceSecret;
}

export interface ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap {
    /**
     * The default permissions to be applied when they are not set at the item level
     */
    defaultPermissions?: string;
    /**
     * Items(files) to retrieve from the K8s object
     */
    items?: outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem[];
    /**
     * The name of the K8s object
     */
    name: string;
}

export interface ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem {
    /**
     * If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
     */
    dynamic?: boolean;
    /**
     * The base64 encoded value of the SHA256 checksum of the file's content
     */
    hash?: string;
    /**
     * The key of the item(file) to retrieve
     */
    key: string;
    /**
     * The path to put the file in the target node
     */
    path: string;
    /**
     * The numeric representation of the file permissions
     */
    permissions?: string;
}

export interface ClusterV2RkeConfigMachineSelectorFileFileSourceSecret {
    /**
     * The default permissions to be applied when they are not set at the item level
     */
    defaultPermissions?: string;
    /**
     * Items(files) to retrieve from the K8s object
     */
    items?: outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem[];
    /**
     * The name of the K8s object
     */
    name: string;
}

export interface ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem {
    /**
     * If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
     */
    dynamic?: boolean;
    /**
     * The base64 encoded value of the SHA256 checksum of the file's content
     */
    hash?: string;
    /**
     * The key of the item(file) to retrieve
     */
    key: string;
    /**
     * The path to put the file in the target node
     */
    path: string;
    /**
     * The numeric representation of the file permissions
     */
    permissions?: string;
}

export interface ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector {
    /**
     * Label selector match expressions
     */
    matchExpressions?: outputs.ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression[];
    /**
     * Label selector match labels
     */
    matchLabels?: {[key: string]: string};
}

export interface ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression {
    /**
     * Label selector requirement key
     */
    key?: string;
    /**
     * Label selector operator
     */
    operator?: string;
    /**
     * Label selector requirement values
     */
    values?: string[];
}

export interface ClusterV2RkeConfigRegistries {
    /**
     * Registry config
     */
    configs?: outputs.ClusterV2RkeConfigRegistriesConfig[];
    /**
     * Registry mirrors
     */
    mirrors?: outputs.ClusterV2RkeConfigRegistriesMirror[];
}

export interface ClusterV2RkeConfigRegistriesConfig {
    /**
     * Registry auth config secret name
     */
    authConfigSecretName?: string;
    /**
     * Registry CA bundle
     */
    caBundle?: string;
    /**
     * Registry hostname
     */
    hostname: string;
    /**
     * Registry insecure connectivity
     */
    insecure?: boolean;
    /**
     * Registry TLS secret name. TLS is a pair of Cert/Key
     */
    tlsSecretName?: string;
}

export interface ClusterV2RkeConfigRegistriesMirror {
    /**
     * Registry mirror endpoints
     */
    endpoints?: string[];
    /**
     * Registry hostname
     */
    hostname: string;
    /**
     * Registry mirror rewrites
     */
    rewrites?: {[key: string]: string};
}

export interface ClusterV2RkeConfigRotateCertificates {
    /**
     * Desired certificate rotation generation.
     */
    generation: number;
    /**
     * Service certificates to rotate with this generation.
     */
    services?: string[];
}

export interface ClusterV2RkeConfigUpgradeStrategy {
    /**
     * How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
     */
    controlPlaneConcurrency?: string;
    /**
     * Controlplane nodes drain options
     */
    controlPlaneDrainOptions?: outputs.ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions;
    /**
     * How many worker nodes should be upgrade at time
     */
    workerConcurrency?: string;
    /**
     * Worker nodes drain options
     */
    workerDrainOptions?: outputs.ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions;
}

export interface ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions {
    /**
     * Drain options delete empty dir data
     */
    deleteEmptyDirData?: boolean;
    /**
     * Drain options disable eviction
     */
    disableEviction?: boolean;
    /**
     * Drain options enabled?
     */
    enabled?: boolean;
    /**
     * Drain options force
     */
    force?: boolean;
    /**
     * Drain options grace period
     */
    gracePeriod: number;
    /**
     * Drain options ignore daemon sets
     */
    ignoreDaemonSets?: boolean;
    /**
     * Drain options ignore errors
     */
    ignoreErrors?: boolean;
    /**
     * Drain options skip wait for delete timeout seconds
     */
    skipWaitForDeleteTimeoutSeconds: number;
    /**
     * Drain options timeout
     */
    timeout: number;
}

export interface ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions {
    /**
     * Drain options delete empty dir data
     */
    deleteEmptyDirData?: boolean;
    /**
     * Drain options disable eviction
     */
    disableEviction?: boolean;
    /**
     * Drain options enabled?
     */
    enabled?: boolean;
    /**
     * Drain options force
     */
    force?: boolean;
    /**
     * Drain options grace period
     */
    gracePeriod: number;
    /**
     * Drain options ignore daemon sets
     */
    ignoreDaemonSets?: boolean;
    /**
     * Drain options ignore errors
     */
    ignoreErrors?: boolean;
    /**
     * Drain options skip wait for delete timeout seconds
     */
    skipWaitForDeleteTimeoutSeconds: number;
    /**
     * Drain options timeout
     */
    timeout: number;
}

export interface ClusterV2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigMapV2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CustomUserTokenTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EtcdBackupBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.EtcdBackupBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface EtcdBackupBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface EtcdBackupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetClusterAksConfig {
    aadServerAppSecret: string;
    aadTenantId: string;
    addClientAppId: string;
    addServerAppId: string;
    adminUsername: string;
    agentDnsPrefix: string;
    agentOsDiskSize: number;
    agentPoolName: string;
    agentStorageProfile: string;
    agentVmSize: string;
    authBaseUrl: string;
    baseUrl: string;
    clientId: string;
    clientSecret: string;
    count: number;
    dnsServiceIp: string;
    dockerBridgeCidr: string;
    enableHttpApplicationRouting: boolean;
    enableMonitoring: boolean;
    kubernetesVersion: string;
    loadBalancerSku: string;
    location: string;
    logAnalyticsWorkspace: string;
    logAnalyticsWorkspaceResourceGroup: string;
    masterDnsPrefix: string;
    maxPods: number;
    networkPlugin: string;
    networkPolicy: string;
    podCidr: string;
    resourceGroup: string;
    serviceCidr: string;
    sshPublicKeyContents: string;
    subnet: string;
    subscriptionId: string;
    tag: {[key: string]: string};
    tags: string[];
    tenantId: string;
    virtualNetwork: string;
    virtualNetworkResourceGroup: string;
}

export interface GetClusterAksConfigV2 {
    authBaseUrl: string;
    authorizedIpRanges: string[];
    baseUrl: string;
    cloudCredentialId: string;
    dnsPrefix: string;
    httpApplicationRouting: boolean;
    imported: boolean;
    kubernetesVersion: string;
    linuxAdminUsername: string;
    linuxSshPublicKey: string;
    loadBalancerSku: string;
    logAnalyticsWorkspaceGroup: string;
    logAnalyticsWorkspaceName: string;
    monitoring: boolean;
    name: string;
    networkDnsServiceIp: string;
    networkDockerBridgeCidr: string;
    networkPlugin: string;
    networkPodCidr: string;
    networkPolicy: string;
    networkServiceCidr: string;
    nodePools: outputs.GetClusterAksConfigV2NodePool[];
    nodeResourceGroup: string;
    privateCluster: boolean;
    resourceGroup: string;
    resourceLocation: string;
    subnet: string;
    tags: {[key: string]: string};
    virtualNetwork: string;
    virtualNetworkResourceGroup: string;
}

export interface GetClusterAksConfigV2NodePool {
    availabilityZones: string[];
    count: number;
    enableAutoScaling: boolean;
    labels: {[key: string]: string};
    maxCount: number;
    maxPods: number;
    maxSurge: string;
    minCount: number;
    mode: string;
    name: string;
    orchestratorVersion: string;
    osDiskSizeGb: number;
    osDiskType: string;
    osType: string;
    taints: string[];
    vmSize: string;
}

export interface GetClusterClusterAuthEndpoint {
    caCerts: string;
    enabled: boolean;
    fqdn: string;
}

export interface GetClusterClusterRegistrationToken {
    annotations: {[key: string]: string};
    clusterId: string;
    command: string;
    id: string;
    insecureCommand: string;
    insecureNodeCommand: string;
    insecureWindowsNodeCommand: string;
    labels: {[key: string]: string};
    manifestUrl: string;
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface GetClusterClusterTemplateAnswer {
    clusterId: string;
    projectId: string;
    values: {[key: string]: string};
}

export interface GetClusterClusterTemplateQuestion {
    default: string;
    required: boolean;
    type: string;
    variable: string;
}

export interface GetClusterEksConfig {
    accessKey: string;
    ami: string;
    associateWorkerNodePublicIp: boolean;
    desiredNodes: number;
    ebsEncryption: boolean;
    instanceType: string;
    keyPairName: string;
    kubernetesVersion: string;
    maximumNodes: number;
    minimumNodes: number;
    nodeVolumeSize: number;
    region: string;
    secretKey: string;
    securityGroups: string[];
    serviceRole: string;
    sessionToken: string;
    subnets: string[];
    userData: string;
    virtualNetwork: string;
}

export interface GetClusterEksConfigV2 {
    cloudCredentialId: string;
    imported: boolean;
    kmsKey: string;
    kubernetesVersion: string;
    loggingTypes: string[];
    name: string;
    nodeGroups: outputs.GetClusterEksConfigV2NodeGroup[];
    privateAccess: boolean;
    publicAccess: boolean;
    publicAccessSources: string[];
    region: string;
    secretsEncryption: boolean;
    securityGroups: string[];
    serviceRole: string;
    subnets: string[];
    tags: {[key: string]: string};
}

export interface GetClusterEksConfigV2NodeGroup {
    desiredSize: number;
    diskSize: number;
    ec2SshKey: string;
    gpu: boolean;
    imageId: string;
    instanceType: string;
    labels: {[key: string]: string};
    launchTemplates: outputs.GetClusterEksConfigV2NodeGroupLaunchTemplate[];
    maxSize: number;
    minSize: number;
    name: string;
    nodeRole: string;
    requestSpotInstances: boolean;
    resourceTags: {[key: string]: string};
    spotInstanceTypes: string[];
    subnets: string[];
    tags: {[key: string]: string};
    userData: string;
    version: string;
}

export interface GetClusterEksConfigV2NodeGroupLaunchTemplate {
    id: string;
    name: string;
    version: number;
}

export interface GetClusterGkeConfig {
    clusterIpv4Cidr: string;
    credential: string;
    description: string;
    diskSizeGb: number;
    diskType: string;
    enableAlphaFeature: boolean;
    enableAutoRepair: boolean;
    enableAutoUpgrade: boolean;
    enableHorizontalPodAutoscaling: boolean;
    enableHttpLoadBalancing: boolean;
    enableKubernetesDashboard: boolean;
    enableLegacyAbac: boolean;
    enableMasterAuthorizedNetwork: boolean;
    enableNetworkPolicyConfig: boolean;
    enableNodepoolAutoscaling: boolean;
    enablePrivateEndpoint: boolean;
    enablePrivateNodes: boolean;
    enableStackdriverLogging: boolean;
    enableStackdriverMonitoring: boolean;
    imageType: string;
    ipPolicyClusterIpv4CidrBlock: string;
    ipPolicyClusterSecondaryRangeName: string;
    ipPolicyCreateSubnetwork: boolean;
    ipPolicyNodeIpv4CidrBlock: string;
    ipPolicyServicesIpv4CidrBlock: string;
    ipPolicyServicesSecondaryRangeName: string;
    ipPolicySubnetworkName: string;
    issueClientCertificate: boolean;
    kubernetesDashboard: boolean;
    labels: {[key: string]: string};
    localSsdCount: number;
    locations: string[];
    machineType: string;
    maintenanceWindow: string;
    masterAuthorizedNetworkCidrBlocks: string[];
    masterIpv4CidrBlock: string;
    masterVersion: string;
    maxNodeCount: number;
    minNodeCount: number;
    network: string;
    nodeCount: number;
    nodePool: string;
    nodeVersion: string;
    oauthScopes: string[];
    preemptible: boolean;
    projectId: string;
    region: string;
    resourceLabels: {[key: string]: string};
    serviceAccount: string;
    subNetwork: string;
    taints: string[];
    useIpAliases: boolean;
    zone: string;
}

export interface GetClusterGkeConfigV2 {
    clusterAddons: outputs.GetClusterGkeConfigV2ClusterAddon[];
    clusterIpv4CidrBlock: string;
    description: string;
    enableKubernetesAlpha: boolean;
    googleCredentialSecret: string;
    imported: boolean;
    ipAllocationPolicies: outputs.GetClusterGkeConfigV2IpAllocationPolicy[];
    kubernetesVersion: string;
    labels: {[key: string]: string};
    locations: string[];
    loggingService: string;
    maintenanceWindow: string;
    masterAuthorizedNetworksConfigs: outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfig[];
    monitoringService: string;
    name: string;
    network: string;
    networkPolicyEnabled: boolean;
    nodePools: outputs.GetClusterGkeConfigV2NodePool[];
    privateClusterConfigs: outputs.GetClusterGkeConfigV2PrivateClusterConfig[];
    projectId: string;
    region: string;
    subnetwork: string;
    zone: string;
}

export interface GetClusterGkeConfigV2ClusterAddon {
    horizontalPodAutoscaling: boolean;
    httpLoadBalancing: boolean;
    networkPolicyConfig: boolean;
}

export interface GetClusterGkeConfigV2IpAllocationPolicy {
    clusterIpv4CidrBlock: string;
    clusterSecondaryRangeName: string;
    createSubnetwork: boolean;
    nodeIpv4CidrBlock: string;
    servicesIpv4CidrBlock: string;
    servicesSecondaryRangeName: string;
    subnetworkName: string;
    useIpAliases: boolean;
}

export interface GetClusterGkeConfigV2MasterAuthorizedNetworksConfig {
    cidrBlocks: outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock[];
    enabled: boolean;
}

export interface GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock {
    cidrBlock: string;
    displayName: string;
}

export interface GetClusterGkeConfigV2NodePool {
    autoscalings: outputs.GetClusterGkeConfigV2NodePoolAutoscaling[];
    configs: outputs.GetClusterGkeConfigV2NodePoolConfig[];
    initialNodeCount: number;
    managements: outputs.GetClusterGkeConfigV2NodePoolManagement[];
    maxPodsConstraint: number;
    name: string;
    version: string;
}

export interface GetClusterGkeConfigV2NodePoolAutoscaling {
    enabled: boolean;
    maxNodeCount: number;
    minNodeCount: number;
}

export interface GetClusterGkeConfigV2NodePoolConfig {
    diskSizeGb: number;
    diskType: string;
    imageType: string;
    labels: {[key: string]: string};
    localSsdCount: number;
    machineType: string;
    oauthScopes: string[];
    preemptible: boolean;
    tags: string[];
    taints: outputs.GetClusterGkeConfigV2NodePoolConfigTaint[];
}

export interface GetClusterGkeConfigV2NodePoolConfigTaint {
    effect: string;
    key: string;
    value: string;
}

export interface GetClusterGkeConfigV2NodePoolManagement {
    autoRepair: boolean;
    autoUpgrade: boolean;
}

export interface GetClusterGkeConfigV2PrivateClusterConfig {
    enablePrivateEndpoint: boolean;
    enablePrivateNodes: boolean;
    masterIpv4CidrBlock: string;
}

export interface GetClusterK3sConfig {
    upgradeStrategies: outputs.GetClusterK3sConfigUpgradeStrategy[];
    version: string;
}

export interface GetClusterK3sConfigUpgradeStrategy {
    drainServerNodes: boolean;
    drainWorkerNodes: boolean;
    serverConcurrency: number;
    workerConcurrency: number;
}

export interface GetClusterOkeConfig {
    compartmentId: string;
    customBootVolumeSize: number;
    description: string;
    enableKubernetesDashboard: boolean;
    enablePrivateControlPlane: boolean;
    enablePrivateNodes: boolean;
    fingerprint: string;
    flexOcpus: number;
    kmsKeyId: string;
    kubernetesVersion: string;
    limitNodeCount: number;
    loadBalancerSubnetName1: string;
    loadBalancerSubnetName2: string;
    nodeImage: string;
    nodePoolDnsDomainName: string;
    nodePoolSubnetName: string;
    nodePublicKeyContents: string;
    nodeShape: string;
    podCidr: string;
    privateKeyContents: string;
    privateKeyPassphrase: string;
    quantityOfNodeSubnets: number;
    quantityPerSubnet: number;
    region: string;
    serviceCidr: string;
    serviceDnsDomainName: string;
    skipVcnDelete: boolean;
    tenancyId: string;
    userOcid: string;
    vcnCompartmentId: string;
    vcnName: string;
    workerNodeIngressCidr: string;
}

export interface GetClusterRke2Config {
    upgradeStrategies: outputs.GetClusterRke2ConfigUpgradeStrategy[];
    version: string;
}

export interface GetClusterRke2ConfigUpgradeStrategy {
    drainServerNodes: boolean;
    drainWorkerNodes: boolean;
    serverConcurrency: number;
    workerConcurrency: number;
}

export interface GetClusterRkeConfig {
    addonJobTimeout: number;
    addons: string;
    addonsIncludes: string[];
    authentications: outputs.GetClusterRkeConfigAuthentication[];
    authorizations: outputs.GetClusterRkeConfigAuthorization[];
    bastionHosts: outputs.GetClusterRkeConfigBastionHost[];
    cloudProviders: outputs.GetClusterRkeConfigCloudProvider[];
    dns: outputs.GetClusterRkeConfigDn[];
    enableCriDockerd: boolean;
    ignoreDockerVersion: boolean;
    ingresses: outputs.GetClusterRkeConfigIngress[];
    kubernetesVersion: string;
    monitorings: outputs.GetClusterRkeConfigMonitoring[];
    networks: outputs.GetClusterRkeConfigNetwork[];
    nodes: outputs.GetClusterRkeConfigNode[];
    prefixPath: string;
    privateRegistries: outputs.GetClusterRkeConfigPrivateRegistry[];
    services: outputs.GetClusterRkeConfigService[];
    sshAgentAuth: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategies: outputs.GetClusterRkeConfigUpgradeStrategy[];
    winPrefixPath: string;
}

export interface GetClusterRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface GetClusterRkeConfigAuthorization {
    mode: string;
    options: {[key: string]: string};
}

export interface GetClusterRkeConfigBastionHost {
    address: string;
    port: string;
    sshAgentAuth: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterRkeConfigCloudProvider {
    awsCloudProviders: outputs.GetClusterRkeConfigCloudProviderAwsCloudProvider[];
    azureCloudProviders: outputs.GetClusterRkeConfigCloudProviderAzureCloudProvider[];
    customCloudProvider: string;
    name: string;
    openstackCloudProviders: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProvider[];
    vsphereCloudProviders: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProvider[];
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProvider {
    globals: outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderGlobal[];
    serviceOverrides: outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress: boolean;
    disableStrictZoneCheck: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface GetClusterRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorages: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage[];
    globals: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal[];
    loadBalancers: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer[];
    metadatas: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata[];
    routes: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderRoute[];
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay: string;
    monitorMaxRetries: number;
    monitorTimeout: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProvider {
    disks: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderDisk[];
    globals: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobal[];
    networks: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderNetwork[];
    virtualCenters: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspaces: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace[];
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    gracefulShutdownTimeout: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface GetClusterRkeConfigDn {
    linearAutoscalerParams: outputs.GetClusterRkeConfigDnLinearAutoscalerParam[];
    nodeSelector: {[key: string]: string};
    nodelocals: outputs.GetClusterRkeConfigDnNodelocal[];
    options: {[key: string]: string};
    provider: string;
    reverseCidrs: string[];
    tolerations: outputs.GetClusterRkeConfigDnToleration[];
    updateStrategies: outputs.GetClusterRkeConfigDnUpdateStrategy[];
    upstreamNameservers: string[];
}

export interface GetClusterRkeConfigDnLinearAutoscalerParam {
    coresPerReplica: number;
    max: number;
    min: number;
    nodesPerReplica: number;
    preventSinglePointFailure: boolean;
}

export interface GetClusterRkeConfigDnNodelocal {
    ipAddress: string;
    nodeSelector: {[key: string]: string};
}

export interface GetClusterRkeConfigDnToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterRkeConfigDnUpdateStrategy {
    rollingUpdates: outputs.GetClusterRkeConfigDnUpdateStrategyRollingUpdate[];
    strategy: string;
}

export interface GetClusterRkeConfigDnUpdateStrategyRollingUpdate {
    maxSurge: number;
    maxUnavailable: number;
}

export interface GetClusterRkeConfigIngress {
    defaultBackend: boolean;
    dnsPolicy: string;
    extraArgs: {[key: string]: string};
    httpPort: number;
    httpsPort: number;
    networkMode: string;
    nodeSelector: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    tolerations: outputs.GetClusterRkeConfigIngressToleration[];
    updateStrategies: outputs.GetClusterRkeConfigIngressUpdateStrategy[];
}

export interface GetClusterRkeConfigIngressToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterRkeConfigIngressUpdateStrategy {
    rollingUpdates: outputs.GetClusterRkeConfigIngressUpdateStrategyRollingUpdate[];
    strategy: string;
}

export interface GetClusterRkeConfigIngressUpdateStrategyRollingUpdate {
    maxUnavailable: number;
}

export interface GetClusterRkeConfigMonitoring {
    nodeSelector: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    replicas: number;
    tolerations: outputs.GetClusterRkeConfigMonitoringToleration[];
    updateStrategies: outputs.GetClusterRkeConfigMonitoringUpdateStrategy[];
}

export interface GetClusterRkeConfigMonitoringToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterRkeConfigMonitoringUpdateStrategy {
    rollingUpdates: outputs.GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdate[];
    strategy: string;
}

export interface GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge: number;
    maxUnavailable: number;
}

export interface GetClusterRkeConfigNetwork {
    aciNetworkProviders: outputs.GetClusterRkeConfigNetworkAciNetworkProvider[];
    calicoNetworkProviders: outputs.GetClusterRkeConfigNetworkCalicoNetworkProvider[];
    canalNetworkProviders: outputs.GetClusterRkeConfigNetworkCanalNetworkProvider[];
    flannelNetworkProviders: outputs.GetClusterRkeConfigNetworkFlannelNetworkProvider[];
    mtu: number;
    options: {[key: string]: string};
    plugin: string;
    tolerations: outputs.GetClusterRkeConfigNetworkToleration[];
    weaveNetworkProviders: outputs.GetClusterRkeConfigNetworkWeaveNetworkProvider[];
}

export interface GetClusterRkeConfigNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicRefreshTickerAdjust: string;
    apicRefreshTime: string;
    apicSubscriptionDelay: string;
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    capic: string;
    controllerLogLevel: string;
    disablePeriodicSnatGlobalInfoSync: string;
    disableWaitForNetwork: string;
    dropLogEnable: string;
    durationWaitForNetwork: string;
    enableEndpointSlice: string;
    encapType: string;
    epRegistry: string;
    externDynamic: string;
    externStatic: string;
    gbpPodSubnet: string;
    hostAgentLogLevel: string;
    imagePullPolicy: string;
    imagePullSecret: string;
    infraVlan: string;
    installIstio: string;
    istioProfile: string;
    kafkaBrokers: string[];
    kafkaClientCrt: string;
    kafkaClientKey: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    maxNodesSvcGraph: string;
    mcastRangeEnd: string;
    mcastRangeStart: string;
    mtuHeadRoom: string;
    multusDisable: string;
    noPriorityClass: string;
    nodePodIfEnable: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    opflexClientSsl: string;
    opflexDeviceDeleteTimeout: string;
    opflexLogLevel: string;
    opflexMode: string;
    opflexServerPort: string;
    overlayVrfName: string;
    ovsMemoryLimit: string;
    pbrTrackingNonSnat: string;
    podSubnetChunkSize: string;
    runGbpContainer: string;
    runOpflexServerContainer: string;
    serviceMonitorInterval: string;
    serviceVlan: string;
    snatContractScope: string;
    snatNamespace: string;
    snatPortRangeEnd: string;
    snatPortRangeStart: string;
    snatPortsPerNode: string;
    sriovEnable: string;
    subnetDomainName: string;
    systemId: string;
    tenant: string;
    token: string;
    useAciAnywhereCrd: string;
    useAciCniPriorityClass: string;
    useClusterRole: string;
    useHostNetnsVolume: string;
    useOpflexServerVolume: string;
    usePrivilegedContainer: string;
    vmmController: string;
    vmmDomain: string;
    vrfName: string;
    vrfTenant: string;
}

export interface GetClusterRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface GetClusterRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface GetClusterRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface GetClusterRkeConfigNetworkToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface GetClusterRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride: string;
    internalAddress: string;
    labels: {[key: string]: string};
    nodeId: string;
    port: string;
    roles: string[];
    sshAgentAuth: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterRkeConfigPrivateRegistry {
    ecrCredentialPlugins: outputs.GetClusterRkeConfigPrivateRegistryEcrCredentialPlugin[];
    isDefault: boolean;
    password: string;
    url: string;
    user: string;
}

export interface GetClusterRkeConfigPrivateRegistryEcrCredentialPlugin {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    awsSessionToken: string;
}

export interface GetClusterRkeConfigService {
    etcds: outputs.GetClusterRkeConfigServiceEtcd[];
    kubeApis: outputs.GetClusterRkeConfigServiceKubeApi[];
    kubeControllers: outputs.GetClusterRkeConfigServiceKubeController[];
    kubelets: outputs.GetClusterRkeConfigServiceKubelet[];
    kubeproxies: outputs.GetClusterRkeConfigServiceKubeproxy[];
    schedulers: outputs.GetClusterRkeConfigServiceScheduler[];
}

export interface GetClusterRkeConfigServiceEtcd {
    backupConfigs: outputs.GetClusterRkeConfigServiceEtcdBackupConfig[];
    caCert: string;
    cert: string;
    creation: string;
    externalUrls: string[];
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    gid: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid: number;
}

export interface GetClusterRkeConfigServiceEtcdBackupConfig {
    enabled: boolean;
    intervalHours: number;
    retention: number;
    s3BackupConfigs: outputs.GetClusterRkeConfigServiceEtcdBackupConfigS3BackupConfig[];
    safeTimestamp: boolean;
    timeout: number;
}

export interface GetClusterRkeConfigServiceEtcdBackupConfigS3BackupConfig {
    accessKey: string;
    bucketName: string;
    customCa: string;
    endpoint: string;
    folder: string;
    region: string;
    secretKey: string;
}

export interface GetClusterRkeConfigServiceKubeApi {
    admissionConfigurations: outputs.GetClusterRkeConfigServiceKubeApiAdmissionConfiguration[];
    alwaysPullImages: boolean;
    auditLogs: outputs.GetClusterRkeConfigServiceKubeApiAuditLog[];
    eventRateLimits: outputs.GetClusterRkeConfigServiceKubeApiEventRateLimit[];
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
    secretsEncryptionConfigs: outputs.GetClusterRkeConfigServiceKubeApiSecretsEncryptionConfig[];
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface GetClusterRkeConfigServiceKubeApiAdmissionConfiguration {
    apiVersion: string;
    kind: string;
    plugins: outputs.GetClusterRkeConfigServiceKubeApiAdmissionConfigurationPlugin[];
}

export interface GetClusterRkeConfigServiceKubeApiAdmissionConfigurationPlugin {
    configuration: string;
    name: string;
    path: string;
}

export interface GetClusterRkeConfigServiceKubeApiAuditLog {
    configurations: outputs.GetClusterRkeConfigServiceKubeApiAuditLogConfiguration[];
    enabled: boolean;
}

export interface GetClusterRkeConfigServiceKubeApiAuditLogConfiguration {
    format: string;
    maxAge: number;
    maxBackup: number;
    maxSize: number;
    path: string;
    policy: string;
}

export interface GetClusterRkeConfigServiceKubeApiEventRateLimit {
    configuration: string;
    enabled: boolean;
}

export interface GetClusterRkeConfigServiceKubeApiSecretsEncryptionConfig {
    customConfig: string;
    enabled: boolean;
}

export interface GetClusterRkeConfigServiceKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface GetClusterRkeConfigServiceKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    failSwapOn: boolean;
    generateServingCertificate: boolean;
    image: string;
    infraContainerImage: string;
}

export interface GetClusterRkeConfigServiceKubeproxy {
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
}

export interface GetClusterRkeConfigServiceScheduler {
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
}

export interface GetClusterRkeConfigUpgradeStrategy {
    drain: boolean;
    drainInputs: outputs.GetClusterRkeConfigUpgradeStrategyDrainInput[];
    maxUnavailableControlplane: string;
    maxUnavailableWorker: string;
}

export interface GetClusterRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData: boolean;
    force: boolean;
    gracePeriod: number;
    ignoreDaemonSets: boolean;
    timeout: number;
}

export interface GetClusterTemplateMember {
    accessType: string;
    groupPrincipalId: string;
    userPrincipalId: string;
}

export interface GetClusterTemplateTemplateRevision {
    annotations: {[key: string]: string};
    clusterConfigs: outputs.GetClusterTemplateTemplateRevisionClusterConfig[];
    clusterTemplateId: string;
    default: boolean;
    enabled: boolean;
    id: string;
    labels: {[key: string]: string};
    name: string;
    questions: outputs.GetClusterTemplateTemplateRevisionQuestion[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfig {
    clusterAuthEndpoints: outputs.GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint[];
    defaultClusterRoleForProjectMembers: string;
    defaultPodSecurityAdmissionConfigurationTemplateName: string;
    desiredAgentImage: string;
    desiredAuthImage: string;
    dockerRootDir: string;
    enableNetworkPolicy: boolean;
    rkeConfigs: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfig[];
    windowsPreferedCluster: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint {
    caCerts: string;
    enabled: boolean;
    fqdn: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfig {
    addonJobTimeout: number;
    addons: string;
    addonsIncludes: string[];
    authentications: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication[];
    authorizations: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization[];
    bastionHosts: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost[];
    cloudProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider[];
    dns: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDn[];
    enableCriDockerd: boolean;
    ignoreDockerVersion: boolean;
    ingresses: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress[];
    kubernetesVersion: string;
    monitorings: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring[];
    networks: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork[];
    nodes: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNode[];
    prefixPath: string;
    privateRegistries: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry[];
    services: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigService[];
    sshAgentAuth: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategies: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy[];
    winPrefixPath: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization {
    mode: string;
    options: {[key: string]: string};
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost {
    address: string;
    port: string;
    sshAgentAuth: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider {
    awsCloudProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider[];
    azureCloudProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider[];
    customCloudProvider: string;
    name: string;
    openstackCloudProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider[];
    vsphereCloudProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider {
    globals: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal[];
    serviceOverrides: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress: boolean;
    disableStrictZoneCheck: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorages: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage[];
    globals: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal[];
    loadBalancers: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer[];
    metadatas: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata[];
    routes: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay: string;
    monitorMaxRetries: number;
    monitorTimeout: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider {
    disks: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk[];
    globals: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal[];
    networks: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork[];
    virtualCenters: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspaces: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    gracefulShutdownTimeout: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDn {
    linearAutoscalerParams: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnLinearAutoscalerParam[];
    nodeSelector: {[key: string]: string};
    nodelocals: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnNodelocal[];
    options: {[key: string]: string};
    provider: string;
    reverseCidrs: string[];
    tolerations: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnToleration[];
    updateStrategies: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnUpdateStrategy[];
    upstreamNameservers: string[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnLinearAutoscalerParam {
    coresPerReplica: number;
    max: number;
    min: number;
    nodesPerReplica: number;
    preventSinglePointFailure: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnNodelocal {
    ipAddress: string;
    nodeSelector: {[key: string]: string};
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnUpdateStrategy {
    rollingUpdates: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnUpdateStrategyRollingUpdate[];
    strategy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnUpdateStrategyRollingUpdate {
    maxSurge: number;
    maxUnavailable: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress {
    defaultBackend: boolean;
    dnsPolicy: string;
    extraArgs: {[key: string]: string};
    httpPort: number;
    httpsPort: number;
    networkMode: string;
    nodeSelector: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    tolerations: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration[];
    updateStrategies: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy {
    rollingUpdates: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate[];
    strategy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate {
    maxUnavailable: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring {
    nodeSelector: {[key: string]: string};
    options: {[key: string]: string};
    provider: string;
    replicas: number;
    tolerations: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration[];
    updateStrategies: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy {
    rollingUpdates: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate[];
    strategy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge: number;
    maxUnavailable: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork {
    aciNetworkProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider[];
    calicoNetworkProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider[];
    canalNetworkProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider[];
    flannelNetworkProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider[];
    mtu: number;
    options: {[key: string]: string};
    plugin: string;
    tolerations: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration[];
    weaveNetworkProviders: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicRefreshTickerAdjust: string;
    apicRefreshTime: string;
    apicSubscriptionDelay: string;
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    capic: string;
    controllerLogLevel: string;
    disablePeriodicSnatGlobalInfoSync: string;
    disableWaitForNetwork: string;
    dropLogEnable: string;
    durationWaitForNetwork: string;
    enableEndpointSlice: string;
    encapType: string;
    epRegistry: string;
    externDynamic: string;
    externStatic: string;
    gbpPodSubnet: string;
    hostAgentLogLevel: string;
    imagePullPolicy: string;
    imagePullSecret: string;
    infraVlan: string;
    installIstio: string;
    istioProfile: string;
    kafkaBrokers: string[];
    kafkaClientCrt: string;
    kafkaClientKey: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    maxNodesSvcGraph: string;
    mcastRangeEnd: string;
    mcastRangeStart: string;
    mtuHeadRoom: string;
    multusDisable: string;
    noPriorityClass: string;
    nodePodIfEnable: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    opflexClientSsl: string;
    opflexDeviceDeleteTimeout: string;
    opflexLogLevel: string;
    opflexMode: string;
    opflexServerPort: string;
    overlayVrfName: string;
    ovsMemoryLimit: string;
    pbrTrackingNonSnat: string;
    podSubnetChunkSize: string;
    runGbpContainer: string;
    runOpflexServerContainer: string;
    serviceMonitorInterval: string;
    serviceVlan: string;
    snatContractScope: string;
    snatNamespace: string;
    snatPortRangeEnd: string;
    snatPortRangeStart: string;
    snatPortsPerNode: string;
    sriovEnable: string;
    subnetDomainName: string;
    systemId: string;
    tenant: string;
    token: string;
    useAciAnywhereCrd: string;
    useAciCniPriorityClass: string;
    useClusterRole: string;
    useHostNetnsVolume: string;
    useOpflexServerVolume: string;
    usePrivilegedContainer: string;
    vmmController: string;
    vmmDomain: string;
    vrfName: string;
    vrfTenant: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration {
    effect: string;
    key: string;
    operator: string;
    seconds: number;
    value: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride: string;
    internalAddress: string;
    labels: {[key: string]: string};
    nodeId: string;
    port: string;
    roles: string[];
    sshAgentAuth: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry {
    ecrCredentialPlugins: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin[];
    isDefault: boolean;
    password: string;
    url: string;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin {
    awsAccessKeyId: string;
    awsSecretAccessKey: string;
    awsSessionToken: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigService {
    etcds: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceEtcd[];
    kubeApis: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApi[];
    kubeControllers: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeController[];
    kubelets: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubelet[];
    kubeproxies: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeproxy[];
    schedulers: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceScheduler[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceEtcd {
    backupConfigs: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceEtcdBackupConfig[];
    caCert: string;
    cert: string;
    creation: string;
    externalUrls: string[];
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    gid: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceEtcdBackupConfig {
    enabled: boolean;
    intervalHours: number;
    retention: number;
    s3BackupConfigs: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceEtcdBackupConfigS3BackupConfig[];
    safeTimestamp: boolean;
    timeout: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceEtcdBackupConfigS3BackupConfig {
    accessKey: string;
    bucketName: string;
    customCa: string;
    endpoint: string;
    folder: string;
    region: string;
    secretKey: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApi {
    admissionConfigurations: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAdmissionConfiguration[];
    alwaysPullImages: boolean;
    auditLogs: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAuditLog[];
    eventRateLimits: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiEventRateLimit[];
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
    secretsEncryptionConfigs: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiSecretsEncryptionConfig[];
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAdmissionConfiguration {
    apiVersion: string;
    kind: string;
    plugins: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAdmissionConfigurationPlugin[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAdmissionConfigurationPlugin {
    configuration: string;
    name: string;
    path: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAuditLog {
    configurations: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAuditLogConfiguration[];
    enabled: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiAuditLogConfiguration {
    format: string;
    maxAge: number;
    maxBackup: number;
    maxSize: number;
    path: string;
    policy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiEventRateLimit {
    configuration: string;
    enabled: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeApiSecretsEncryptionConfig {
    customConfig: string;
    enabled: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    failSwapOn: boolean;
    generateServingCertificate: boolean;
    image: string;
    infraContainerImage: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceKubeproxy {
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServiceScheduler {
    extraArgs: {[key: string]: string};
    extraBinds: string[];
    extraEnvs: string[];
    image: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy {
    drain: boolean;
    drainInputs: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput[];
    maxUnavailableControlplane: string;
    maxUnavailableWorker: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData: boolean;
    force: boolean;
    gracePeriod: number;
    ignoreDaemonSets: boolean;
    timeout: number;
}

export interface GetClusterTemplateTemplateRevisionQuestion {
    default: string;
    required: boolean;
    type: string;
    variable: string;
}

export interface GetClusterV2AgentEnvVar {
    name: string;
    value: string;
}

export interface GetClusterV2ClusterRegistrationToken {
    annotations: {[key: string]: string};
    clusterId: string;
    command: string;
    id: string;
    insecureCommand: string;
    insecureNodeCommand: string;
    insecureWindowsNodeCommand: string;
    labels: {[key: string]: string};
    manifestUrl: string;
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface GetClusterV2RkeConfig {
    additionalManifest: string;
    chartValues: string;
    etcdSnapshotCreates: outputs.GetClusterV2RkeConfigEtcdSnapshotCreate[];
    etcdSnapshotRestores: outputs.GetClusterV2RkeConfigEtcdSnapshotRestore[];
    etcds: outputs.GetClusterV2RkeConfigEtcd[];
    localAuthEndpoints: outputs.GetClusterV2RkeConfigLocalAuthEndpoint[];
    machineGlobalConfig: string;
    machinePoolDefaults: outputs.GetClusterV2RkeConfigMachinePoolDefault[];
    machinePools: outputs.GetClusterV2RkeConfigMachinePool[];
    machineSelectorConfigs: outputs.GetClusterV2RkeConfigMachineSelectorConfig[];
    machineSelectorFiles: outputs.GetClusterV2RkeConfigMachineSelectorFile[];
    registries: outputs.GetClusterV2RkeConfigRegistry[];
    rotateCertificates: outputs.GetClusterV2RkeConfigRotateCertificate[];
    upgradeStrategies: outputs.GetClusterV2RkeConfigUpgradeStrategy[];
}

export interface GetClusterV2RkeConfigEtcd {
    disableSnapshots: boolean;
    s3Configs: outputs.GetClusterV2RkeConfigEtcdS3Config[];
    snapshotRetention: number;
    snapshotScheduleCron: string;
}

export interface GetClusterV2RkeConfigEtcdS3Config {
    bucket: string;
    cloudCredentialName: string;
    endpoint: string;
    endpointCa: string;
    folder: string;
    region: string;
    skipSslVerify: boolean;
}

export interface GetClusterV2RkeConfigEtcdSnapshotCreate {
    generation: number;
}

export interface GetClusterV2RkeConfigEtcdSnapshotRestore {
    generation: number;
    name: string;
    restoreRkeConfig: string;
}

export interface GetClusterV2RkeConfigLocalAuthEndpoint {
    caCerts: string;
    enabled: boolean;
    fqdn: string;
}

export interface GetClusterV2RkeConfigMachinePool {
    annotations: {[key: string]: string};
    cloudCredentialSecretName: string;
    controlPlaneRole: boolean;
    drainBeforeDelete: boolean;
    etcdRole: boolean;
    hostnameLengthLimit: number;
    labels: {[key: string]: string};
    machineConfigs: outputs.GetClusterV2RkeConfigMachinePoolMachineConfig[];
    machineLabels: {[key: string]: string};
    maxUnhealthy: string;
    name: string;
    nodeDrainTimeout: number;
    nodeStartupTimeoutSeconds: number;
    paused: boolean;
    quantity: number;
    rollingUpdates: outputs.GetClusterV2RkeConfigMachinePoolRollingUpdate[];
    taints: outputs.GetClusterV2RkeConfigMachinePoolTaint[];
    unhealthyNodeTimeoutSeconds: number;
    unhealthyRange: string;
    workerRole: boolean;
}

export interface GetClusterV2RkeConfigMachinePoolDefault {
    hostnameLengthLimit: number;
}

export interface GetClusterV2RkeConfigMachinePoolMachineConfig {
    apiVersion: string;
    kind: string;
    name: string;
}

export interface GetClusterV2RkeConfigMachinePoolRollingUpdate {
    maxSurge: string;
    maxUnavailable: string;
}

export interface GetClusterV2RkeConfigMachinePoolTaint {
    effect: string;
    key: string;
    value: string;
}

export interface GetClusterV2RkeConfigMachineSelectorConfig {
    config: string;
    machineLabelSelectors: outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector[];
}

export interface GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector {
    matchExpressions: outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterV2RkeConfigMachineSelectorFile {
    fileSources: outputs.GetClusterV2RkeConfigMachineSelectorFileFileSource[];
    machineLabelSelectors: outputs.GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelector[];
}

export interface GetClusterV2RkeConfigMachineSelectorFileFileSource {
    configmaps: outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap[];
    secrets: outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceSecret[];
}

export interface GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap {
    defaultPermissions: string;
    items: outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem[];
    name: string;
}

export interface GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem {
    dynamic: boolean;
    hash: string;
    key: string;
    path: string;
    permissions: string;
}

export interface GetClusterV2RkeConfigMachineSelectorFileFileSourceSecret {
    defaultPermissions: string;
    items: outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem[];
    name: string;
}

export interface GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem {
    dynamic: boolean;
    hash: string;
    key: string;
    path: string;
    permissions: string;
}

export interface GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelector {
    matchExpressions: outputs.GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterV2RkeConfigRegistry {
    configs: outputs.GetClusterV2RkeConfigRegistryConfig[];
    mirrors: outputs.GetClusterV2RkeConfigRegistryMirror[];
}

export interface GetClusterV2RkeConfigRegistryConfig {
    authConfigSecretName: string;
    caBundle: string;
    hostname: string;
    insecure: boolean;
    tlsSecretName: string;
}

export interface GetClusterV2RkeConfigRegistryMirror {
    endpoints: string[];
    hostname: string;
    rewrites: {[key: string]: string};
}

export interface GetClusterV2RkeConfigRotateCertificate {
    generation: number;
    services: string[];
}

export interface GetClusterV2RkeConfigUpgradeStrategy {
    controlPlaneConcurrency: string;
    controlPlaneDrainOptions: outputs.GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOption[];
    workerConcurrency: string;
    workerDrainOptions: outputs.GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOption[];
}

export interface GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOption {
    deleteEmptyDirData: boolean;
    disableEviction: boolean;
    enabled: boolean;
    force: boolean;
    gracePeriod: number;
    ignoreDaemonSets: boolean;
    ignoreErrors: boolean;
    skipWaitForDeleteTimeoutSeconds: number;
    timeout: number;
}

export interface GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOption {
    deleteEmptyDirData: boolean;
    disableEviction: boolean;
    enabled: boolean;
    force: boolean;
    gracePeriod: number;
    ignoreDaemonSets: boolean;
    ignoreErrors: boolean;
    skipWaitForDeleteTimeoutSeconds: number;
    timeout: number;
}

export interface GetEtcdBackupBackupConfig {
    enabled: boolean;
    intervalHours: number;
    retention: number;
    s3BackupConfigs: outputs.GetEtcdBackupBackupConfigS3BackupConfig[];
    safeTimestamp: boolean;
    timeout: number;
}

export interface GetEtcdBackupBackupConfigS3BackupConfig {
    accessKey: string;
    bucketName: string;
    customCa: string;
    endpoint: string;
    folder: string;
    region: string;
    secretKey: string;
}

export interface GetGlobalDnsProviderAlidnsConfig {
    accessKey: string;
    secretKey: string;
}

export interface GetGlobalDnsProviderCloudflareConfig {
    apiEmail: string;
    apiKey: string;
    proxySetting: boolean;
}

export interface GetGlobalDnsProviderRoute53Config {
    accessKey: string;
    credentialsPath: string;
    region: string;
    roleArn: string;
    secretKey: string;
    zoneType: string;
}

export interface GetGlobalRoleRule {
    apiGroups: string[];
    nonResourceUrls: string[];
    resourceNames: string[];
    resources: string[];
    verbs: string[];
}

export interface GetMultiClusterAppAnswer {
    clusterId: string;
    projectId: string;
    values: {[key: string]: string};
}

export interface GetMultiClusterAppMember {
    accessType: string;
    groupPrincipalId: string;
    userPrincipalId: string;
}

export interface GetMultiClusterAppTarget {
    appId: string;
    healthState: string;
    projectId: string;
    state: string;
}

export interface GetMultiClusterAppUpgradeStrategy {
    rollingUpdates: outputs.GetMultiClusterAppUpgradeStrategyRollingUpdate[];
}

export interface GetMultiClusterAppUpgradeStrategyRollingUpdate {
    batchSize: number;
    interval: number;
}

export interface GetNamespaceContainerResourceLimit {
    limitsCpu: string;
    limitsMemory: string;
    requestsCpu: string;
    requestsMemory: string;
}

export interface GetNamespaceResourceQuota {
    limits: outputs.GetNamespaceResourceQuotaLimit[];
}

export interface GetNamespaceResourceQuotaLimit {
    configMaps: string;
    limitsCpu: string;
    limitsMemory: string;
    persistentVolumeClaims: string;
    pods: string;
    replicationControllers: string;
    requestsCpu: string;
    requestsMemory: string;
    requestsStorage: string;
    secrets: string;
    services: string;
    servicesLoadBalancers: string;
    servicesNodePorts: string;
}

export interface GetNodePoolNodeTaint {
    effect: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface GetNodeTemplateNodeTaint {
    effect: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface GetPodSecurityAdmissionConfigurationTemplateDefault {
    audit: string;
    auditVersion: string;
    enforce: string;
    enforceVersion: string;
    warn: string;
    warnVersion: string;
}

export interface GetPodSecurityAdmissionConfigurationTemplateExemption {
    namespaces: string[];
    runtimeClasses: string[];
    usernames: string[];
}

export interface GetProjectContainerResourceLimit {
    limitsCpu: string;
    limitsMemory: string;
    requestsCpu: string;
    requestsMemory: string;
}

export interface GetProjectResourceQuota {
    namespaceDefaultLimits: outputs.GetProjectResourceQuotaNamespaceDefaultLimit[];
    projectLimits: outputs.GetProjectResourceQuotaProjectLimit[];
}

export interface GetProjectResourceQuotaNamespaceDefaultLimit {
    configMaps: string;
    limitsCpu: string;
    limitsMemory: string;
    persistentVolumeClaims: string;
    pods: string;
    replicationControllers: string;
    requestsCpu: string;
    requestsMemory: string;
    requestsStorage: string;
    secrets: string;
    services: string;
    servicesLoadBalancers: string;
    servicesNodePorts: string;
}

export interface GetProjectResourceQuotaProjectLimit {
    configMaps: string;
    limitsCpu: string;
    limitsMemory: string;
    persistentVolumeClaims: string;
    pods: string;
    replicationControllers: string;
    requestsCpu: string;
    requestsMemory: string;
    requestsStorage: string;
    secrets: string;
    services: string;
    servicesLoadBalancers: string;
    servicesNodePorts: string;
}

export interface GetRegistryRegistry {
    address: string;
    password: string;
    username: string;
}

export interface GetRoleTemplateExternalRule {
    /**
     * Policy rule api groups
     */
    apiGroups?: string[];
    /**
     * Policy rule non resource urls
     */
    nonResourceUrls?: string[];
    /**
     * Policy rule resource names
     */
    resourceNames?: string[];
    /**
     * Policy rule resources
     */
    resources?: string[];
    /**
     * Policy rule verbs
     */
    verbs?: string[];
}

export interface GetRoleTemplateRule {
    apiGroups: string[];
    nonResourceUrls: string[];
    resourceNames: string[];
    resources: string[];
    verbs: string[];
}

export interface GlobalDnsProviderAlidnsConfig {
    accessKey: string;
    secretKey: string;
}

export interface GlobalDnsProviderCloudflareConfig {
    apiEmail: string;
    apiKey: string;
    proxySetting?: boolean;
}

export interface GlobalDnsProviderRoute53Config {
    accessKey: string;
    credentialsPath?: string;
    region?: string;
    roleArn?: string;
    secretKey: string;
    zoneType?: string;
}

export interface GlobalDnsProviderTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GlobalDnsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GlobalRoleBindingTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GlobalRoleRule {
    /**
     * Policy rule api groups
     */
    apiGroups?: string[];
    /**
     * Policy rule non resource urls
     */
    nonResourceUrls?: string[];
    /**
     * Policy rule resource names
     */
    resourceNames?: string[];
    /**
     * Policy rule resources
     */
    resources?: string[];
    /**
     * Policy rule verbs
     */
    verbs?: string[];
}

export interface GlobalRoleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MachineConfigV2Amazonec2Config {
    /**
     * AWS Access Key
     */
    accessKey?: string;
    /**
     * AWS machine image
     */
    ami: string;
    /**
     * AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
     */
    blockDurationMinutes?: string;
    /**
     * AWS root device name
     */
    deviceName?: string;
    /**
     * Encrypt EBS volume
     */
    encryptEbsVolume?: boolean;
    /**
     * Optional endpoint URL (hostname only or fully qualified URI)
     */
    endpoint?: string;
    /**
     * Enables or disables the HTTP metadata endpoint on your instances
     */
    httpEndpoint?: string;
    /**
     * The state of token usage for your instance metadata requests
     */
    httpTokens?: string;
    /**
     * AWS IAM Instance Profile
     */
    iamInstanceProfile?: string;
    /**
     * Disable SSL when sending requests
     */
    insecureTransport?: boolean;
    /**
     * AWS instance type
     */
    instanceType?: string;
    /**
     * Custom KMS key ID using the AWS Managed CMK
     */
    kmsKey?: string;
    /**
     * Set this flag to enable CloudWatch monitoring
     */
    monitoring?: boolean;
    /**
     * Make the specified port number accessible from the Internet
     */
    openPorts?: string[];
    /**
     * Only use a private IP address
     */
    privateAddressOnly?: boolean;
    /**
     * AWS Region
     */
    region: string;
    /**
     * Set this flag to request spot instance
     */
    requestSpotInstance?: boolean;
    /**
     * Set retry count for recoverable failures (use -1 to disable)
     */
    retries?: string;
    /**
     * AWS root disk size (in GB)
     */
    rootSize?: string;
    /**
     * AWS Secret Key
     */
    secretKey?: string;
    /**
     * Skip adding default rules to security groups
     */
    securityGroupReadonly?: boolean;
    /**
     * AWS VPC security group
     */
    securityGroups: string[];
    /**
     * AWS Session Token
     */
    sessionToken?: string;
    /**
     * AWS spot instance bid price (in dollar)
     */
    spotPrice?: string;
    /**
     * SSH Key file contents for sshKeyContents
     */
    sshKeyContents?: string;
    /**
     * Set the name of the ssh user
     */
    sshUser?: string;
    /**
     * AWS VPC subnet id
     */
    subnetId: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2)
     */
    tags?: string;
    /**
     * Create an EBS optimized instance
     */
    useEbsOptimizedInstance?: boolean;
    /**
     * Force the usage of private IP address
     */
    usePrivateAddress?: boolean;
    /**
     * Path to file with cloud-init user data
     */
    userdata?: string;
    /**
     * Amazon EBS volume type
     */
    volumeType?: string;
    /**
     * AWS VPC id
     */
    vpcId: string;
    /**
     * AWS zone for instance (i.e. a,b,c,d,e)
     */
    zone: string;
}

export interface MachineConfigV2AzureConfig {
    /**
     * Use Accelerated Networking when creating a network interface for the Azure VM
     */
    acceleratedNetworking?: boolean;
    /**
     * Azure Availability Set to place the virtual machine into
     */
    availabilitySet?: string;
    /**
     * The Availability Zone that the Azure VM should be created in
     */
    availabilityZone?: string;
    /**
     * Azure Service Principal Account ID (optional, browser auth is used if not specified)
     */
    clientId?: string;
    /**
     * Azure Service Principal Account password (optional, browser auth is used if not specified)
     */
    clientSecret?: string;
    /**
     * Path to file with custom-data
     */
    customData?: string;
    /**
     * Disk size if using managed disk
     */
    diskSize?: string;
    /**
     * A unique DNS label for the public IP adddress
     */
    dns?: string;
    /**
     * Port number for Docker engine
     */
    dockerPort?: string;
    /**
     * Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
     */
    environment?: string;
    /**
     * Fault domain count to use for availability set
     */
    faultDomainCount?: string;
    /**
     * Azure virtual machine OS image
     */
    image?: string;
    /**
     * Azure region to create the virtual machine
     */
    location?: string;
    /**
     * Configures VM and availability set for managed disks
     */
    managedDisks?: boolean;
    /**
     * Do not create a public IP address for the machine
     */
    noPublicIp?: boolean;
    /**
     * Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
     */
    nsg?: string;
    /**
     * Make the specified port number accessible from the Internet
     */
    openPorts?: string[];
    /**
     * Only use a private IP address
     */
    privateAddressOnly?: boolean;
    /**
     * Specify a static private IP address for the machine
     */
    privateIpAddress?: string;
    /**
     * Azure Resource Group name (will be created if missing)
     */
    resourceGroup?: string;
    /**
     * Size for Azure Virtual Machine
     */
    size?: string;
    /**
     * Username for SSH login
     */
    sshUser?: string;
    /**
     * Assign a static public IP address to the machine
     */
    staticPublicIp?: boolean;
    /**
     * Type of Storage Account to host the OS Disk for the machine
     */
    storageType?: string;
    /**
     * Azure Subnet Name to be used within the Virtual Network
     */
    subnet?: string;
    /**
     * Private CIDR block to be used for the new subnet, should comply RFC 1918
     */
    subnetPrefix?: string;
    /**
     * Azure Subscription ID
     */
    subscriptionId?: string;
    /**
     * Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
     */
    tags?: string;
    /**
     * Azure Tenant ID
     */
    tenantId?: string;
    /**
     * Update domain count to use for availability set
     */
    updateDomainCount?: string;
    /**
     * Use private IP address of the machine to connect
     */
    usePrivateIp?: boolean;
    /**
     * Use the standard SKU when creating a Public IP for the Azure VM instance
     */
    usePublicIpStandardSku?: boolean;
    /**
     * Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
     */
    vnet?: string;
}

export interface MachineConfigV2DigitaloceanConfig {
    /**
     * Digital Ocean access token
     */
    accessToken?: string;
    /**
     * Enable backups for droplet
     */
    backups?: boolean;
    /**
     * Digital Ocean Image
     */
    image?: string;
    /**
     * Enable ipv6 for droplet
     */
    ipv6?: boolean;
    /**
     * Enable monitoring for droplet
     */
    monitoring?: boolean;
    /**
     * Enable private networking for droplet
     */
    privateNetworking?: boolean;
    /**
     * Digital Ocean region
     */
    region?: string;
    /**
     * Digital Ocean size
     */
    size?: string;
    /**
     * SSH private key contents
     */
    sshKeyContents?: string;
    /**
     * SSH key fingerprint
     */
    sshKeyFingerprint?: string;
    /**
     * SSH port
     */
    sshPort?: string;
    /**
     * SSH username
     */
    sshUser?: string;
    /**
     * Comma-separated list of tags to apply to the Droplet
     */
    tags?: string;
    /**
     * Path to file with cloud-init user-data
     */
    userdata?: string;
}

export interface MachineConfigV2HarvesterConfig {
    /**
     * CPU count
     */
    cpuCount?: string;
    /**
     * Disk bus
     *
     * @deprecated Deprecated
     */
    diskBus?: string;
    /**
     * A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
     */
    diskInfo?: string;
    /**
     * Disk size (in GiB)
     *
     * @deprecated Deprecated
     */
    diskSize?: string;
    /**
     * Image name
     *
     * @deprecated Deprecated
     */
    imageName?: string;
    /**
     * Memory size (in GiB)
     */
    memorySize?: string;
    /**
     * NetworkData content of cloud-init, base64 is supported
     */
    networkData?: string;
    /**
     * A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
     */
    networkInfo?: string;
    /**
     * Network model
     *
     * @deprecated Deprecated
     */
    networkModel?: string;
    /**
     * Network name
     *
     * @deprecated Deprecated
     */
    networkName?: string;
    /**
     * SSH password
     */
    sshPassword?: string;
    /**
     * SSH username
     */
    sshUser: string;
    /**
     * UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
     */
    userData?: string;
    /**
     * VM affinity, base64 is supported
     */
    vmAffinity?: string;
    /**
     * Virtual machine namespace
     */
    vmNamespace: string;
}

export interface MachineConfigV2LinodeConfig {
    /**
     * Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
     */
    authorizedUsers?: string;
    /**
     * Create private IP for the instance
     */
    createPrivateIp?: boolean;
    /**
     * Docker Port
     */
    dockerPort?: string;
    /**
     * Specifies the Linode Instance image which determines the OS distribution and base files
     */
    image?: string;
    /**
     * Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
     */
    instanceType?: string;
    /**
     * Linode Instance Label
     */
    label?: string;
    /**
     * Specifies the region (location) of the Linode instance
     */
    region?: string;
    /**
     * Root Password
     */
    rootPass?: string;
    /**
     * Linode Instance SSH Port
     */
    sshPort?: string;
    /**
     * Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
     */
    sshUser?: string;
    /**
     * Specifies the Linode StackScript to use to create the instance
     */
    stackscript?: string;
    /**
     * A JSON string specifying data for the selected StackScript
     */
    stackscriptData?: string;
    /**
     * Linode Instance Swap Size (MB)
     */
    swapSize?: string;
    /**
     * A comma separated list of tags to apply to the the Linode resource
     */
    tags?: string;
    /**
     * Linode API Token
     */
    token?: string;
    /**
     * Prefix the User-Agent in Linode API calls with some 'product/version'
     */
    uaPrefix?: string;
}

export interface MachineConfigV2OpenstackConfig {
    activeTimeout?: string;
    applicationCredentialId?: string;
    applicationCredentialName?: string;
    applicationCredentialSecret?: string;
    authUrl: string;
    availabilityZone: string;
    bootFromVolume?: boolean;
    cacert?: string;
    configDrive?: boolean;
    domainId?: string;
    domainName?: string;
    endpointType?: string;
    flavorId?: string;
    flavorName?: string;
    floatingIpPool?: string;
    imageId?: string;
    imageName?: string;
    insecure?: boolean;
    ipVersion?: string;
    keypairName?: string;
    netId?: string;
    netName?: string;
    novaNetwork?: boolean;
    password?: string;
    privateKeyFile?: string;
    region: string;
    secGroups?: string;
    sshPort?: string;
    sshUser?: string;
    tenantDomainId?: string;
    tenantDomainName?: string;
    tenantId?: string;
    tenantName?: string;
    userDataFile?: string;
    userDomainId?: string;
    userDomainName?: string;
    username?: string;
    volumeDevicePath?: string;
    volumeId?: string;
    volumeName?: string;
    volumeSize?: string;
    volumeType?: string;
}

export interface MachineConfigV2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MachineConfigV2VsphereConfig {
    /**
     * vSphere URL for boot2docker image
     */
    boot2dockerUrl?: string;
    /**
     * vSphere vm configuration parameters (used for guestinfo)
     */
    cfgparams?: string[];
    /**
     * If you choose creation type clone a name of what you want to clone is required
     */
    cloneFrom?: string;
    /**
     * Filepath to a cloud-config yaml file to put into the ISO user-data
     */
    cloudConfig?: string;
    /**
     * vSphere cloud-init filepath or url to add to guestinfo
     */
    cloudinit?: string;
    /**
     * If you choose to clone from a content library template specify the name of the library
     */
    contentLibrary?: string;
    /**
     * vSphere CPU number for docker VM
     */
    cpuCount?: string;
    /**
     * Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
     */
    creationType?: string;
    /**
     * vSphere custom attributes, format key/value e.g. '200=my custom value'
     */
    customAttributes?: string[];
    /**
     * vSphere datacenter for virtual machine
     */
    datacenter?: string;
    /**
     * vSphere datastore for virtual machine
     */
    datastore?: string;
    /**
     * vSphere datastore cluster for virtual machine
     */
    datastoreCluster?: string;
    /**
     * vSphere size of disk for docker VM (in MB)
     */
    diskSize?: string;
    /**
     * vSphere folder for the docker VM. This folder must already exist in the datacenter
     */
    folder?: string;
    /**
     * Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
     */
    gracefulShutdownTimeout?: string;
    /**
     * vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
     */
    hostsystem?: string;
    /**
     * vSphere size of memory for docker VM (in MB)
     */
    memorySize?: string;
    /**
     * vSphere network where the virtual machine will be attached
     */
    networks?: string[];
    /**
     * vSphere password
     */
    password?: string;
    /**
     * vSphere resource pool for docker VM
     */
    pool?: string;
    /**
     * If using a non-B2D image you can specify the ssh password
     */
    sshPassword?: string;
    /**
     * If using a non-B2D image you can specify the ssh port
     */
    sshPort?: string;
    /**
     * If using a non-B2D image you can specify the ssh user
     */
    sshUser?: string;
    /**
     * If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
     */
    sshUserGroup?: string;
    /**
     * vSphere tags id e.g. urn:xxx
     */
    tags?: string[];
    /**
     * vSphere username
     */
    username?: string;
    /**
     * vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
     */
    vappIpAllocationPolicy?: string;
    /**
     * vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
     */
    vappIpProtocol?: string;
    /**
     * vSphere vApp properties
     */
    vappProperties?: string[];
    /**
     * vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
     */
    vappTransport?: string;
    /**
     * vSphere IP/hostname for vCenter
     */
    vcenter?: string;
    /**
     * vSphere Port for vCenter
     */
    vcenterPort?: string;
}

export interface MultiClusterAppAnswer {
    /**
     * Cluster ID for answer
     */
    clusterId: string;
    /**
     * Project ID for answer
     */
    projectId: string;
    /**
     * Key/values for answer
     */
    values: {[key: string]: string};
}

export interface MultiClusterAppMember {
    /**
     * Member access type: member, owner, read-only
     */
    accessType?: string;
    /**
     * Member group principal id
     */
    groupPrincipalId?: string;
    /**
     * Member user principal id
     */
    userPrincipalId?: string;
}

export interface MultiClusterAppTarget {
    /**
     * App ID for target
     */
    appId: string;
    /**
     * App health state for target
     */
    healthState: string;
    /**
     * Project ID for target
     */
    projectId: string;
    /**
     * App state for target
     */
    state: string;
}

export interface MultiClusterAppTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MultiClusterAppUpgradeStrategy {
    /**
     * Rolling update for upgrade strategy
     */
    rollingUpdate?: outputs.MultiClusterAppUpgradeStrategyRollingUpdate;
}

export interface MultiClusterAppUpgradeStrategyRollingUpdate {
    /**
     * Rolling update batch size
     */
    batchSize?: number;
    /**
     * Rolling update interval
     */
    interval?: number;
}

export interface NamespaceContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface NamespaceResourceQuota {
    limit: outputs.NamespaceResourceQuotaLimit;
}

export interface NamespaceResourceQuotaLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface NamespaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NodeDriverTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NodePoolNodeTaint {
    effect?: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface NodePoolTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NodeTemplateAmazonec2Config {
    /**
     * AWS Access Key
     */
    accessKey?: string;
    /**
     * AWS machine image
     */
    ami: string;
    /**
     * AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
     */
    blockDurationMinutes?: string;
    /**
     * AWS root device name
     */
    deviceName?: string;
    /**
     * Encrypt EBS volume
     */
    encryptEbsVolume?: boolean;
    /**
     * Optional endpoint URL (hostname only or fully qualified URI)
     */
    endpoint?: string;
    /**
     * Enables or disables the HTTP metadata endpoint on your instances
     */
    httpEndpoint?: string;
    /**
     * The state of token usage for your instance metadata requests
     */
    httpTokens?: string;
    /**
     * AWS IAM Instance Profile
     */
    iamInstanceProfile?: string;
    /**
     * Disable SSL when sending requests
     */
    insecureTransport?: boolean;
    /**
     * AWS instance type
     */
    instanceType?: string;
    /**
     * Custom KMS key ID using the AWS Managed CMK
     */
    kmsKey?: string;
    /**
     * Set this flag to enable CloudWatch monitoring
     */
    monitoring?: boolean;
    /**
     * Make the specified port number accessible from the Internet
     */
    openPorts?: string[];
    /**
     * Only use a private IP address
     */
    privateAddressOnly?: boolean;
    /**
     * AWS Region
     */
    region: string;
    /**
     * Set this flag to request spot instance
     */
    requestSpotInstance?: boolean;
    /**
     * Set retry count for recoverable failures (use -1 to disable)
     */
    retries?: string;
    /**
     * AWS root disk size (in GB)
     */
    rootSize?: string;
    /**
     * AWS Secret Key
     */
    secretKey?: string;
    /**
     * Skip adding default rules to security groups
     */
    securityGroupReadonly?: boolean;
    /**
     * AWS VPC security group
     */
    securityGroups: string[];
    /**
     * AWS Session Token
     */
    sessionToken?: string;
    /**
     * AWS spot instance bid price (in dollar)
     */
    spotPrice?: string;
    /**
     * SSH Key for Instance
     */
    sshKeypath?: string;
    /**
     * Set the name of the ssh user
     */
    sshUser?: string;
    /**
     * AWS VPC subnet id
     */
    subnetId: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2)
     */
    tags?: string;
    /**
     * Create an EBS optimized instance
     */
    useEbsOptimizedInstance?: boolean;
    /**
     * Force the usage of private IP address
     */
    usePrivateAddress?: boolean;
    /**
     * Path to file with cloud-init user data
     */
    userdata?: string;
    /**
     * Amazon EBS volume type
     */
    volumeType?: string;
    /**
     * AWS VPC id
     */
    vpcId: string;
    /**
     * AWS zone for instance (i.e. a,b,c,d,e)
     */
    zone: string;
}

export interface NodeTemplateAzureConfig {
    /**
     * Enable Accelerated Networking when creating an Azure Network Interface
     */
    acceleratedNetworking?: boolean;
    /**
     * Azure Availability Set to place the virtual machine into
     */
    availabilitySet?: string;
    /**
     * The Azure Availability Zone the VM should be created in
     */
    availabilityZone?: string;
    /**
     * Azure Service Principal Account ID (optional, browser auth is used if not specified)
     */
    clientId?: string;
    /**
     * Azure Service Principal Account password (optional, browser auth is used if not specified)
     */
    clientSecret?: string;
    /**
     * Path to file with custom-data
     */
    customData?: string;
    /**
     * Disk size if using managed disk
     */
    diskSize?: string;
    /**
     * A unique DNS label for the public IP adddress
     */
    dns?: string;
    /**
     * Port number for Docker engine
     */
    dockerPort?: string;
    /**
     * Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
     */
    environment?: string;
    /**
     * Fault domain count to use for availability set
     */
    faultDomainCount?: string;
    /**
     * Azure virtual machine OS image
     */
    image?: string;
    /**
     * Azure region to create the virtual machine
     */
    location?: string;
    /**
     * Configures VM and availability set for managed disks
     */
    managedDisks?: boolean;
    /**
     * Do not create a public IP address for the machine
     */
    noPublicIp?: boolean;
    /**
     * Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
     */
    nsg?: string;
    /**
     * Make the specified port number accessible from the Internet
     */
    openPorts?: string[];
    /**
     * Purchase plan for Azure Virtual Machine (in <publisher>:<product>:<plan> format)
     */
    plan?: string;
    /**
     * Specify a static private IP address for the machine
     */
    privateIpAddress?: string;
    /**
     * Azure Resource Group name (will be created if missing)
     */
    resourceGroup?: string;
    /**
     * Size for Azure Virtual Machine
     */
    size?: string;
    /**
     * Username for SSH login
     */
    sshUser?: string;
    /**
     * Assign a static public IP address to the machine
     */
    staticPublicIp?: boolean;
    /**
     * Type of Storage Account to host the OS Disk for the machine
     */
    storageType?: string;
    /**
     * Azure Subnet Name to be used within the Virtual Network
     */
    subnet?: string;
    /**
     * Private CIDR block to be used for the new subnet, should comply RFC 1918
     */
    subnetPrefix?: string;
    /**
     * Azure Subscription ID
     */
    subscriptionId?: string;
    /**
     * Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
     */
    tags?: string;
    /**
     * Update domain count to use for availability set
     */
    updateDomainCount?: string;
    /**
     * Use private IP address of the machine to connect
     */
    usePrivateIp?: boolean;
    /**
     * Use the Standard SKU when creating a public IP for an Azure VM
     */
    usePublicIpStandardSku?: boolean;
    /**
     * Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
     */
    vnet?: string;
}

export interface NodeTemplateDigitaloceanConfig {
    /**
     * Digital Ocean access token
     */
    accessToken?: string;
    /**
     * Enable backups for droplet
     */
    backups?: boolean;
    /**
     * Digital Ocean Image
     */
    image?: string;
    /**
     * Enable ipv6 for droplet
     */
    ipv6?: boolean;
    /**
     * Enable monitoring for droplet
     */
    monitoring?: boolean;
    /**
     * Enable private networking for droplet
     */
    privateNetworking?: boolean;
    /**
     * Digital Ocean region
     */
    region?: string;
    /**
     * Digital Ocean size
     */
    size?: string;
    /**
     * SSH key fingerprint
     */
    sshKeyFingerprint?: string;
    /**
     * SSH private key path
     */
    sshKeyPath?: string;
    /**
     * SSH port
     */
    sshPort?: string;
    /**
     * SSH username
     */
    sshUser?: string;
    /**
     * Comma-separated list of tags to apply to the Droplet
     */
    tags?: string;
    /**
     * Path to file with cloud-init user-data
     */
    userdata?: string;
}

export interface NodeTemplateHarvesterConfig {
    /**
     * CPU count
     */
    cpuCount?: string;
    /**
     * Disk bus
     *
     * @deprecated Deprecated
     */
    diskBus?: string;
    /**
     * A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
     */
    diskInfo?: string;
    /**
     * Disk size (in GiB)
     *
     * @deprecated Deprecated
     */
    diskSize?: string;
    /**
     * Image name
     *
     * @deprecated Deprecated
     */
    imageName?: string;
    /**
     * Memory size (in GiB)
     */
    memorySize?: string;
    /**
     * NetworkData content of cloud-init, base64 is supported
     */
    networkData?: string;
    /**
     * A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
     */
    networkInfo?: string;
    /**
     * Network model
     *
     * @deprecated Deprecated
     */
    networkModel?: string;
    /**
     * Network name
     *
     * @deprecated Deprecated
     */
    networkName?: string;
    /**
     * SSH password
     */
    sshPassword?: string;
    /**
     * SSH username
     */
    sshUser: string;
    /**
     * UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
     */
    userData?: string;
    /**
     * VM affinity, base64 is supported
     */
    vmAffinity?: string;
    /**
     * Virtual machine namespace
     */
    vmNamespace: string;
}

export interface NodeTemplateHetznerConfig {
    /**
     * Hetzner Cloud project API token
     */
    apiToken: string;
    /**
     * Hetzner Cloud server image
     */
    image?: string;
    /**
     * Comma-separated list of network IDs or names which should be attached to the server private network interface
     */
    networks?: string;
    /**
     * Map of the labels which will be assigned to the server
     */
    serverLabels?: {[key: string]: string};
    /**
     * Hetzner Cloud datacenter
     */
    serverLocation?: string;
    /**
     * Hetzner Cloud server type
     */
    serverType?: string;
    /**
     * Use private network
     */
    usePrivateNetwork?: boolean;
    /**
     * Path to file with cloud-init user-data
     */
    userdata?: string;
    /**
     * Comma-separated list of volume IDs or names which should be attached to the server
     */
    volumes?: string;
}

export interface NodeTemplateLinodeConfig {
    /**
     * Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
     */
    authorizedUsers?: string;
    /**
     * Create private IP for the instance
     */
    createPrivateIp?: boolean;
    /**
     * Docker Port
     */
    dockerPort?: string;
    /**
     * Specifies the Linode Instance image which determines the OS distribution and base files
     */
    image?: string;
    /**
     * Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
     */
    instanceType?: string;
    /**
     * Linode Instance Label
     */
    label?: string;
    /**
     * Specifies the region (location) of the Linode instance
     */
    region?: string;
    /**
     * Root Password
     */
    rootPass?: string;
    /**
     * Linode Instance SSH Port
     */
    sshPort?: string;
    /**
     * Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
     */
    sshUser?: string;
    /**
     * Specifies the Linode StackScript to use to create the instance
     */
    stackscript?: string;
    /**
     * A JSON string specifying data for the selected StackScript
     */
    stackscriptData?: string;
    /**
     * Linode Instance Swap Size (MB)
     */
    swapSize?: string;
    /**
     * A comma separated list of tags to apply to the the Linode resource
     */
    tags?: string;
    /**
     * Linode API Token
     */
    token?: string;
    /**
     * Prefix the User-Agent in Linode API calls with some 'product/version'
     */
    uaPrefix?: string;
}

export interface NodeTemplateNodeTaint {
    effect?: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface NodeTemplateOpennebulaConfig {
    b2dSize?: string;
    cpu?: string;
    devPrefix?: string;
    disableVnc?: boolean;
    diskResize?: string;
    imageId?: string;
    imageName?: string;
    imageOwner?: string;
    memory?: string;
    networkId?: string;
    networkName?: string;
    networkOwner?: string;
    password: string;
    sshUser?: string;
    templateId?: string;
    templateName?: string;
    user: string;
    vcpu?: string;
    xmlRpcUrl: string;
}

export interface NodeTemplateOpenstackConfig {
    activeTimeout?: string;
    applicationCredentialId?: string;
    applicationCredentialName?: string;
    applicationCredentialSecret?: string;
    authUrl: string;
    availabilityZone: string;
    bootFromVolume?: boolean;
    cacert?: string;
    configDrive?: boolean;
    domainId?: string;
    domainName?: string;
    endpointType?: string;
    flavorId?: string;
    flavorName?: string;
    floatingIpPool?: string;
    imageId?: string;
    imageName?: string;
    insecure?: boolean;
    ipVersion?: string;
    keypairName?: string;
    netId?: string;
    netName?: string;
    novaNetwork?: boolean;
    password?: string;
    privateKeyFile?: string;
    region: string;
    secGroups?: string;
    sshPort?: string;
    sshUser?: string;
    tenantId?: string;
    tenantName?: string;
    userDataFile?: string;
    username?: string;
    volumeDevicePath?: string;
    volumeId?: string;
    volumeName?: string;
    volumeSize?: string;
    volumeType?: string;
}

export interface NodeTemplateOutscaleConfig {
    /**
     * Outscale Access Key
     */
    accessKey: string;
    /**
     * Extra tags for all created resources (e.g. key1=value1,key2=value2)
     */
    extraTagsAlls?: string[];
    /**
     * Extra tags only for instances (e.g. key1=value1,key2=value2)
     */
    extraTagsInstances?: string[];
    /**
     * Outscale VM type
     */
    instanceType?: string;
    /**
     * Outscale Region
     */
    region?: string;
    /**
     * Iops for io1 Root Disk. From 1 to 13000.
     */
    rootDiskIops?: number;
    /**
     * Size of the Root Disk (in GB). From 1 to 14901.
     */
    rootDiskSize?: number;
    /**
     * Type of the Root Disk. Possible values are :'standard', 'gp2' or 'io1'.
     */
    rootDiskType?: string;
    /**
     * Outscale Secret Key
     */
    secretKey: string;
    /**
     * Ids of user defined Security Groups to add to the machine
     */
    securityGroupIds?: string[];
    /**
     * Outscale Machine Image to use as bootstrap for the VM
     */
    sourceOmi?: string;
}

export interface NodeTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NodeTemplateVsphereConfig {
    /**
     * vSphere URL for boot2docker image
     */
    boot2dockerUrl?: string;
    /**
     * vSphere vm configuration parameters (used for guestinfo)
     */
    cfgparams?: string[];
    /**
     * If you choose creation type clone a name of what you want to clone is required
     */
    cloneFrom?: string;
    /**
     * Filepath to a cloud-config yaml file to put into the ISO user-data
     */
    cloudConfig?: string;
    /**
     * vSphere cloud-init filepath or url to add to guestinfo
     */
    cloudinit?: string;
    /**
     * If you choose to clone from a content library template specify the name of the library
     */
    contentLibrary?: string;
    /**
     * vSphere CPU number for docker VM
     */
    cpuCount?: string;
    /**
     * Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
     */
    creationType?: string;
    /**
     * vSphere custom attributes, format key/value e.g. '200=my custom value'
     */
    customAttributes?: string[];
    /**
     * vSphere datacenter for virtual machine
     */
    datacenter?: string;
    /**
     * vSphere datastore for virtual machine
     */
    datastore?: string;
    /**
     * vSphere datastore cluster for virtual machine
     */
    datastoreCluster?: string;
    /**
     * vSphere size of disk for docker VM (in MB)
     */
    diskSize?: string;
    /**
     * vSphere folder for the docker VM. This folder must already exist in the datacenter
     */
    folder?: string;
    /**
     * Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
     */
    gracefulShutdownTimeout?: string;
    /**
     * vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
     */
    hostsystem?: string;
    /**
     * vSphere size of memory for docker VM (in MB)
     */
    memorySize?: string;
    /**
     * vSphere network where the virtual machine will be attached
     */
    networks?: string[];
    /**
     * vSphere password
     */
    password?: string;
    /**
     * vSphere resource pool for docker VM
     */
    pool?: string;
    /**
     * If using a non-B2D image you can specify the ssh password
     */
    sshPassword?: string;
    /**
     * If using a non-B2D image you can specify the ssh port
     */
    sshPort?: string;
    /**
     * If using a non-B2D image you can specify the ssh user
     */
    sshUser?: string;
    /**
     * If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
     */
    sshUserGroup?: string;
    /**
     * vSphere tags id e.g. urn:xxx
     */
    tags?: string[];
    /**
     * vSphere username
     */
    username?: string;
    /**
     * vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
     */
    vappIpAllocationPolicy?: string;
    /**
     * vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
     */
    vappIpProtocol?: string;
    /**
     * vSphere vApp properties
     */
    vappProperties?: string[];
    /**
     * vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
     */
    vappTransport?: string;
    /**
     * vSphere IP/hostname for vCenter
     */
    vcenter?: string;
    /**
     * vSphere Port for vCenter
     */
    vcenterPort?: string;
}

export interface PodSecurityAdmissionConfigurationTemplateDefaults {
    /**
     * Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
     */
    audit?: string;
    /**
     * Pod Security Admission Configuration audit version (default: latest)
     */
    auditVersion?: string;
    /**
     * Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
     */
    enforce?: string;
    /**
     * Pod Security Admission Configuration enforce version (default: latest)
     */
    enforceVersion?: string;
    /**
     * Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
     */
    warn?: string;
    /**
     * Pod Security Admission Configuration warn version (default: latest)
     */
    warnVersion?: string;
}

export interface PodSecurityAdmissionConfigurationTemplateExemptions {
    /**
     * Pod Security Admission Configuration namespace exemptions
     */
    namespaces?: string[];
    /**
     * Pod Security Admission Configuration runtime class exemptions
     */
    runtimeClasses?: string[];
    /**
     * Pod Security Admission Configuration username exemptions
     */
    usernames?: string[];
}

export interface PodSecurityAdmissionConfigurationTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ProjectContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface ProjectResourceQuota {
    namespaceDefaultLimit: outputs.ProjectResourceQuotaNamespaceDefaultLimit;
    projectLimit: outputs.ProjectResourceQuotaProjectLimit;
}

export interface ProjectResourceQuotaNamespaceDefaultLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface ProjectResourceQuotaProjectLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface ProjectRoleTemplateBindingTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ProjectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RegistryRegistry {
    address: string;
    password?: string;
    username?: string;
}

export interface RegistryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RoleTemplateExternalRule {
    /**
     * Policy rule api groups
     */
    apiGroups?: string[];
    /**
     * Policy rule non resource urls
     */
    nonResourceUrls?: string[];
    /**
     * Policy rule resource names
     */
    resourceNames?: string[];
    /**
     * Policy rule resources
     */
    resources?: string[];
    /**
     * Policy rule verbs
     */
    verbs?: string[];
}

export interface RoleTemplateRule {
    /**
     * Policy rule api groups
     */
    apiGroups?: string[];
    /**
     * Policy rule non resource urls
     */
    nonResourceUrls?: string[];
    /**
     * Policy rule resource names
     */
    resourceNames?: string[];
    /**
     * Policy rule resources
     */
    resources?: string[];
    /**
     * Policy rule verbs
     */
    verbs?: string[];
}

export interface RoleTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SecretTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SecretV2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface StorageClassV2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface TokenTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface UserTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

