// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface DatastoreCeph {
    /**
     * Non-default Ceph configuration file if needed
     */
    config?: pulumi.Input<string>;
    /**
     * List of Ceph monitors
     */
    hosts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Key file for user. if not set default locations are used
     */
    key?: pulumi.Input<string>;
    /**
     * Use local host storage, SSH mode
     */
    localStorage?: pulumi.Input<boolean>;
    /**
     * Ceph pool name
     */
    poolName?: pulumi.Input<string>;
    /**
     * By default RBD Format 2 will be used
     */
    rbdFormat?: pulumi.Input<string>;
    /**
     * The UUID of the libvirt secret
     */
    secret?: pulumi.Input<string>;
    /**
     * Enables trash feature on given datastore
     */
    trash?: pulumi.Input<boolean>;
    /**
     * Ceph user name
     */
    user?: pulumi.Input<string>;
}

export interface DatastoreCustom {
    /**
     * Datastore driver
     */
    datastore?: pulumi.Input<string>;
    /**
     * Transfer driver
     */
    transfer: pulumi.Input<string>;
}

export interface GroupOpennebula {
    /**
     * Sets order of elements by ID in list API calls: ASC or DESC respectively for ascending or descending order
     */
    apiListOrder?: pulumi.Input<string>;
    /**
     * Control the default value for the PERSISTENT attribute on image creation ( clone and disk save-as): should be YES or NO
     */
    defaultImagePersistent?: pulumi.Input<string>;
    /**
     * Control the default value for the PERSISTENT attribute on image creation ( only new images): should be YES or NO
     */
    defaultImagePersistentNew?: pulumi.Input<string>;
}

export interface GroupQuota {
    /**
     * Datastore quotas
     */
    datastoreQuotas?: pulumi.Input<pulumi.Input<inputs.GroupQuotaDatastoreQuota>[]>;
    /**
     * Image quotas
     */
    imageQuotas?: pulumi.Input<pulumi.Input<inputs.GroupQuotaImageQuota>[]>;
    /**
     * Network quotas
     */
    networkQuotas?: pulumi.Input<pulumi.Input<inputs.GroupQuotaNetworkQuota>[]>;
    /**
     * VM quotas
     */
    vmQuotas?: pulumi.Input<pulumi.Input<inputs.GroupQuotaVmQuota>[]>;
}

export interface GroupQuotaDatastoreQuota {
    /**
     * Datastore ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: pulumi.Input<number>;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: pulumi.Input<number>;
}

export interface GroupQuotaImageQuota {
    /**
     * Image ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
}

export interface GroupQuotaNetworkQuota {
    /**
     * Network ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: pulumi.Input<number>;
}

export interface GroupQuotaVmQuota {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: pulumi.Input<number>;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: pulumi.Input<number>;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: pulumi.Input<number>;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: pulumi.Input<number>;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: pulumi.Input<number>;
}

export interface GroupQuotasDatastore {
    /**
     * Datastore ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: pulumi.Input<number>;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: pulumi.Input<number>;
}

export interface GroupQuotasImage {
    /**
     * Image ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
}

export interface GroupQuotasNetwork {
    /**
     * Network ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: pulumi.Input<number>;
}

export interface GroupQuotasVm {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: pulumi.Input<number>;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: pulumi.Input<number>;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: pulumi.Input<number>;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: pulumi.Input<number>;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: pulumi.Input<number>;
}

export interface GroupSunstone {
    /**
     * Default Sunstone view for regular users
     */
    defaultView?: pulumi.Input<string>;
    /**
     * Default Sunstone view for group admin users
     */
    groupAdminDefaultView?: pulumi.Input<string>;
    /**
     * List of available views for the group admins
     */
    groupAdminViews?: pulumi.Input<string>;
    /**
     * List of available views for regular users
     */
    views?: pulumi.Input<string>;
}

export interface GroupTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface HostCustom {
    /**
     * Information driver
     */
    information?: pulumi.Input<string>;
    /**
     * Virtualization driver
     */
    virtualization?: pulumi.Input<string>;
}

export interface HostOvercommit {
    /**
     * Maximum allocatable CPU capacity in number of cores multiplied by 100
     */
    cpu?: pulumi.Input<number>;
    /**
     * Maximum allocatable memory capacity in KB
     */
    memory?: pulumi.Input<number>;
}

export interface HostTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface ImageTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface ImageTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface MarketplaceApplianceTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface MarketplaceApplianceTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface MarketplaceHttp {
    /**
     * Base URL of the Marketplace HTTP endpoint
     */
    endpointUrl: pulumi.Input<string>;
    /**
     * Absolute directory path to place images in the front-end or in the hosts pointed at by storage_bridge_list
     */
    path: pulumi.Input<string>;
    /**
     * List of servers to access the public directory
     */
    storageBridgeLists?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface MarketplaceLxc {
    /**
     * VM template CPU
     */
    cpu?: pulumi.Input<number>;
    /**
     * The base URL of the Market
     */
    endpointUrl?: pulumi.Input<string>;
    /**
     * Filesystem used for the image
     */
    filesystem?: pulumi.Input<string>;
    /**
     * Image block file format
     */
    imageBlockFileFormat?: pulumi.Input<string>;
    /**
     * VM template memory
     */
    memory?: pulumi.Input<number>;
    /**
     * Secrurity mode of the Linux Container
     */
    privileged?: pulumi.Input<boolean>;
    /**
     * Size in MB for the image holding the rootfs
     */
    roofsImageSize?: pulumi.Input<number>;
    /**
     * Include only apps with support for context
     */
    skipUntested?: pulumi.Input<boolean>;
    /**
     * VM template VCPU
     */
    vcpu?: pulumi.Input<number>;
}

export interface MarketplaceOne {
    /**
     * The marketplace endpoint url
     */
    endpointUrl?: pulumi.Input<string>;
}

export interface MarketplaceS3 {
    /**
     * The access key of the S3 user
     */
    accessKeyId: pulumi.Input<string>;
    /**
     * The bucket where the files will be stored
     */
    bucket: pulumi.Input<string>;
    /**
     * Only required when connecteing to a service other than Amazon S3
     */
    endpointUrl?: pulumi.Input<string>;
    /**
     * Split the file into chunks of this size in MB
     */
    readBlockLength?: pulumi.Input<number>;
    /**
     * The region to connect to. Any value will work with Ceph-S3
     */
    region: pulumi.Input<string>;
    /**
     * The secret key of the S3 user
     */
    secretAccessKey: pulumi.Input<string>;
    /**
     * Define the total size of the marketplace in MB.
     */
    totalSize?: pulumi.Input<number>;
    /**
     * Type of the s3 backend: aws, ceph, minio
     */
    type?: pulumi.Input<string>;
}

export interface MarketplaceTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface MarketplaceTimeouts {
    create?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface MarketplaceTurnkey {
    /**
     * The base URL of the Market
     */
    endpointUrl?: pulumi.Input<string>;
    /**
     * Filesystem used for the image
     */
    filesystem?: pulumi.Input<string>;
    /**
     * Image block file format
     */
    imageBlockFileFormat?: pulumi.Input<string>;
    /**
     * Size in MB for the image holding the rootfs
     */
    roofsImageSize?: pulumi.Input<number>;
    /**
     * Include only apps with support for context
     */
    skipUntested?: pulumi.Input<boolean>;
}

export interface ProviderDefaultTag {
    /**
     * Default tags to apply
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface SecurityGroupRule {
    /**
     * Type of ICMP traffic to apply to when 'protocol' is ICMP
     */
    icmpType?: pulumi.Input<string>;
    /**
     * IP (or starting IP if used with 'size') to apply the rule to
     */
    ip?: pulumi.Input<string>;
    /**
     * VNET ID to be used as the source/destination IP addresses
     */
    networkId?: pulumi.Input<string>;
    /**
     * Protocol for the rule, must be one of: ALL, TCP, UDP, ICMP or IPSEC
     */
    protocol: pulumi.Input<string>;
    /**
     * Comma separated list of ports and port ranges
     */
    range?: pulumi.Input<string>;
    /**
     * Direction of the traffic flow to allow, must be INBOUND or OUTBOUND
     */
    ruleType: pulumi.Input<string>;
    /**
     * Number of IPs to apply the rule from, starting with 'ip'
     */
    size?: pulumi.Input<string>;
}

export interface SecurityGroupTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface ServiceRole {
    cardinality: pulumi.Input<number>;
    name: pulumi.Input<string>;
    nodes: pulumi.Input<pulumi.Input<number>[]>;
    state: pulumi.Input<number>;
}

export interface ServiceTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface TemplateCpumodel {
    model: pulumi.Input<string>;
}

export interface TemplateDisk {
    cache?: pulumi.Input<string>;
    devPrefix?: pulumi.Input<string>;
    discard?: pulumi.Input<string>;
    driver?: pulumi.Input<string>;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: pulumi.Input<number>;
    io?: pulumi.Input<string>;
    size?: pulumi.Input<number>;
    target?: pulumi.Input<string>;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: pulumi.Input<string>;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: pulumi.Input<string>;
}

export interface TemplateFeature {
    /**
     * Useful for power management, for example, with KVM guests it is required for graceful shutdown to work.
     */
    acpi?: pulumi.Input<string>;
    /**
     * Enables the advanced programmable IRQ management. Useful for SMP machines.
     */
    apic?: pulumi.Input<string>;
    /**
     * Enables the QEMU Guest Agent communication. This only creates the socket inside the VM, the Guest Agent itself must be installed and started in the VM.
     */
    guestAgent?: pulumi.Input<string>;
    /**
     * Add hyperv extensions to the VM. The options can be configured in the driver configuration, HYPERV_OPTIONS.
     */
    hyperv?: pulumi.Input<string>;
    /**
     * Number of iothreads for virtio disks. By default threads will be assign to disk by round robin algorithm. Disk thread id can be forced by disk IOTHREAD attribute.
     */
    iothreads?: pulumi.Input<string>;
    /**
     * The guest clock will be synchronized to the host’s configured timezone when booted. Useful for Windows VMs.
     */
    localtime?: pulumi.Input<string>;
    /**
     * Physical address extension mode allows 32-bit guests to address more than 4 GB of memory.
     */
    pae?: pulumi.Input<string>;
    /**
     * Numer of vCPU queues for the virtio-scsi controller.
     */
    virtioScsiQueues?: pulumi.Input<string>;
}

export interface TemplateGraphics {
    keymap?: pulumi.Input<string>;
    listen: pulumi.Input<string>;
    passwd?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    randomPasswd?: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
}

export interface TemplateNic {
    ip?: pulumi.Input<string>;
    mac?: pulumi.Input<string>;
    model?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
    networkId?: pulumi.Input<number>;
    networkModeAuto?: pulumi.Input<boolean>;
    physicalDevice?: pulumi.Input<string>;
    schedRank?: pulumi.Input<string>;
    schedRequirements?: pulumi.Input<string>;
    securityGroups?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Only if model is virtio
     */
    virtioQueues?: pulumi.Input<string>;
}

export interface TemplateOs {
    arch: pulumi.Input<string>;
    boot: pulumi.Input<string>;
}

export interface TemplateRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: pulumi.Input<string>;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: pulumi.Input<string>;
}

export interface TemplateTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface TemplateVmgroup {
    role: pulumi.Input<string>;
    vmgroupId: pulumi.Input<number>;
}

export interface UserQuota {
    /**
     * Datastore quotas
     */
    datastoreQuotas?: pulumi.Input<pulumi.Input<inputs.UserQuotaDatastoreQuota>[]>;
    /**
     * Image quotas
     */
    imageQuotas?: pulumi.Input<pulumi.Input<inputs.UserQuotaImageQuota>[]>;
    /**
     * Network quotas
     */
    networkQuotas?: pulumi.Input<pulumi.Input<inputs.UserQuotaNetworkQuota>[]>;
    /**
     * VM quotas
     */
    vmQuotas?: pulumi.Input<pulumi.Input<inputs.UserQuotaVmQuota>[]>;
}

export interface UserQuotaDatastoreQuota {
    /**
     * Datastore ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: pulumi.Input<number>;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: pulumi.Input<number>;
}

export interface UserQuotaImageQuota {
    /**
     * Image ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
}

export interface UserQuotaNetworkQuota {
    /**
     * Network ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: pulumi.Input<number>;
}

export interface UserQuotaVmQuota {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: pulumi.Input<number>;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: pulumi.Input<number>;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: pulumi.Input<number>;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: pulumi.Input<number>;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: pulumi.Input<number>;
}

export interface UserQuotasDatastore {
    /**
     * Datastore ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: pulumi.Input<number>;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: pulumi.Input<number>;
}

export interface UserQuotasImage {
    /**
     * Image ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
}

export interface UserQuotasNetwork {
    /**
     * Network ID
     */
    id: pulumi.Input<number>;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: pulumi.Input<number>;
}

export interface UserQuotasVm {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: pulumi.Input<number>;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: pulumi.Input<number>;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: pulumi.Input<number>;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: pulumi.Input<number>;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: pulumi.Input<number>;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: pulumi.Input<number>;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: pulumi.Input<number>;
}

export interface UserTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface VirtualDataCenterZone {
    /**
     * List of cluster IDs from the Zone to add in the VDC
     */
    clusterIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * List of Datastore IDs from the Zone to add in the VDC
     */
    datastoreIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * List of Host IDs from the Zone to add in the VDC
     */
    hostIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Resources Zone ID (default: 0)
     */
    id?: pulumi.Input<number>;
    /**
     * List of VNET IDs from the Zone to add in the VDC
     */
    vnetIds?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface VirtualMachineCpumodel {
    model: pulumi.Input<string>;
}

export interface VirtualMachineDisk {
    cache?: pulumi.Input<string>;
    computedCache?: pulumi.Input<string>;
    computedDevPrefix?: pulumi.Input<string>;
    computedDiscard?: pulumi.Input<string>;
    computedDriver?: pulumi.Input<string>;
    computedIo?: pulumi.Input<string>;
    computedSize?: pulumi.Input<number>;
    computedTarget?: pulumi.Input<string>;
    computedVolatileFormat?: pulumi.Input<string>;
    devPrefix?: pulumi.Input<string>;
    discard?: pulumi.Input<string>;
    diskId?: pulumi.Input<number>;
    driver?: pulumi.Input<string>;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: pulumi.Input<number>;
    io?: pulumi.Input<string>;
    size?: pulumi.Input<number>;
    target?: pulumi.Input<string>;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: pulumi.Input<string>;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: pulumi.Input<string>;
}

export interface VirtualMachineGraphics {
    keymap?: pulumi.Input<string>;
    listen: pulumi.Input<string>;
    passwd?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    randomPasswd?: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
}

export interface VirtualMachineGroupRole {
    /**
     * Host(s) where the VM should run
     */
    hostAffineds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Host(s) where the VM should not run
     */
    hostAntiAffineds?: pulumi.Input<pulumi.Input<number>[]>;
    id?: pulumi.Input<number>;
    name: pulumi.Input<string>;
    policy?: pulumi.Input<string>;
}

export interface VirtualMachineGroupTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface VirtualMachineNic {
    computedIp?: pulumi.Input<string>;
    computedMac?: pulumi.Input<string>;
    computedModel?: pulumi.Input<string>;
    computedPhysicalDevice?: pulumi.Input<string>;
    computedSecurityGroups?: pulumi.Input<pulumi.Input<number>[]>;
    computedVirtioQueues?: pulumi.Input<string>;
    ip?: pulumi.Input<string>;
    mac?: pulumi.Input<string>;
    model?: pulumi.Input<string>;
    network?: pulumi.Input<string>;
    networkId?: pulumi.Input<number>;
    networkModeAuto?: pulumi.Input<boolean>;
    nicId?: pulumi.Input<number>;
    physicalDevice?: pulumi.Input<string>;
    schedRank?: pulumi.Input<string>;
    schedRequirements?: pulumi.Input<string>;
    securityGroups?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Only if model is virtio
     */
    virtioQueues?: pulumi.Input<string>;
}

export interface VirtualMachineOs {
    arch: pulumi.Input<string>;
    boot: pulumi.Input<string>;
}

export interface VirtualMachineRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: pulumi.Input<string>;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: pulumi.Input<string>;
}

export interface VirtualMachineTemplateDisk {
    computedCache: pulumi.Input<string>;
    computedDevPrefix: pulumi.Input<string>;
    computedDiscard: pulumi.Input<string>;
    computedDriver: pulumi.Input<string>;
    computedIo: pulumi.Input<string>;
    computedSize: pulumi.Input<number>;
    computedTarget: pulumi.Input<string>;
    computedVolatileFormat: pulumi.Input<string>;
    diskId: pulumi.Input<number>;
    imageId: pulumi.Input<number>;
}

export interface VirtualMachineTemplateNic {
    computedIp: pulumi.Input<string>;
    computedMac: pulumi.Input<string>;
    computedModel: pulumi.Input<string>;
    computedPhysicalDevice: pulumi.Input<string>;
    computedSecurityGroups: pulumi.Input<pulumi.Input<number>[]>;
    computedVirtioQueues: pulumi.Input<string>;
    network: pulumi.Input<string>;
    networkId: pulumi.Input<number>;
    nicId: pulumi.Input<number>;
}

export interface VirtualMachineTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface VirtualMachineTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface VirtualMachineVmgroup {
    role: pulumi.Input<string>;
    vmgroupId: pulumi.Input<number>;
}

export interface VirtualNetworkAddressRangeTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface VirtualNetworkAr {
    /**
     * Type of the Address Range: IP4, IP6. Default is 'IP4'
     */
    arType?: pulumi.Input<string>;
    /**
     * Global prefix for IP6 or IP4_6
     */
    computedGlobalPrefix?: pulumi.Input<string>;
    /**
     * Start IPv6 of the range to be allocated (Required if IP6_STATIC or IP4_6_STATIC)
     */
    computedIp6?: pulumi.Input<string>;
    /**
     * Start MAC of the range to be allocated
     */
    computedMac?: pulumi.Input<string>;
    /**
     * ULA prefix for IP6 or IP4_6
     */
    computedUlaPrefix?: pulumi.Input<string>;
    /**
     * Global prefix for IP6 or IP4_6
     */
    globalPrefix?: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    /**
     * Start IPv4 of the range to be allocated (Required if IP4 or IP4_6).
     */
    ip4?: pulumi.Input<string>;
    /**
     * Start IPv6 of the range to be allocated (Required if IP6_STATIC or IP4_6_STATIC)
     */
    ip6?: pulumi.Input<string>;
    /**
     * Start MAC of the range to be allocated
     */
    mac?: pulumi.Input<string>;
    /**
     * Prefix lenght Only needed for IP6_STATIC or IP4_6_STATIC
     */
    prefixLength?: pulumi.Input<string>;
    /**
     * Size (in number) of the ip range
     */
    size: pulumi.Input<number>;
    /**
     * ULA prefix for IP6 or IP4_6
     */
    ulaPrefix?: pulumi.Input<string>;
}

export interface VirtualNetworkTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface VirtualNetworkTimeouts {
    create?: pulumi.Input<string>;
}

export interface VirtualRouterInstanceCpumodel {
    model: pulumi.Input<string>;
}

export interface VirtualRouterInstanceDisk {
    cache?: pulumi.Input<string>;
    computedCache?: pulumi.Input<string>;
    computedDevPrefix?: pulumi.Input<string>;
    computedDiscard?: pulumi.Input<string>;
    computedDriver?: pulumi.Input<string>;
    computedIo?: pulumi.Input<string>;
    computedSize?: pulumi.Input<number>;
    computedTarget?: pulumi.Input<string>;
    computedVolatileFormat?: pulumi.Input<string>;
    devPrefix?: pulumi.Input<string>;
    discard?: pulumi.Input<string>;
    diskId?: pulumi.Input<number>;
    driver?: pulumi.Input<string>;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: pulumi.Input<number>;
    io?: pulumi.Input<string>;
    size?: pulumi.Input<number>;
    target?: pulumi.Input<string>;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: pulumi.Input<string>;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: pulumi.Input<string>;
}

export interface VirtualRouterInstanceGraphics {
    keymap?: pulumi.Input<string>;
    listen: pulumi.Input<string>;
    passwd?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    randomPasswd?: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
}

export interface VirtualRouterInstanceOs {
    arch: pulumi.Input<string>;
    boot: pulumi.Input<string>;
}

export interface VirtualRouterInstanceRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: pulumi.Input<string>;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateCpumodel {
    model: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateDisk {
    cache?: pulumi.Input<string>;
    devPrefix?: pulumi.Input<string>;
    discard?: pulumi.Input<string>;
    driver?: pulumi.Input<string>;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: pulumi.Input<number>;
    io?: pulumi.Input<string>;
    size?: pulumi.Input<number>;
    target?: pulumi.Input<string>;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: pulumi.Input<string>;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateFeature {
    /**
     * Useful for power management, for example, with KVM guests it is required for graceful shutdown to work.
     */
    acpi?: pulumi.Input<string>;
    /**
     * Enables the advanced programmable IRQ management. Useful for SMP machines.
     */
    apic?: pulumi.Input<string>;
    /**
     * Enables the QEMU Guest Agent communication. This only creates the socket inside the VM, the Guest Agent itself must be installed and started in the VM.
     */
    guestAgent?: pulumi.Input<string>;
    /**
     * Add hyperv extensions to the VM. The options can be configured in the driver configuration, HYPERV_OPTIONS.
     */
    hyperv?: pulumi.Input<string>;
    /**
     * Number of iothreads for virtio disks. By default threads will be assign to disk by round robin algorithm. Disk thread id can be forced by disk IOTHREAD attribute.
     */
    iothreads?: pulumi.Input<string>;
    /**
     * The guest clock will be synchronized to the host’s configured timezone when booted. Useful for Windows VMs.
     */
    localtime?: pulumi.Input<string>;
    /**
     * Physical address extension mode allows 32-bit guests to address more than 4 GB of memory.
     */
    pae?: pulumi.Input<string>;
    /**
     * Numer of vCPU queues for the virtio-scsi controller.
     */
    virtioScsiQueues?: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateGraphics {
    keymap?: pulumi.Input<string>;
    listen: pulumi.Input<string>;
    passwd?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    randomPasswd?: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateOs {
    arch: pulumi.Input<string>;
    boot: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: pulumi.Input<string>;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}

export interface VirtualRouterInstanceTemplateVmgroup {
    role: pulumi.Input<string>;
    vmgroupId: pulumi.Input<number>;
}

export interface VirtualRouterInstanceTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface VirtualRouterInstanceVmgroup {
    role: pulumi.Input<string>;
    vmgroupId: pulumi.Input<number>;
}

export interface VirtualRouterNicTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface VirtualRouterTemplateSection {
    elements?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
}
export namespace config {
}
