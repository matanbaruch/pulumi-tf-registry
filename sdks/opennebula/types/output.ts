// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface DatastoreCeph {
    /**
     * Non-default Ceph configuration file if needed
     */
    config?: string;
    /**
     * List of Ceph monitors
     */
    hosts?: string[];
    /**
     * Key file for user. if not set default locations are used
     */
    key?: string;
    /**
     * Use local host storage, SSH mode
     */
    localStorage?: boolean;
    /**
     * Ceph pool name
     */
    poolName?: string;
    /**
     * By default RBD Format 2 will be used
     */
    rbdFormat?: string;
    /**
     * The UUID of the libvirt secret
     */
    secret?: string;
    /**
     * Enables trash feature on given datastore
     */
    trash?: boolean;
    /**
     * Ceph user name
     */
    user?: string;
}

export interface DatastoreCustom {
    /**
     * Datastore driver
     */
    datastore?: string;
    /**
     * Transfer driver
     */
    transfer: string;
}

export interface GetTemplateDisk {
    cache: string;
    devPrefix: string;
    discard: string;
    driver: string;
    imageId: number;
    io: string;
    size: number;
    target: string;
    volatileFormat: string;
    volatileType: string;
}

export interface GetTemplateNic {
    ip: string;
    mac: string;
    model: string;
    network: string;
    networkId: number;
    networkModeAuto: boolean;
    physicalDevice: string;
    schedRank: string;
    schedRequirements: string;
    securityGroups: number[];
    virtioQueues: string;
}

export interface GetTemplateVmgroup {
    role: string;
    vmgroupId: number;
}

export interface GetTemplatesTemplate {
    cpu: number;
    disks: outputs.GetTemplatesTemplateDisk[];
    id: number;
    memory: number;
    name: string;
    nics: outputs.GetTemplatesTemplateNic[];
    registerDate: number;
    tags: {[key: string]: string};
    vcpu: number;
    vmgroups: outputs.GetTemplatesTemplateVmgroup[];
}

export interface GetTemplatesTemplateDisk {
    cache: string;
    devPrefix: string;
    discard: string;
    driver: string;
    imageId: number;
    io: string;
    size: number;
    target: string;
    volatileFormat: string;
    volatileType: string;
}

export interface GetTemplatesTemplateNic {
    ip: string;
    mac: string;
    model: string;
    network: string;
    networkId: number;
    networkModeAuto: boolean;
    physicalDevice: string;
    schedRank: string;
    schedRequirements: string;
    securityGroups: number[];
    virtioQueues: string;
}

export interface GetTemplatesTemplateVmgroup {
    role: string;
    vmgroupId: number;
}

export interface GroupOpennebula {
    /**
     * Sets order of elements by ID in list API calls: ASC or DESC respectively for ascending or descending order
     */
    apiListOrder?: string;
    /**
     * Control the default value for the PERSISTENT attribute on image creation ( clone and disk save-as): should be YES or NO
     */
    defaultImagePersistent?: string;
    /**
     * Control the default value for the PERSISTENT attribute on image creation ( only new images): should be YES or NO
     */
    defaultImagePersistentNew?: string;
}

export interface GroupQuota {
    /**
     * Datastore quotas
     */
    datastoreQuotas?: outputs.GroupQuotaDatastoreQuota[];
    /**
     * Image quotas
     */
    imageQuotas?: outputs.GroupQuotaImageQuota[];
    /**
     * Network quotas
     */
    networkQuotas?: outputs.GroupQuotaNetworkQuota[];
    /**
     * VM quotas
     */
    vmQuotas?: outputs.GroupQuotaVmQuota[];
}

export interface GroupQuotaDatastoreQuota {
    /**
     * Datastore ID
     */
    id: number;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: number;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: number;
}

export interface GroupQuotaImageQuota {
    /**
     * Image ID
     */
    id: number;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: number;
}

export interface GroupQuotaNetworkQuota {
    /**
     * Network ID
     */
    id: number;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: number;
}

export interface GroupQuotaVmQuota {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: number;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: number;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: number;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: number;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: number;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: number;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: number;
}

export interface GroupQuotasDatastore {
    /**
     * Datastore ID
     */
    id: number;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: number;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: number;
}

export interface GroupQuotasImage {
    /**
     * Image ID
     */
    id: number;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: number;
}

export interface GroupQuotasNetwork {
    /**
     * Network ID
     */
    id: number;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: number;
}

export interface GroupQuotasVm {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: number;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: number;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: number;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: number;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: number;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: number;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: number;
}

export interface GroupSunstone {
    /**
     * Default Sunstone view for regular users
     */
    defaultView?: string;
    /**
     * Default Sunstone view for group admin users
     */
    groupAdminDefaultView?: string;
    /**
     * List of available views for the group admins
     */
    groupAdminViews?: string;
    /**
     * List of available views for regular users
     */
    views?: string;
}

export interface GroupTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface HostCustom {
    /**
     * Information driver
     */
    information?: string;
    /**
     * Virtualization driver
     */
    virtualization?: string;
}

export interface HostOvercommit {
    /**
     * Maximum allocatable CPU capacity in number of cores multiplied by 100
     */
    cpu?: number;
    /**
     * Maximum allocatable memory capacity in KB
     */
    memory?: number;
}

export interface HostTimeouts {
    create?: string;
    delete?: string;
}

export interface ImageTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface ImageTimeouts {
    create?: string;
    delete?: string;
}

export interface MarketplaceApplianceTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface MarketplaceApplianceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MarketplaceHttp {
    /**
     * Base URL of the Marketplace HTTP endpoint
     */
    endpointUrl: string;
    /**
     * Absolute directory path to place images in the front-end or in the hosts pointed at by storage_bridge_list
     */
    path: string;
    /**
     * List of servers to access the public directory
     */
    storageBridgeLists?: string[];
}

export interface MarketplaceLxc {
    /**
     * VM template CPU
     */
    cpu?: number;
    /**
     * The base URL of the Market
     */
    endpointUrl?: string;
    /**
     * Filesystem used for the image
     */
    filesystem?: string;
    /**
     * Image block file format
     */
    imageBlockFileFormat?: string;
    /**
     * VM template memory
     */
    memory?: number;
    /**
     * Secrurity mode of the Linux Container
     */
    privileged?: boolean;
    /**
     * Size in MB for the image holding the rootfs
     */
    roofsImageSize?: number;
    /**
     * Include only apps with support for context
     */
    skipUntested?: boolean;
    /**
     * VM template VCPU
     */
    vcpu?: number;
}

export interface MarketplaceOne {
    /**
     * The marketplace endpoint url
     */
    endpointUrl?: string;
}

export interface MarketplaceS3 {
    /**
     * The access key of the S3 user
     */
    accessKeyId: string;
    /**
     * The bucket where the files will be stored
     */
    bucket: string;
    /**
     * Only required when connecteing to a service other than Amazon S3
     */
    endpointUrl?: string;
    /**
     * Split the file into chunks of this size in MB
     */
    readBlockLength?: number;
    /**
     * The region to connect to. Any value will work with Ceph-S3
     */
    region: string;
    /**
     * The secret key of the S3 user
     */
    secretAccessKey: string;
    /**
     * Define the total size of the marketplace in MB.
     */
    totalSize?: number;
    /**
     * Type of the s3 backend: aws, ceph, minio
     */
    type?: string;
}

export interface MarketplaceTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface MarketplaceTimeouts {
    create?: string;
    update?: string;
}

export interface MarketplaceTurnkey {
    /**
     * The base URL of the Market
     */
    endpointUrl?: string;
    /**
     * Filesystem used for the image
     */
    filesystem?: string;
    /**
     * Image block file format
     */
    imageBlockFileFormat?: string;
    /**
     * Size in MB for the image holding the rootfs
     */
    roofsImageSize?: number;
    /**
     * Include only apps with support for context
     */
    skipUntested?: boolean;
}

export interface SecurityGroupRule {
    /**
     * Type of ICMP traffic to apply to when 'protocol' is ICMP
     */
    icmpType: string;
    /**
     * IP (or starting IP if used with 'size') to apply the rule to
     */
    ip: string;
    /**
     * VNET ID to be used as the source/destination IP addresses
     */
    networkId: string;
    /**
     * Protocol for the rule, must be one of: ALL, TCP, UDP, ICMP or IPSEC
     */
    protocol: string;
    /**
     * Comma separated list of ports and port ranges
     */
    range: string;
    /**
     * Direction of the traffic flow to allow, must be INBOUND or OUTBOUND
     */
    ruleType: string;
    /**
     * Number of IPs to apply the rule from, starting with 'ip'
     */
    size: string;
}

export interface SecurityGroupTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface ServiceRole {
    cardinality: number;
    name: string;
    nodes: number[];
    state: number;
}

export interface ServiceTimeouts {
    create?: string;
    delete?: string;
}

export interface TemplateCpumodel {
    model: string;
}

export interface TemplateDisk {
    cache?: string;
    devPrefix?: string;
    discard?: string;
    driver?: string;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: number;
    io?: string;
    size?: number;
    target?: string;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: string;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: string;
}

export interface TemplateFeature {
    /**
     * Useful for power management, for example, with KVM guests it is required for graceful shutdown to work.
     */
    acpi?: string;
    /**
     * Enables the advanced programmable IRQ management. Useful for SMP machines.
     */
    apic?: string;
    /**
     * Enables the QEMU Guest Agent communication. This only creates the socket inside the VM, the Guest Agent itself must be installed and started in the VM.
     */
    guestAgent?: string;
    /**
     * Add hyperv extensions to the VM. The options can be configured in the driver configuration, HYPERV_OPTIONS.
     */
    hyperv?: string;
    /**
     * Number of iothreads for virtio disks. By default threads will be assign to disk by round robin algorithm. Disk thread id can be forced by disk IOTHREAD attribute.
     */
    iothreads?: string;
    /**
     * The guest clock will be synchronized to the host’s configured timezone when booted. Useful for Windows VMs.
     */
    localtime?: string;
    /**
     * Physical address extension mode allows 32-bit guests to address more than 4 GB of memory.
     */
    pae?: string;
    /**
     * Numer of vCPU queues for the virtio-scsi controller.
     */
    virtioScsiQueues?: string;
}

export interface TemplateGraphics {
    keymap?: string;
    listen: string;
    passwd?: string;
    port: string;
    randomPasswd?: boolean;
    type: string;
}

export interface TemplateNic {
    ip?: string;
    mac?: string;
    model?: string;
    network: string;
    networkId?: number;
    networkModeAuto?: boolean;
    physicalDevice?: string;
    schedRank?: string;
    schedRequirements?: string;
    securityGroups?: number[];
    /**
     * Only if model is virtio
     */
    virtioQueues?: string;
}

export interface TemplateOs {
    arch: string;
    boot: string;
}

export interface TemplateRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: string;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: string;
}

export interface TemplateTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface TemplateVmgroup {
    role: string;
    vmgroupId: number;
}

export interface UserQuota {
    /**
     * Datastore quotas
     */
    datastoreQuotas?: outputs.UserQuotaDatastoreQuota[];
    /**
     * Image quotas
     */
    imageQuotas?: outputs.UserQuotaImageQuota[];
    /**
     * Network quotas
     */
    networkQuotas?: outputs.UserQuotaNetworkQuota[];
    /**
     * VM quotas
     */
    vmQuotas?: outputs.UserQuotaVmQuota[];
}

export interface UserQuotaDatastoreQuota {
    /**
     * Datastore ID
     */
    id: number;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: number;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: number;
}

export interface UserQuotaImageQuota {
    /**
     * Image ID
     */
    id: number;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: number;
}

export interface UserQuotaNetworkQuota {
    /**
     * Network ID
     */
    id: number;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: number;
}

export interface UserQuotaVmQuota {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: number;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: number;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: number;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: number;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: number;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: number;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: number;
}

export interface UserQuotasDatastore {
    /**
     * Datastore ID
     */
    id: number;
    /**
     * Maximum number of Images allowed (default: default quota)
     */
    images?: number;
    /**
     * Maximum size in MB allowed on the datastore (default: default quota)
     */
    size?: number;
}

export interface UserQuotasImage {
    /**
     * Image ID
     */
    id: number;
    /**
     * Maximum number of Running VMs allowed for this image (default: default quota)
     */
    runningVms?: number;
}

export interface UserQuotasNetwork {
    /**
     * Network ID
     */
    id: number;
    /**
     * Maximum number of Leases allowed for this network (default: default quota)
     */
    leases?: number;
}

export interface UserQuotasVm {
    /**
     * Maximum number of CPU allowed (default: default quota)
     */
    cpu?: number;
    /**
     * Maximum Memory (MB) allowed (default: default quota)
     */
    memory?: number;
    /**
     * Maximum number of 'running' CPUs allowed (default: default quota)
     */
    runningCpu?: number;
    /**
     * 'Running' Memory (MB) allowed (default: default quota)
     */
    runningMemory?: number;
    /**
     * Maximum number of Running VMs allowed (default: default quota)
     */
    runningVms?: number;
    /**
     * Maximum System Disk size (MB) allowed (default: default quota)
     */
    systemDiskSize?: number;
    /**
     * Maximum number of VMs allowed (default: default quota)
     */
    vms?: number;
}

export interface UserTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface VirtualDataCenterZone {
    /**
     * List of cluster IDs from the Zone to add in the VDC
     */
    clusterIds: number[];
    /**
     * List of Datastore IDs from the Zone to add in the VDC
     */
    datastoreIds: number[];
    /**
     * List of Host IDs from the Zone to add in the VDC
     */
    hostIds: number[];
    /**
     * Resources Zone ID (default: 0)
     */
    id?: number;
    /**
     * List of VNET IDs from the Zone to add in the VDC
     */
    vnetIds: number[];
}

export interface VirtualMachineCpumodel {
    model: string;
}

export interface VirtualMachineDisk {
    cache?: string;
    computedCache: string;
    computedDevPrefix: string;
    computedDiscard: string;
    computedDriver: string;
    computedIo: string;
    computedSize: number;
    computedTarget: string;
    computedVolatileFormat: string;
    devPrefix?: string;
    discard?: string;
    diskId: number;
    driver?: string;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: number;
    io?: string;
    size?: number;
    target?: string;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: string;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: string;
}

export interface VirtualMachineGraphics {
    keymap?: string;
    listen: string;
    passwd?: string;
    port: string;
    randomPasswd?: boolean;
    type: string;
}

export interface VirtualMachineGroupRole {
    /**
     * Host(s) where the VM should run
     */
    hostAffineds: number[];
    /**
     * Host(s) where the VM should not run
     */
    hostAntiAffineds: number[];
    id: number;
    name: string;
    policy: string;
}

export interface VirtualMachineGroupTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface VirtualMachineNic {
    computedIp: string;
    computedMac: string;
    computedModel: string;
    computedPhysicalDevice: string;
    computedSecurityGroups: number[];
    computedVirtioQueues: string;
    ip?: string;
    mac?: string;
    model?: string;
    network: string;
    networkId?: number;
    networkModeAuto?: boolean;
    nicId: number;
    physicalDevice?: string;
    schedRank?: string;
    schedRequirements?: string;
    securityGroups?: number[];
    /**
     * Only if model is virtio
     */
    virtioQueues?: string;
}

export interface VirtualMachineOs {
    arch: string;
    boot: string;
}

export interface VirtualMachineRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: string;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: string;
}

export interface VirtualMachineTemplateDisk {
    computedCache: string;
    computedDevPrefix: string;
    computedDiscard: string;
    computedDriver: string;
    computedIo: string;
    computedSize: number;
    computedTarget: string;
    computedVolatileFormat: string;
    diskId: number;
    imageId: number;
}

export interface VirtualMachineTemplateNic {
    computedIp: string;
    computedMac: string;
    computedModel: string;
    computedPhysicalDevice: string;
    computedSecurityGroups: number[];
    computedVirtioQueues: string;
    network: string;
    networkId: number;
    nicId: number;
}

export interface VirtualMachineTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface VirtualMachineTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VirtualMachineVmgroup {
    role: string;
    vmgroupId: number;
}

export interface VirtualNetworkAddressRangeTimeouts {
    create?: string;
    delete?: string;
}

export interface VirtualNetworkAr {
    /**
     * Type of the Address Range: IP4, IP6. Default is 'IP4'
     */
    arType?: string;
    /**
     * Global prefix for IP6 or IP4_6
     */
    computedGlobalPrefix: string;
    /**
     * Start IPv6 of the range to be allocated (Required if IP6_STATIC or IP4_6_STATIC)
     */
    computedIp6: string;
    /**
     * Start MAC of the range to be allocated
     */
    computedMac: string;
    /**
     * ULA prefix for IP6 or IP4_6
     */
    computedUlaPrefix: string;
    /**
     * Global prefix for IP6 or IP4_6
     */
    globalPrefix?: string;
    id: string;
    /**
     * Start IPv4 of the range to be allocated (Required if IP4 or IP4_6).
     */
    ip4?: string;
    /**
     * Start IPv6 of the range to be allocated (Required if IP6_STATIC or IP4_6_STATIC)
     */
    ip6?: string;
    /**
     * Start MAC of the range to be allocated
     */
    mac?: string;
    /**
     * Prefix lenght Only needed for IP6_STATIC or IP4_6_STATIC
     */
    prefixLength?: string;
    /**
     * Size (in number) of the ip range
     */
    size: number;
    /**
     * ULA prefix for IP6 or IP4_6
     */
    ulaPrefix?: string;
}

export interface VirtualNetworkTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface VirtualNetworkTimeouts {
    create?: string;
}

export interface VirtualRouterInstanceCpumodel {
    model: string;
}

export interface VirtualRouterInstanceDisk {
    cache?: string;
    computedCache: string;
    computedDevPrefix: string;
    computedDiscard: string;
    computedDriver: string;
    computedIo: string;
    computedSize: number;
    computedTarget: string;
    computedVolatileFormat: string;
    devPrefix?: string;
    discard?: string;
    diskId: number;
    driver?: string;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: number;
    io?: string;
    size?: number;
    target?: string;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: string;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: string;
}

export interface VirtualRouterInstanceGraphics {
    keymap?: string;
    listen: string;
    passwd?: string;
    port: string;
    randomPasswd?: boolean;
    type: string;
}

export interface VirtualRouterInstanceOs {
    arch: string;
    boot: string;
}

export interface VirtualRouterInstanceRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: string;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: string;
}

export interface VirtualRouterInstanceTemplateCpumodel {
    model: string;
}

export interface VirtualRouterInstanceTemplateDisk {
    cache?: string;
    devPrefix?: string;
    discard?: string;
    driver?: string;
    /**
     * Image Id  of the image to attach to the VM. Defaults to -1: no image attached.
     */
    imageId?: number;
    io?: string;
    size?: number;
    target?: string;
    /**
     * Format of the volatile disk: raw or qcow2.
     */
    volatileFormat?: string;
    /**
     * Type of the volatile disk: swap or fs.
     */
    volatileType?: string;
}

export interface VirtualRouterInstanceTemplateFeature {
    /**
     * Useful for power management, for example, with KVM guests it is required for graceful shutdown to work.
     */
    acpi?: string;
    /**
     * Enables the advanced programmable IRQ management. Useful for SMP machines.
     */
    apic?: string;
    /**
     * Enables the QEMU Guest Agent communication. This only creates the socket inside the VM, the Guest Agent itself must be installed and started in the VM.
     */
    guestAgent?: string;
    /**
     * Add hyperv extensions to the VM. The options can be configured in the driver configuration, HYPERV_OPTIONS.
     */
    hyperv?: string;
    /**
     * Number of iothreads for virtio disks. By default threads will be assign to disk by round robin algorithm. Disk thread id can be forced by disk IOTHREAD attribute.
     */
    iothreads?: string;
    /**
     * The guest clock will be synchronized to the host’s configured timezone when booted. Useful for Windows VMs.
     */
    localtime?: string;
    /**
     * Physical address extension mode allows 32-bit guests to address more than 4 GB of memory.
     */
    pae?: string;
    /**
     * Numer of vCPU queues for the virtio-scsi controller.
     */
    virtioScsiQueues?: string;
}

export interface VirtualRouterInstanceTemplateGraphics {
    keymap?: string;
    listen: string;
    passwd?: string;
    port: string;
    randomPasswd?: boolean;
    type: string;
}

export interface VirtualRouterInstanceTemplateOs {
    arch: string;
    boot: string;
}

export interface VirtualRouterInstanceTemplateRaw {
    /**
     * Low-level data to pass to the hypervisor
     */
    data: string;
    /**
     * Name of the hypervisor: kvm, lxd, vmware
     */
    type: string;
}

export interface VirtualRouterInstanceTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface VirtualRouterInstanceTemplateTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export interface VirtualRouterInstanceTemplateVmgroup {
    role: string;
    vmgroupId: number;
}

export interface VirtualRouterInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VirtualRouterInstanceVmgroup {
    role: string;
    vmgroupId: number;
}

export interface VirtualRouterNicTimeouts {
    create?: string;
    delete?: string;
}

export interface VirtualRouterTemplateSection {
    elements?: {[key: string]: string};
    name: string;
}

export namespace config {
    export interface DefaultTags {
        /**
         * Default tags to apply
         */
        tags?: {[key: string]: string};
    }

}
