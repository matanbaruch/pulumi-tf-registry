// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ActiongroupconfigConfigpbAttribute {
    version: string;
}

export interface AlbservicesconfigAppSignatureConfig {
    appSignatureSyncInterval?: string;
}

export interface AlbservicesconfigAssetContact {
    accountId: string;
    accountName: string;
    email: string;
    managedAccounts?: outputs.AlbservicesconfigAssetContactManagedAccount[];
    name: string;
    phone: string;
}

export interface AlbservicesconfigAssetContactManagedAccount {
    id: string;
    name: string;
    users?: outputs.AlbservicesconfigAssetContactManagedAccountUser[];
}

export interface AlbservicesconfigAssetContactManagedAccountUser {
    email: string;
    name: string;
    phone: string;
}

export interface AlbservicesconfigCaseConfig {
    additionalEmails?: string[];
    enableAutoCaseCreationOnControllerFailure?: string;
    enableAutoCaseCreationOnSeFailure?: string;
    enableCleanupOfAttachedFiles?: string;
}

export interface AlbservicesconfigConfigpbAttribute {
    version: string;
}

export interface AlbservicesconfigFeatureOptInStatus {
    enableAppsignatureSync?: string;
    enableIpReputation?: string;
    enablePulseCaseManagement?: string;
    enablePulseInventory?: string;
    enablePulseWafManagement?: string;
    enableUserAgentDbSync?: string;
}

export interface AlbservicesconfigInventoryConfig {
    enableSearchInfo?: string;
}

export interface AlbservicesconfigIpReputationConfig {
    ipReputationFileObjectExpiryDuration?: string;
    ipReputationSyncInterval?: string;
}

export interface AlbservicesconfigSaasLicensingConfig {
    maxServiceUnits?: string;
    reserveServiceUnits?: string;
}

export interface AlbservicesconfigSessionConfig {
    sessionHeaders?: outputs.AlbservicesconfigSessionConfigSessionHeader[];
}

export interface AlbservicesconfigSessionConfigSessionHeader {
    name: string;
    value: string;
}

export interface AlbservicesconfigSplitProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface AlbservicesconfigTenantConfig {
    heartbeatInterval: string;
    licenseEscrowInterval: string;
    licenseExpiryInterval: string;
    licenseReconcileInterval: string;
    licenseRefreshInterval: string;
    licenseRenewalInterval: string;
    tokenRefreshInterval: string;
}

export interface AlbservicesconfigUserAgentDbConfig {
    allowedBatchSize?: string;
}

export interface AlbservicesconfigWafConfig {
    enableAutoDownloadWafSignatures?: string;
    enableWafSignaturesNotifications?: string;
}

export interface AlbservicesfiledownloadConfigpbAttribute {
    version: string;
}

export interface AlbservicesfiledownloadMetadata {
    checksum: string;
    checksumType: string;
    chunkSize: string;
    isMultiPartDownload: string;
    signedUrl: string;
    totalSize: string;
}

export interface AlbservicesjobConfigpbAttribute {
    version: string;
}

export interface AlbservicesjobEndTime {
    secs: string;
    usecs: string;
}

export interface AlbservicesjobParam {
    key: string;
    value: string;
}

export interface AlbservicesjobStartTime {
    secs: string;
    usecs: string;
}

export interface AlbservicesjobStatusUpdateTime {
    secs: string;
    usecs: string;
}

export interface AlertconfigAlertRule {
    connAppLogRules?: outputs.AlertconfigAlertRuleConnAppLogRule[];
    eventMatchFilter: string;
    metricsRules?: outputs.AlertconfigAlertRuleMetricsRule[];
    operator?: string;
    sysEventRules?: outputs.AlertconfigAlertRuleSysEventRule[];
}

export interface AlertconfigAlertRuleConnAppLogRule {
    filterAction: string;
    filterString: string;
}

export interface AlertconfigAlertRuleMetricsRule {
    duration: string;
    metricId: string;
    metricThresholds: outputs.AlertconfigAlertRuleMetricsRuleMetricThreshold[];
}

export interface AlertconfigAlertRuleMetricsRuleMetricThreshold {
    comparator: string;
    threshold: string;
}

export interface AlertconfigAlertRuleSysEventRule {
    eventDetails?: outputs.AlertconfigAlertRuleSysEventRuleEventDetail[];
    eventId: string;
    notCond?: string;
}

export interface AlertconfigAlertRuleSysEventRuleEventDetail {
    comparator: string;
    eventDetailsKey: string;
    eventDetailsValue: string;
}

export interface AlertconfigConfigpbAttribute {
    version: string;
}

export interface AlertemailconfigConfigpbAttribute {
    version: string;
}

export interface AlertscriptconfigConfigpbAttribute {
    version: string;
}

export interface AlertsyslogconfigConfigpbAttribute {
    version: string;
}

export interface AlertsyslogconfigSyslogServer {
    anonAuth?: string;
    format?: string;
    pkiprofileRef: string;
    sslKeyAndCertificateRef: string;
    strictCertVerify?: string;
    syslogServer: string;
    syslogServerPort?: string;
    tlsEnable?: string;
    udp: string;
}

export interface AnalyticsprofileClientLogConfig {
    enableSignificantLogCollection?: string;
    filteredLogProcessing?: string;
    nonSignificantLogProcessing?: string;
    significantLogProcessing?: string;
}

export interface AnalyticsprofileClientLogStreamingConfig {
    externalServer: string;
    externalServerPort?: string;
    formatConfigs?: outputs.AnalyticsprofileClientLogStreamingConfigFormatConfig[];
    logTypesToSend?: string;
    markerKeys?: outputs.AnalyticsprofileClientLogStreamingConfigMarkerKey[];
    maxLogsPerSecond?: string;
    protocol?: string;
    syslogConfigs?: outputs.AnalyticsprofileClientLogStreamingConfigSyslogConfig[];
}

export interface AnalyticsprofileClientLogStreamingConfigFormatConfig {
    format: string;
    includedFields?: string[];
}

export interface AnalyticsprofileClientLogStreamingConfigMarkerKey {
    key: string;
    values?: string[];
}

export interface AnalyticsprofileClientLogStreamingConfigSyslogConfig {
    facility?: string;
    filteredLogSeverity?: string;
    hostname?: string;
    msgId?: string;
    nonSignificantLogSeverity?: string;
    procId?: string;
    significantLogSeverity?: string;
}

export interface AnalyticsprofileConfigpbAttribute {
    version: string;
}

export interface AnalyticsprofileLatencyAuditProp {
    connEstAuditMode: string;
    connEstThreshold: string;
    latencyAuditMode: string;
    latencyThreshold: string;
}

export interface AnalyticsprofileMarker {
    key: string;
    values?: string[];
}

export interface AnalyticsprofileRange {
    begin: string;
    end: string;
}

export interface AnalyticsprofileSensitiveLogProfile {
    headerFieldRules?: outputs.AnalyticsprofileSensitiveLogProfileHeaderFieldRule[];
    uriQueryFieldRules?: outputs.AnalyticsprofileSensitiveLogProfileUriQueryFieldRule[];
    wafFieldRules?: outputs.AnalyticsprofileSensitiveLogProfileWafFieldRule[];
}

export interface AnalyticsprofileSensitiveLogProfileHeaderFieldRule {
    action?: string;
    enabled?: string;
    index: string;
    matches?: outputs.AnalyticsprofileSensitiveLogProfileHeaderFieldRuleMatch[];
    name: string;
}

export interface AnalyticsprofileSensitiveLogProfileHeaderFieldRuleMatch {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface AnalyticsprofileSensitiveLogProfileUriQueryFieldRule {
    action?: string;
    enabled?: string;
    index: string;
    matches?: outputs.AnalyticsprofileSensitiveLogProfileUriQueryFieldRuleMatch[];
    name: string;
}

export interface AnalyticsprofileSensitiveLogProfileUriQueryFieldRuleMatch {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface AnalyticsprofileSensitiveLogProfileWafFieldRule {
    action?: string;
    enabled?: string;
    index: string;
    matches?: outputs.AnalyticsprofileSensitiveLogProfileWafFieldRuleMatch[];
    name: string;
}

export interface AnalyticsprofileSensitiveLogProfileWafFieldRuleMatch {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface AnalyticsprofileTimeTrackerProp {
    beConnEstAuditMode: string;
    beConnEstThreshold: string;
    feConnEstAuditMode: string;
    feConnEstThreshold: string;
    ingressSigLog: string;
}

export interface ApplicationpersistenceprofileAppCookiePersistenceProfile {
    encryptionKey: string;
    prstHdrName: string;
    timeout?: string;
}

export interface ApplicationpersistenceprofileConfigpbAttribute {
    version: string;
}

export interface ApplicationpersistenceprofileHdrPersistenceProfile {
    prstHdrName: string;
}

export interface ApplicationpersistenceprofileHttpCookiePersistenceProfile {
    alwaysSendCookie?: string;
    cookieName: string;
    encryptionKey: string;
    httpOnly?: string;
    isPersistentCookie?: string;
    keys?: outputs.ApplicationpersistenceprofileHttpCookiePersistenceProfileKey[];
    timeout: string;
}

export interface ApplicationpersistenceprofileHttpCookiePersistenceProfileKey {
    aesKey: string;
    hmacKey: string;
    name: string;
}

export interface ApplicationpersistenceprofileIpPersistenceProfile {
    ipMask: string;
    ipPersistentTimeout?: string;
}

export interface ApplicationpersistenceprofileMarker {
    key: string;
    values?: string[];
}

export interface ApplicationprofileConfigpbAttribute {
    version: string;
}

export interface ApplicationprofileDnsServiceProfile {
    aaaaEmptyResponse?: string;
    adminEmail?: string;
    clientDnsTcpRequestTimeout?: string;
    closeTcpConnectionPostResponse?: string;
    dnsOverTcpEnabled?: string;
    dnsZones?: outputs.ApplicationprofileDnsServiceProfileDnsZone[];
    domainNames?: string[];
    ecsStrippingEnabled?: string;
    edns?: string;
    ednsClientSubnetPrefixLen: string;
    errorResponse?: string;
    nameServer: string;
    negativeCachingTtl?: string;
    numDnsIp?: string;
    ttl?: string;
}

export interface ApplicationprofileDnsServiceProfileDnsZone {
    adminEmail: string;
    domainName: string;
    nameServer: string;
}

export interface ApplicationprofileDosRlProfile {
    dosProfiles?: outputs.ApplicationprofileDosRlProfileDosProfile[];
    rlProfiles?: outputs.ApplicationprofileDosRlProfileRlProfile[];
}

export interface ApplicationprofileDosRlProfileDosProfile {
    threshInfos?: outputs.ApplicationprofileDosRlProfileDosProfileThreshInfo[];
    threshPeriod: string;
}

export interface ApplicationprofileDosRlProfileDosProfileThreshInfo {
    attack: string;
    maxValue: string;
    minValue: string;
}

export interface ApplicationprofileDosRlProfileRlProfile {
    clientIpConnectionsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimit[];
    clientIpFailedRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimit[];
    clientIpRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimit[];
    clientIpScannersRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimit[];
    clientIpToUriFailedRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimit[];
    clientIpToUriRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimit[];
    customRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimit[];
    httpHeaderRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimit[];
    uriFailedRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimit[];
    uriRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimit[];
    uriScannersRequestsRateLimits?: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimit[];
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimit {
    actions: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitRateLimiter[];
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitAction {
    files?: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionFile[];
    redirects?: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHost {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPath {
    tokens: outputs.ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface ApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface ApplicationprofileHttpProfile {
    allowDotsInHeaderName?: string;
    cacheConfigs?: outputs.ApplicationprofileHttpProfileCacheConfig[];
    clientBodyTimeout?: string;
    clientHeaderTimeout?: string;
    clientMaxBodySize?: string;
    clientMaxHeaderSize?: string;
    clientMaxRequestSize?: string;
    closeServerSideConnectionOnError?: string;
    collectClientTlsFingerprint?: string;
    compressionProfiles?: outputs.ApplicationprofileHttpProfileCompressionProfile[];
    connectionMultiplexingEnabled?: string;
    detectNtlmApp?: string;
    disableKeepalivePostsMsie6?: string;
    disableSniHostnameCheck?: string;
    enableChunkMerge?: string;
    enableFireAndForget?: string;
    enableRequestBodyBuffering?: string;
    enableRequestBodyMetrics?: string;
    fwdCloseHdrForBoundConnections?: string;
    hstsEnabled?: string;
    hstsMaxAge?: string;
    hstsSubdomainsEnabled?: string;
    http2Profiles?: outputs.ApplicationprofileHttpProfileHttp2Profile[];
    httpToHttps?: string;
    httpUpstreamBufferSize?: string;
    httponlyEnabled?: string;
    keepaliveHeader?: string;
    keepaliveTimeout?: string;
    maxBadRpsCip?: string;
    maxBadRpsCipUri?: string;
    maxBadRpsUri?: string;
    maxHeaderCount?: string;
    maxKeepaliveRequests?: string;
    maxResponseHeadersSize?: string;
    maxRpsCip?: string;
    maxRpsCipUri?: string;
    maxRpsUnknownCip?: string;
    maxRpsUnknownUri?: string;
    maxRpsUri?: string;
    passThroughXAccelHeaders?: string;
    pkiProfileRef: string;
    postAcceptTimeout?: string;
    resetConnHttpOnSslPort?: string;
    respondWith100Continue?: string;
    secureCookieEnabled?: string;
    serverSideRedirectToHttps?: string;
    sessionConfigs?: outputs.ApplicationprofileHttpProfileSessionConfig[];
    sslClientCertificateActions?: outputs.ApplicationprofileHttpProfileSslClientCertificateAction[];
    sslClientCertificateMode?: string;
    trueClientIps?: outputs.ApplicationprofileHttpProfileTrueClientIp[];
    useAppKeepaliveTimeout?: string;
    useTrueClientIp?: string;
    websocketsEnabled?: string;
    xForwardedProtoEnabled?: string;
    xffAlternateName?: string;
    xffEnabled?: string;
    xffUpdate?: string;
}

export interface ApplicationprofileHttpProfileCacheConfig {
    ageHeader?: string;
    aggressive?: string;
    dateHeader?: string;
    defaultExpire?: string;
    enabled?: string;
    heuristicExpire?: string;
    ignoreRequestCacheControl?: string;
    maxCacheSize?: string;
    maxObjectSize?: string;
    mimeTypesBlockGroupRefs?: string[];
    mimeTypesBlockLists?: string[];
    mimeTypesGroupRefs?: string[];
    mimeTypesLists?: string[];
    minObjectSize?: string;
    queryCacheable?: string;
    uriNonCacheables?: outputs.ApplicationprofileHttpProfileCacheConfigUriNonCacheable[];
    xcacheHeader?: string;
}

export interface ApplicationprofileHttpProfileCacheConfigUriNonCacheable {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface ApplicationprofileHttpProfileCompressionProfile {
    bufNum?: string;
    bufSize?: string;
    compressibleContentRef: string;
    compression: string;
    filters?: outputs.ApplicationprofileHttpProfileCompressionProfileFilter[];
    hashSize?: string;
    levelAggressive?: string;
    levelNormal?: string;
    maxLowRtt?: string;
    minHighRtt?: string;
    minLength?: string;
    mobileStrRef: string;
    removeAcceptEncodingHeader: string;
    type: string;
    windowSize?: string;
}

export interface ApplicationprofileHttpProfileCompressionProfileFilter {
    devicesRef: string;
    index: string;
    ipAddrPrefixes?: outputs.ApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefix[];
    ipAddrRanges?: outputs.ApplicationprofileHttpProfileCompressionProfileFilterIpAddrRange[];
    ipAddrs?: outputs.ApplicationprofileHttpProfileCompressionProfileFilterIpAddr[];
    ipAddrsRef: string;
    level: string;
    match?: string;
    name: string;
    userAgents?: string[];
}

export interface ApplicationprofileHttpProfileCompressionProfileFilterIpAddr {
    addr: string;
    type: string;
}

export interface ApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefix {
    ipAddrs: outputs.ApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefixIpAddr[];
    mask: string;
}

export interface ApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefixIpAddr {
    addr: string;
    type: string;
}

export interface ApplicationprofileHttpProfileCompressionProfileFilterIpAddrRange {
    begins: outputs.ApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeBegin[];
    ends: outputs.ApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeEnd[];
}

export interface ApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeBegin {
    addr: string;
    type: string;
}

export interface ApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeEnd {
    addr: string;
    type: string;
}

export interface ApplicationprofileHttpProfileHttp2Profile {
    enableHttp2ServerPush?: string;
    http2InitialWindowSize?: string;
    maxHttp2ConcurrentPushesPerConnection?: string;
    maxHttp2ConcurrentStreamsPerConnection?: string;
    maxHttp2ControlFramesPerConnection?: string;
    maxHttp2EmptyDataFramesPerConnection?: string;
    maxHttp2HeaderFieldSize?: string;
    maxHttp2QueuedFramesToClientPerConnection?: string;
    maxHttp2RequestsPerConnection?: string;
}

export interface ApplicationprofileHttpProfileSessionConfig {
    sessionCookieHttponly?: string;
    sessionCookieName?: string;
    sessionCookieSamesite?: string;
    sessionCookieSecure?: string;
    sessionEstablishmentTimeout?: string;
    sessionIdleTimeout?: string;
    sessionMaximumTimeout?: string;
}

export interface ApplicationprofileHttpProfileSslClientCertificateAction {
    closeConnection?: string;
    headers?: outputs.ApplicationprofileHttpProfileSslClientCertificateActionHeader[];
}

export interface ApplicationprofileHttpProfileSslClientCertificateActionHeader {
    requestHeader: string;
    requestHeaderValue: string;
}

export interface ApplicationprofileHttpProfileTrueClientIp {
    direction?: string;
    headers?: string[];
    indexInHeader?: string;
}

export interface ApplicationprofileL4SslProfile {
    sslStreamIdleTimeout?: string;
}

export interface ApplicationprofileMarker {
    key: string;
    values?: string[];
}

export interface ApplicationprofileSipServiceProfile {
    transactionTimeout?: string;
}

export interface ApplicationprofileTcpAppProfile {
    ftpProfiles?: outputs.ApplicationprofileTcpAppProfileFtpProfile[];
    pkiProfileRef: string;
    proxyProtocolEnabled?: string;
    proxyProtocolVersion?: string;
    sslClientCertificateMode?: string;
}

export interface ApplicationprofileTcpAppProfileFtpProfile {
    deactivateActive?: string;
    deactivatePassive?: string;
}

export interface AuthmappingprofileConfigpbAttribute {
    version: string;
}

export interface AuthmappingprofileMappingRule {
    assignPolicy: string;
    assignRole: string;
    assignTenant: string;
    assignUserprofile: string;
    attributeMatches?: outputs.AuthmappingprofileMappingRuleAttributeMatch[];
    defaultTenantRef: string;
    groupMatches?: outputs.AuthmappingprofileMappingRuleGroupMatch[];
    index: string;
    isSuperuser: string;
    policyAttributeName: string;
    roleAttributeName: string;
    roleRefs?: string[];
    tenantAttributeName: string;
    tenantRefs?: string[];
    userprofileAttributeName: string;
    userprofileRef: string;
}

export interface AuthmappingprofileMappingRuleAttributeMatch {
    criteria: string;
    name: string;
    values?: string[];
}

export interface AuthmappingprofileMappingRuleGroupMatch {
    criteria: string;
    groups?: string[];
}

export interface AuthprofileConfigpbAttribute {
    version: string;
}

export interface AuthprofileHttp {
    cacheExpirationTime?: string;
    requestHeader: string;
    requireUserGroups?: string[];
}

export interface AuthprofileLdap {
    baseDn: string;
    bindAsAdministrator?: string;
    emailAttribute?: string;
    fullNameAttribute?: string;
    port?: string;
    securityMode?: string;
    servers: string[];
    settings?: outputs.AuthprofileLdapSetting[];
    userBinds?: outputs.AuthprofileLdapUserBind[];
}

export interface AuthprofileLdapSetting {
    adminBindDn: string;
    groupFilter?: string;
    groupMemberAttribute?: string;
    groupMemberIsFullDn?: string;
    groupSearchDn: string;
    groupSearchScope?: string;
    ignoreReferrals?: string;
    password: string;
    userAttributes?: string[];
    userIdAttribute: string;
    userSearchDn: string;
    userSearchScope?: string;
}

export interface AuthprofileLdapUserBind {
    dnTemplate: string;
    token?: string;
    userAttributes?: string[];
    userIdAttribute: string;
}

export interface AuthprofileMarker {
    key: string;
    values?: string[];
}

export interface AuthprofileOauthProfile {
    authorizationEndpoint: string;
    endSessionEndpoint: string;
    instanceId: string;
    introspectionEndpoint: string;
    issuer: string;
    jwksTimeout?: string;
    jwksUri: string;
    oauthControllerSettings?: outputs.AuthprofileOauthProfileOauthControllerSetting[];
    oauthProfileType?: string;
    oauthProvider: string;
    oauthRespBufferSz?: string;
    orgId: string;
    poolRef: string;
    redirectUri: string;
    serviceId: string;
    serviceName: string;
    tokenEndpoint: string;
    userinfoEndpoint: string;
}

export interface AuthprofileOauthProfileOauthControllerSetting {
    clientId: string;
    clientSecret: string;
    oidcConfigs?: outputs.AuthprofileOauthProfileOauthControllerSettingOidcConfig[];
    scopes?: string[];
}

export interface AuthprofileOauthProfileOauthControllerSettingOidcConfig {
    oidcEnable: string;
    profile?: string;
    userinfo: string;
}

export interface AuthprofileSaml {
    idps: outputs.AuthprofileSamlIdp[];
    sps: outputs.AuthprofileSamlSp[];
}

export interface AuthprofileSamlIdp {
    metaDataDownloadInterval?: string;
    metadata: string;
    metadataUrl: string;
    periodicDownload?: string;
}

export interface AuthprofileSamlSp {
    fqdn: string;
    orgDisplayName: string;
    orgName: string;
    orgUrl: string;
    samlEntityType: string;
    spNodes?: outputs.AuthprofileSamlSpSpNode[];
    techContactEmail: string;
    techContactName: string;
}

export interface AuthprofileSamlSpSpNode {
    entityId: string;
    name: string;
    signingSslKeyAndCertificateRef: string;
    singleSignonUrl: string;
}

export interface AuthprofileTacacsPlus {
    authorizationAttrs?: outputs.AuthprofileTacacsPlusAuthorizationAttr[];
    password: string;
    port?: string;
    servers: string[];
    service?: string;
}

export interface AuthprofileTacacsPlusAuthorizationAttr {
    mandatory: string;
    name: string;
    value: string;
}

export interface AutoscalelaunchconfigConfigpbAttribute {
    version: string;
}

export interface AutoscalelaunchconfigMarker {
    key: string;
    values?: string[];
}

export interface AutoscalelaunchconfigMeso {
    force?: string;
}

export interface AutoscalelaunchconfigOpenstack {
    heatScaleDownUrl: string;
    heatScaleUpUrl: string;
}

export interface AvailabilityzoneConfigpbAttribute {
    version: string;
}

export interface BackupconfigurationConfigpbAttribute {
    version: string;
}

export interface BotdetectionpolicyAllowList {
    rules?: outputs.BotdetectionpolicyAllowListRule[];
}

export interface BotdetectionpolicyAllowListRule {
    action: string;
    conditions: outputs.BotdetectionpolicyAllowListRuleCondition[];
    index: string;
    name: string;
}

export interface BotdetectionpolicyAllowListRuleCondition {
    botDetectionResults?: outputs.BotdetectionpolicyAllowListRuleConditionBotDetectionResult[];
    clientIps?: outputs.BotdetectionpolicyAllowListRuleConditionClientIp[];
    cookies?: outputs.BotdetectionpolicyAllowListRuleConditionCookie[];
    geoMatches?: outputs.BotdetectionpolicyAllowListRuleConditionGeoMatch[];
    hdrs?: outputs.BotdetectionpolicyAllowListRuleConditionHdr[];
    hostHdrs?: outputs.BotdetectionpolicyAllowListRuleConditionHostHdr[];
    ipReputationTypes?: outputs.BotdetectionpolicyAllowListRuleConditionIpReputationType[];
    methods?: outputs.BotdetectionpolicyAllowListRuleConditionMethod[];
    paths?: outputs.BotdetectionpolicyAllowListRuleConditionPath[];
    protocols?: outputs.BotdetectionpolicyAllowListRuleConditionProtocol[];
    queries?: outputs.BotdetectionpolicyAllowListRuleConditionQuery[];
    sourceIps?: outputs.BotdetectionpolicyAllowListRuleConditionSourceIp[];
    tlsFingerprintMatches?: outputs.BotdetectionpolicyAllowListRuleConditionTlsFingerprintMatch[];
    versions?: outputs.BotdetectionpolicyAllowListRuleConditionVersion[];
    vsPorts?: outputs.BotdetectionpolicyAllowListRuleConditionVsPort[];
}

export interface BotdetectionpolicyAllowListRuleConditionBotDetectionResult {
    classifications?: outputs.BotdetectionpolicyAllowListRuleConditionBotDetectionResultClassification[];
    matchOperation: string;
}

export interface BotdetectionpolicyAllowListRuleConditionBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface BotdetectionpolicyAllowListRuleConditionClientIp {
    addrs?: outputs.BotdetectionpolicyAllowListRuleConditionClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.BotdetectionpolicyAllowListRuleConditionClientIpPrefix[];
    ranges?: outputs.BotdetectionpolicyAllowListRuleConditionClientIpRange[];
}

export interface BotdetectionpolicyAllowListRuleConditionClientIpAddr {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionClientIpPrefix {
    ipAddrs: outputs.BotdetectionpolicyAllowListRuleConditionClientIpPrefixIpAddr[];
    mask: string;
}

export interface BotdetectionpolicyAllowListRuleConditionClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionClientIpRange {
    begins: outputs.BotdetectionpolicyAllowListRuleConditionClientIpRangeBegin[];
    ends: outputs.BotdetectionpolicyAllowListRuleConditionClientIpRangeEnd[];
}

export interface BotdetectionpolicyAllowListRuleConditionClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionCookie {
    matchCase?: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface BotdetectionpolicyAllowListRuleConditionGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionMethod {
    matchCriteria: string;
    methods: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface BotdetectionpolicyAllowListRuleConditionQuery {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionSourceIp {
    addrs?: outputs.BotdetectionpolicyAllowListRuleConditionSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.BotdetectionpolicyAllowListRuleConditionSourceIpPrefix[];
    ranges?: outputs.BotdetectionpolicyAllowListRuleConditionSourceIpRange[];
}

export interface BotdetectionpolicyAllowListRuleConditionSourceIpAddr {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionSourceIpPrefix {
    ipAddrs: outputs.BotdetectionpolicyAllowListRuleConditionSourceIpPrefixIpAddr[];
    mask: string;
}

export interface BotdetectionpolicyAllowListRuleConditionSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionSourceIpRange {
    begins: outputs.BotdetectionpolicyAllowListRuleConditionSourceIpRangeBegin[];
    ends: outputs.BotdetectionpolicyAllowListRuleConditionSourceIpRangeEnd[];
}

export interface BotdetectionpolicyAllowListRuleConditionSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface BotdetectionpolicyAllowListRuleConditionTlsFingerprintMatch {
    fingerprints?: string[];
    matchOperation: string;
    stringGroupRefs?: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionVersion {
    matchCriteria: string;
    versions: string[];
}

export interface BotdetectionpolicyAllowListRuleConditionVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface BotdetectionpolicyClientBehaviorDetector {
    badRequestPercent?: string;
    enabled?: string;
    minimumRequests?: string;
    minimumRequestsWithReferer?: string;
}

export interface BotdetectionpolicyIpLocationDetector {
    enabled?: string;
    ipLocationDbRef: string;
    systemCloudProvidersRef: string;
    systemSearchEnginesRef: string;
}

export interface BotdetectionpolicyIpReputationDetector {
    enabled?: string;
    ipReputationDbRef: string;
    systemIpReputationMappingRef: string;
}

export interface BotdetectionpolicyUserAgentDetector {
    enabled?: string;
    useTlsFingerprint?: string;
}

export interface BotipreputationtypemappingIpReputationMapping {
    botIdentifications: outputs.BotipreputationtypemappingIpReputationMappingBotIdentification[];
    ipReputationType: string;
}

export interface BotipreputationtypemappingIpReputationMappingBotIdentification {
    class: string;
    identifier: string;
    type: string;
}

export interface BotmappingMappingRule {
    classifications: outputs.BotmappingMappingRuleClassification[];
    index: string;
    matches: outputs.BotmappingMappingRuleMatch[];
    name: string;
}

export interface BotmappingMappingRuleClassification {
    type: string;
    userDefinedType: string;
}

export interface BotmappingMappingRuleMatch {
    classMatchers?: outputs.BotmappingMappingRuleMatchClassMatcher[];
    clientIps?: outputs.BotmappingMappingRuleMatchClientIp[];
    componentMatcher: string;
    hdrs?: outputs.BotmappingMappingRuleMatchHdr[];
    hostHdrs?: outputs.BotmappingMappingRuleMatchHostHdr[];
    identifierMatchers?: outputs.BotmappingMappingRuleMatchIdentifierMatcher[];
    methods?: outputs.BotmappingMappingRuleMatchMethod[];
    paths?: outputs.BotmappingMappingRuleMatchPath[];
    typeMatchers?: outputs.BotmappingMappingRuleMatchTypeMatcher[];
}

export interface BotmappingMappingRuleMatchClassMatcher {
    clientClasses: string[];
    op?: string;
}

export interface BotmappingMappingRuleMatchClientIp {
    addrs?: outputs.BotmappingMappingRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.BotmappingMappingRuleMatchClientIpPrefix[];
    ranges?: outputs.BotmappingMappingRuleMatchClientIpRange[];
}

export interface BotmappingMappingRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface BotmappingMappingRuleMatchClientIpPrefix {
    ipAddrs: outputs.BotmappingMappingRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface BotmappingMappingRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface BotmappingMappingRuleMatchClientIpRange {
    begins: outputs.BotmappingMappingRuleMatchClientIpRangeBegin[];
    ends: outputs.BotmappingMappingRuleMatchClientIpRangeEnd[];
}

export interface BotmappingMappingRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface BotmappingMappingRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface BotmappingMappingRuleMatchHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface BotmappingMappingRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface BotmappingMappingRuleMatchIdentifierMatcher {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface BotmappingMappingRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface BotmappingMappingRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface BotmappingMappingRuleMatchTypeMatcher {
    clientTypes: string[];
    op?: string;
}

export interface CertificatemanagementprofileConfigpbAttribute {
    version: string;
}

export interface CertificatemanagementprofileMarker {
    key: string;
    values?: string[];
}

export interface CertificatemanagementprofileScriptParam {
    isDynamic?: string;
    isSensitive?: string;
    name: string;
    value: string;
}

export interface CloudAwsConfiguration {
    accessKeyId: string;
    asgPollInterval?: string;
    ebsEncryptions?: outputs.CloudAwsConfigurationEbsEncryption[];
    freeElasticips?: string;
    iamAssumeRole: string;
    publishVipToPublicZone?: string;
    region?: string;
    route53Integration?: string;
    s3Encryptions?: outputs.CloudAwsConfigurationS3Encryption[];
    secretAccessKey: string;
    sqsEncryptions?: outputs.CloudAwsConfigurationSqsEncryption[];
    ttl?: string;
    useIamRoles?: string;
    useSnsSqs?: string;
    vpc: string;
    vpcId: string;
    zones?: outputs.CloudAwsConfigurationZone[];
}

export interface CloudAwsConfigurationEbsEncryption {
    masterKey: string;
    mode?: string;
}

export interface CloudAwsConfigurationS3Encryption {
    masterKey: string;
    mode?: string;
}

export interface CloudAwsConfigurationSqsEncryption {
    masterKey: string;
    mode?: string;
}

export interface CloudAwsConfigurationZone {
    availabilityZone: string;
    mgmtNetworkName: string;
    mgmtNetworkUuid: string;
}

export interface CloudAzureConfiguration {
    availabilityZones?: string[];
    cloudCredentialsRef: string;
    desId: string;
    location: string;
    networkInfos: outputs.CloudAzureConfigurationNetworkInfo[];
    resourceGroup: string;
    seStorageAccount: string;
    subscriptionId: string;
    useAzureDns?: string;
    useEnhancedHa?: string;
    useManagedDisks?: string;
    useStandardAlb?: string;
}

export interface CloudAzureConfigurationNetworkInfo {
    managementNetworkId: string;
    seNetworkId: string;
    virtualNetworkId: string;
}

export interface CloudCloudstackConfiguration {
    accessKeyId: string;
    apiUrl: string;
    cntrPublicIp: string;
    hypervisor?: string;
    mgmtNetworkName: string;
    mgmtNetworkUuid: string;
    secretAccessKey: string;
}

export interface CloudConfigpbAttribute {
    version: string;
}

export interface CloudCustomTag {
    tagKey: string;
    tagVal: string;
}

export interface CloudDnsResolver {
    fixedTtl: string;
    minTtl?: string;
    nameserverIps: outputs.CloudDnsResolverNameserverIp[];
    resolverName: string;
    useMgmt?: string;
}

export interface CloudDnsResolverNameserverIp {
    addr: string;
    type: string;
}

export interface CloudDockerConfiguration {
    appSyncFrequency?: string;
    caTlsKeyAndCertificateRef: string;
    clientTlsKeyAndCertificateRef: string;
    containerPortMatchHttpService?: string;
    coredumpDirectory?: string;
    disableAutoBackendServiceSync?: string;
    disableAutoFrontendServiceSync?: string;
    disableAutoSeCreation?: string;
    dockerRegistrySes?: outputs.CloudDockerConfigurationDockerRegistrySe[];
    eastWestPlacementSubnets?: outputs.CloudDockerConfigurationEastWestPlacementSubnet[];
    enableEventSubscription?: string;
    feproxyContainerPortAsService?: string;
    feproxyVipsEnableProxyArp?: string;
    fleetEndpoint: string;
    httpContainerPorts?: number[];
    seDeploymentMethod?: string;
    seExcludeAttributes?: outputs.CloudDockerConfigurationSeExcludeAttribute[];
    seIncludeAttributes?: outputs.CloudDockerConfigurationSeIncludeAttribute[];
    seSpawnRate?: string;
    seVolume?: string;
    servicesAccessibleAllInterfaces?: string;
    sshUserRef: string;
    ucpNodes?: string[];
    useContainerIpPort?: string;
    useControllerImage?: string;
}

export interface CloudDockerConfigurationDockerRegistrySe {
    oshiftRegistries?: outputs.CloudDockerConfigurationDockerRegistrySeOshiftRegistry[];
    password: string;
    private?: string;
    registry?: string;
    username: string;
}

export interface CloudDockerConfigurationDockerRegistrySeOshiftRegistry {
    registryNamespace?: string;
    registryService?: string;
    registryVips?: outputs.CloudDockerConfigurationDockerRegistrySeOshiftRegistryRegistryVip[];
}

export interface CloudDockerConfigurationDockerRegistrySeOshiftRegistryRegistryVip {
    addr: string;
    type: string;
}

export interface CloudDockerConfigurationEastWestPlacementSubnet {
    ipAddrs: outputs.CloudDockerConfigurationEastWestPlacementSubnetIpAddr[];
    mask: string;
}

export interface CloudDockerConfigurationEastWestPlacementSubnetIpAddr {
    addr: string;
    type: string;
}

export interface CloudDockerConfigurationSeExcludeAttribute {
    attribute: string;
    value: string;
}

export interface CloudDockerConfigurationSeIncludeAttribute {
    attribute: string;
    value: string;
}

export interface CloudGcpConfiguration {
    cloudCredentialsRef: string;
    encryptionKeys?: outputs.CloudGcpConfigurationEncryptionKey[];
    firewallTargetTags?: string[];
    gcpServiceAccountEmail: string;
    gcsBucketName: string;
    gcsProjectId: string;
    networkConfigs: outputs.CloudGcpConfigurationNetworkConfig[];
    regionName: string;
    seProjectId: string;
    vipAllocationStrategies: outputs.CloudGcpConfigurationVipAllocationStrategy[];
    zones: string[];
}

export interface CloudGcpConfigurationEncryptionKey {
    gcsBucketKmsKeyId: string;
    gcsObjectsKmsKeyId: string;
    seDiskKmsKeyId: string;
    seImageKmsKeyId: string;
}

export interface CloudGcpConfigurationNetworkConfig {
    config: string;
    inbands?: outputs.CloudGcpConfigurationNetworkConfigInband[];
    oneArms?: outputs.CloudGcpConfigurationNetworkConfigOneArm[];
    twoArms?: outputs.CloudGcpConfigurationNetworkConfigTwoArm[];
}

export interface CloudGcpConfigurationNetworkConfigInband {
    vpcNetworkName: string;
    vpcProjectId: string;
    vpcSubnetName: string;
}

export interface CloudGcpConfigurationNetworkConfigOneArm {
    dataVpcNetworkName: string;
    dataVpcProjectId: string;
    dataVpcSubnetName: string;
    managementVpcNetworkName: string;
    managementVpcProjectId: string;
    managementVpcSubnetName: string;
}

export interface CloudGcpConfigurationNetworkConfigTwoArm {
    backendDataVpcNetworkName: string;
    backendDataVpcProjectId: string;
    backendDataVpcSubnetName: string;
    frontendDataVpcNetworkName: string;
    frontendDataVpcProjectId: string;
    frontendDataVpcSubnetName: string;
    managementVpcNetworkName: string;
    managementVpcProjectId: string;
    managementVpcSubnetName: string;
}

export interface CloudGcpConfigurationVipAllocationStrategy {
    ilbs?: outputs.CloudGcpConfigurationVipAllocationStrategyIlb[];
    mode?: string;
    routes?: outputs.CloudGcpConfigurationVipAllocationStrategyRoute[];
}

export interface CloudGcpConfigurationVipAllocationStrategyIlb {
    cloudRouterNames?: string[];
}

export interface CloudGcpConfigurationVipAllocationStrategyRoute {
    matchSeGroupSubnet?: string;
    routePriority?: string;
}

export interface CloudLinuxserverConfiguration {
    hosts?: outputs.CloudLinuxserverConfigurationHost[];
    seInbandMgmt?: string;
    seLogDiskPath: string;
    seLogDiskSizeGb?: string;
    seSysDiskPath: string;
    seSysDiskSizeGb?: string;
    sshUserRef: string;
}

export interface CloudLinuxserverConfigurationHost {
    hostAttrs?: outputs.CloudLinuxserverConfigurationHostHostAttr[];
    hostIps: outputs.CloudLinuxserverConfigurationHostHostIp[];
    nodeAvailabilityZone: string;
    seGroupRef: string;
}

export interface CloudLinuxserverConfigurationHostHostAttr {
    attrKey: string;
    attrVal: string;
}

export interface CloudLinuxserverConfigurationHostHostIp {
    addr: string;
    type: string;
}

export interface CloudMarker {
    key: string;
    values?: string[];
}

export interface CloudNsxtConfiguration {
    automateDfwObjects?: string;
    automateDfwRules?: string;
    dataNetworkConfigs?: outputs.CloudNsxtConfigurationDataNetworkConfig[];
    domainId?: string;
    enforcementpointId?: string;
    managementNetworkConfigs?: outputs.CloudNsxtConfigurationManagementNetworkConfig[];
    nsxtCredentialsRef: string;
    nsxtUrl: string;
    siteId?: string;
    vmcMode?: string;
    vpcMode: string;
}

export interface CloudNsxtConfigurationDataNetworkConfig {
    tier1SegmentConfigs?: outputs.CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfig[];
    transportZone: string;
    tzType: string;
    vlanSegments?: string[];
}

export interface CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfig {
    automatics?: outputs.CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomatic[];
    manuals?: outputs.CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManual[];
    segmentConfigMode?: string;
}

export interface CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomatic {
    nsxtSegmentSubnets: outputs.CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnet[];
    numSePerSegment?: string;
    tier1LrIds: string[];
}

export interface CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnet {
    ipAddrs: outputs.CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnetIpAddr[];
    mask: string;
}

export interface CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnetIpAddr {
    addr: string;
    type: string;
}

export interface CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManual {
    tier1Lrs: outputs.CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManualTier1Lr[];
}

export interface CloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManualTier1Lr {
    localeService: string;
    segmentId: string;
    tier1LrId: string;
}

export interface CloudNsxtConfigurationManagementNetworkConfig {
    overlaySegments?: outputs.CloudNsxtConfigurationManagementNetworkConfigOverlaySegment[];
    transportZone: string;
    tzType: string;
    vlanSegment: string;
}

export interface CloudNsxtConfigurationManagementNetworkConfigOverlaySegment {
    localeService: string;
    segmentId: string;
    tier1LrId: string;
}

export interface CloudNtpConfiguration {
    ntpAuthenticationKeys?: outputs.CloudNtpConfigurationNtpAuthenticationKey[];
    ntpServerLists?: outputs.CloudNtpConfigurationNtpServerList[];
    ntpServers?: outputs.CloudNtpConfigurationNtpServer[];
}

export interface CloudNtpConfigurationNtpAuthenticationKey {
    algorithm?: string;
    key: string;
    keyNumber: string;
}

export interface CloudNtpConfigurationNtpServer {
    keyNumber: string;
    servers: outputs.CloudNtpConfigurationNtpServerServer[];
}

export interface CloudNtpConfigurationNtpServerList {
    addr: string;
    type: string;
}

export interface CloudNtpConfigurationNtpServerServer {
    addr: string;
    type: string;
}

export interface CloudOpenstackConfiguration {
    adminTenant: string;
    adminTenantUuid: string;
    allowedAddressPairs?: string;
    antiAffinity?: string;
    authUrl: string;
    configDrive?: string;
    contrailDisablePolicy?: string;
    contrailEndpoint: string;
    contrailPlugin?: string;
    customSeImageProperties?: outputs.CloudOpenstackConfigurationCustomSeImageProperty[];
    enableOsObjectCaching?: string;
    enableTagging?: string;
    externalNetworks?: string;
    freeFloatingips?: string;
    hypervisor?: string;
    hypervisorProperties?: outputs.CloudOpenstackConfigurationHypervisorProperty[];
    imgFormat?: string;
    importKeystoneTenants?: string;
    insecure?: string;
    keystoneHost: string;
    mapAdminToCloudadmin?: string;
    mgmtNetworkName: string;
    mgmtNetworkUuid: string;
    nameOwner?: string;
    neutronRbac?: string;
    password: string;
    privilege: string;
    provNames?: string[];
    providerVipNetworks?: outputs.CloudOpenstackConfigurationProviderVipNetwork[];
    region: string;
    roleMappings?: outputs.CloudOpenstackConfigurationRoleMapping[];
    securityGroups?: string;
    tenantSe?: string;
    useAdminUrl?: string;
    useInternalEndpoints?: string;
    useKeystoneAuth?: string;
    username: string;
    vipPortInAdminTenant?: string;
}

export interface CloudOpenstackConfigurationCustomSeImageProperty {
    name: string;
    value: string;
}

export interface CloudOpenstackConfigurationHypervisorProperty {
    hypervisor: string;
    imageProperties?: outputs.CloudOpenstackConfigurationHypervisorPropertyImageProperty[];
}

export interface CloudOpenstackConfigurationHypervisorPropertyImageProperty {
    name: string;
    value: string;
}

export interface CloudOpenstackConfigurationProviderVipNetwork {
    osNetworkUuid: string;
    osTenantUuids?: string[];
}

export interface CloudOpenstackConfigurationRoleMapping {
    aviRole: string;
    osRole: string;
}

export interface CloudProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface CloudRancherConfiguration {
    accessKey: string;
    appSyncFrequency?: string;
    containerPortMatchHttpService?: string;
    coredumpDirectory?: string;
    disableAutoBackendServiceSync?: string;
    disableAutoFrontendServiceSync?: string;
    disableAutoSeCreation?: string;
    dockerRegistrySes?: outputs.CloudRancherConfigurationDockerRegistrySe[];
    eastWestPlacementSubnets?: outputs.CloudRancherConfigurationEastWestPlacementSubnet[];
    enableEventSubscription?: string;
    feproxyContainerPortAsService?: string;
    feproxyVipsEnableProxyArp?: string;
    fleetEndpoint: string;
    httpContainerPorts?: number[];
    nuageControllers?: outputs.CloudRancherConfigurationNuageController[];
    rancherServers?: string[];
    seDeploymentMethod?: string;
    seExcludeAttributes?: outputs.CloudRancherConfigurationSeExcludeAttribute[];
    seIncludeAttributes?: outputs.CloudRancherConfigurationSeIncludeAttribute[];
    seSpawnRate?: string;
    seVolume?: string;
    secretKey: string;
    servicesAccessibleAllInterfaces?: string;
    sshUserRef: string;
    useContainerIpPort?: string;
    useControllerImage?: string;
}

export interface CloudRancherConfigurationDockerRegistrySe {
    oshiftRegistries?: outputs.CloudRancherConfigurationDockerRegistrySeOshiftRegistry[];
    password: string;
    private?: string;
    registry?: string;
    username: string;
}

export interface CloudRancherConfigurationDockerRegistrySeOshiftRegistry {
    registryNamespace?: string;
    registryService?: string;
    registryVips?: outputs.CloudRancherConfigurationDockerRegistrySeOshiftRegistryRegistryVip[];
}

export interface CloudRancherConfigurationDockerRegistrySeOshiftRegistryRegistryVip {
    addr: string;
    type: string;
}

export interface CloudRancherConfigurationEastWestPlacementSubnet {
    ipAddrs: outputs.CloudRancherConfigurationEastWestPlacementSubnetIpAddr[];
    mask: string;
}

export interface CloudRancherConfigurationEastWestPlacementSubnetIpAddr {
    addr: string;
    type: string;
}

export interface CloudRancherConfigurationNuageController {
    nuageOrganization: string;
    nuagePassword: string;
    nuagePort?: string;
    nuageUsername: string;
    nuageVsdHost: string;
    seDomain: string;
    seEnterprise: string;
    seNetwork: string;
    sePolicyGroup: string;
    seUser: string;
    seZone: string;
}

export interface CloudRancherConfigurationSeExcludeAttribute {
    attribute: string;
    value: string;
}

export interface CloudRancherConfigurationSeIncludeAttribute {
    attribute: string;
    value: string;
}

export interface CloudVcaConfiguration {
    privilege: string;
    vcaHost: string;
    vcaInstance: string;
    vcaMgmtNetwork: string;
    vcaOrgnization: string;
    vcaPassword: string;
    vcaUsername: string;
    vcaVdc: string;
}

export interface CloudVcenterConfiguration {
    contentLibs?: outputs.CloudVcenterConfigurationContentLib[];
    datacenter: string;
    datacenterManagedObjectId: string;
    isNsxEnvironment?: string;
    managementIpSubnets?: outputs.CloudVcenterConfigurationManagementIpSubnet[];
    managementNetwork: string;
    password: string;
    privilege: string;
    useContentLib?: string;
    username: string;
    vcenterTemplateSeLocation: string;
    vcenterUrl: string;
}

export interface CloudVcenterConfigurationContentLib {
    id: string;
    name: string;
}

export interface CloudVcenterConfigurationManagementIpSubnet {
    ipAddrs: outputs.CloudVcenterConfigurationManagementIpSubnetIpAddr[];
    mask: string;
}

export interface CloudVcenterConfigurationManagementIpSubnetIpAddr {
    addr: string;
    type: string;
}

export interface CloudconnectoruserAzureServiceprincipal {
    applicationId: string;
    authenticationToken: string;
    tenantId: string;
}

export interface CloudconnectoruserAzureUserpass {
    password: string;
    tenantName: string;
    username: string;
}

export interface CloudconnectoruserConfigpbAttribute {
    version: string;
}

export interface CloudconnectoruserGcpCredential {
    serviceAccountKeyfileData: string;
}

export interface CloudconnectoruserNsxtCredential {
    password: string;
    username: string;
}

export interface CloudconnectoruserOciCredential {
    fingerprint: string;
    keyContent: string;
    passPhrase: string;
    user: string;
}

export interface CloudconnectoruserTencentCredential {
    secretId: string;
    secretKey: string;
}

export interface CloudconnectoruserVcenterCredential {
    password: string;
    username: string;
}

export interface CloudpropertiesCcProp {
    rpcPollInterval?: string;
    rpcQueueSize?: string;
}

export interface CloudpropertiesConfigpbAttribute {
    version: string;
}

export interface CloudpropertiesHypProp {
    htype: string;
    maxIpsPerNic: string;
    maxNics: string;
}

export interface CloudpropertiesInfo {
    ccaProps?: outputs.CloudpropertiesInfoCcaProp[];
    controllerProps?: outputs.CloudpropertiesInfoControllerProp[];
    flavorProps?: outputs.CloudpropertiesInfoFlavorProp[];
    flavorRegexFilter: string;
    htypes?: string[];
    vtype: string;
}

export interface CloudpropertiesInfoCcaProp {
    asyncRetries?: string;
    asyncRetriesDelay?: string;
    pollDurationTarget?: string;
    pollFastTarget?: string;
    pollSlowTarget?: string;
    vcenterHostPingInterval?: string;
    vcenterInventoryMaxObjectUpdates?: string;
    vcenterMaxDatastoreGoRoutines?: string;
    vcenterReconcileInterval?: string;
    vnicRetries?: string;
    vnicRetriesDelay?: string;
}

export interface CloudpropertiesInfoControllerProp {
    alertManagerUseEvms?: string;
    allowAdminNetworkUpdates?: string;
    allowIpForwarding?: string;
    allowUnauthenticatedApis?: string;
    allowUnauthenticatedNodes?: string;
    apiIdleTimeout?: string;
    apiPerfLoggingThreshold?: string;
    appviewxCompatMode?: string;
    asyncPatchMergePeriod?: string;
    asyncPatchRequestCleanupDuration?: string;
    attachIpRetryInterval?: string;
    attachIpRetryLimit?: string;
    bmUseAnsible?: string;
    checkVsvipFqdnSyntax?: string;
    cleanupExpiredAuthtokenTimeoutPeriod?: string;
    cleanupSessionsTimeoutPeriod?: string;
    cloudDiscoveryInterval?: string;
    cloudReconcile?: string;
    cloudReconcileInterval?: string;
    clusterIpGratuitousArpPeriod?: string;
    configpbAttributes?: outputs.CloudpropertiesInfoControllerPropConfigpbAttribute[];
    consistencyCheckTimeoutPeriod?: string;
    controllerResourceInfoCollectionPeriod?: string;
    crashedSeReboot?: string;
    deadSeDetectionTimer?: string;
    defaultMinimumApiTimeout?: string;
    delOfflineSeAfterRebootDelay?: string;
    detachIpRetryInterval?: string;
    detachIpRetryLimit?: string;
    detachIpTimeout?: string;
    dnsRefreshPeriod?: string;
    dummy: string;
    editSystemLimits?: string;
    enableApiSharding?: string;
    enableMemoryBalancer?: string;
    enablePerProcessStop?: string;
    enableResmgrLogCachePrint?: string;
    eventManagerMaxGoroutines?: string;
    eventManagerMaxSubscribers?: string;
    eventManagerProcessingTimeThreshold?: string;
    falsePositiveLearningConfigs?: outputs.CloudpropertiesInfoControllerPropFalsePositiveLearningConfig[];
    fatalErrorLeaseTime?: string;
    federatedDatastoreCleanupDuration?: string;
    fileObjectCleanupPeriod?: string;
    fileobjectMaxFileVersions?: string;
    gslbPurgeBatchSize?: string;
    gslbPurgeSleepTimeMs?: string;
    ignoreVrfInNetworksubnetlist?: string;
    maxDeadSeInGrp?: string;
    maxPcapPerTenant?: string;
    maxSeSpawnIntervalDelay?: string;
    maxSeqAttachIpFailures?: string;
    maxSeqVnicFailures?: string;
    maxThreadsCcVipBgWorker?: string;
    permissionScopedSharedAdminNetworks?: string;
    persistenceKeyRotatePeriod?: string;
    portalRequestBurstLimit?: string;
    portalRequestRateLimit?: string;
    portalToken: string;
    postgresVacuumPeriod?: string;
    processLockedUseraccountsTimeoutPeriod?: string;
    processPkiProfileTimeoutPeriod?: string;
    queryHostFail?: string;
    resmgrLogCachingPeriod?: string;
    restrictCloudReadAccess?: string;
    safenetHsmVersion: string;
    seCreateTimeout?: string;
    seFailoverAttemptInterval?: string;
    seFromMarketplace?: string;
    seOfflineDel?: string;
    seSpawnRetryInterval?: string;
    seUpgradeFlowCleanupTimeout?: string;
    seVnicCooldown?: string;
    seVnicGcWaitTime?: string;
    secureChannelCleanupTimeout?: string;
    secureChannelControllerTokenTimeout?: string;
    secureChannelSeTokenTimeout?: string;
    seupgradeCopyBufferSize?: string;
    seupgradeCopyPoolSize?: string;
    seupgradeFabricPoolSize?: string;
    seupgradeSegroupMinDeadTimeout?: string;
    sharedSslCertificates?: string;
    skopeoRetryInterval?: string;
    skopeoRetryLimit?: string;
    softMinMemPerSeLimit?: string;
    sslCertificateExpiryWarningDays?: number[];
    systemReportCleanupInterval?: string;
    systemReportLimit?: string;
    unresponsiveSeReboot?: string;
    updateDnsEntryRetryLimit?: string;
    updateDnsEntryTimeout?: string;
    upgradeDnsTtl?: string;
    upgradeFatSeLeaseTime?: string;
    upgradeLeaseTime?: string;
    upgradeSePerVsScaleOpsTxnTime?: string;
    userAgentCacheConfigs?: outputs.CloudpropertiesInfoControllerPropUserAgentCacheConfig[];
    uuid: string;
    vnicOpFailTime?: string;
    vsAwaitingSeTimeout?: string;
    vsKeyRotatePeriod?: string;
    vsScaleoutReadyCheckInterval?: string;
    vsSeAttachIpFail?: string;
    vsSeBootupFail?: string;
    vsSeBootupFailPatch?: string;
    vsSeCreateFail?: string;
    vsSePingFail?: string;
    vsSeVnicFail?: string;
    vsSeVnicIpFail?: string;
    vsphereHaDetectionTimeout?: string;
    vsphereHaRecoveryTimeout?: string;
    vsphereHaTimerInterval?: string;
    warmstartSeReconnectWaitTime?: string;
    warmstartVsResyncWaitTime?: string;
}

export interface CloudpropertiesInfoControllerPropConfigpbAttribute {
    version: string;
}

export interface CloudpropertiesInfoControllerPropFalsePositiveLearningConfig {
    maxAppsSupported?: string;
    minMonitorTime?: string;
    minTransPerApplication?: string;
    minTransPerUri?: string;
}

export interface CloudpropertiesInfoControllerPropUserAgentCacheConfig {
    batchSize?: string;
    controllerCacheSize?: string;
    maxAge?: string;
    maxLastHitTime?: string;
    maxUpstreamQueries?: string;
    maxWaitTime?: string;
    numEntriesUpstreamUpdate?: string;
    percentReservedForBadBots?: string;
    percentReservedForBrowsers?: string;
    percentReservedForGoodBots?: string;
    percentReservedForOutstanding?: string;
    seCacheSize?: string;
    upstreamUpdateInterval?: string;
}

export interface CloudpropertiesInfoFlavorProp {
    cost: string;
    diskGb: string;
    enhancedNw: string;
    id: string;
    isRecommended: string;
    maxIp6sPerNic: string;
    maxIpsPerNic: string;
    maxNics: string;
    metas?: outputs.CloudpropertiesInfoFlavorPropMeta[];
    name: string;
    public?: string;
    ramMb: string;
    vcpus: string;
}

export interface CloudpropertiesInfoFlavorPropMeta {
    key: string;
    value: string;
}

export interface ClusterClusterState {
    progress: string;
    state: string;
    upSince: string;
}

export interface ClusterNode {
    categories?: string[];
    interfaces?: outputs.ClusterNodeInterface[];
    ip6s?: outputs.ClusterNodeIp6[];
    ips?: outputs.ClusterNodeIp[];
    name?: string;
    password: string;
    publicIpOrNames?: outputs.ClusterNodePublicIpOrName[];
    staticRoutes?: outputs.ClusterNodeStaticRoute[];
    vmHostname: string;
    vmMor: string;
    vmName: string;
    vmUuid: string;
}

export interface ClusterNodeInterface {
    gateway6s?: outputs.ClusterNodeInterfaceGateway6[];
    gateways?: outputs.ClusterNodeInterfaceGateway[];
    ifName: string;
    ip6s?: outputs.ClusterNodeInterfaceIp6[];
    ips?: outputs.ClusterNodeInterfaceIp[];
    labels?: string[];
    macAddress: string;
    mode: string;
    mode6: string;
    publicIpOrNames?: outputs.ClusterNodeInterfacePublicIpOrName[];
    v4Enabled: string;
    v6Enabled: string;
}

export interface ClusterNodeInterfaceGateway {
    addr: string;
    type: string;
}

export interface ClusterNodeInterfaceGateway6 {
    addr: string;
    type: string;
}

export interface ClusterNodeInterfaceIp {
    ipAddrs: outputs.ClusterNodeInterfaceIpIpAddr[];
    mask: string;
}

export interface ClusterNodeInterfaceIp6 {
    ipAddrs: outputs.ClusterNodeInterfaceIp6IpAddr[];
    mask: string;
}

export interface ClusterNodeInterfaceIp6IpAddr {
    addr: string;
    type: string;
}

export interface ClusterNodeInterfaceIpIpAddr {
    addr: string;
    type: string;
}

export interface ClusterNodeInterfacePublicIpOrName {
    addr: string;
    type: string;
}

export interface ClusterNodeIp {
    addr: string;
    type: string;
}

export interface ClusterNodeIp6 {
    addr: string;
    type: string;
}

export interface ClusterNodePublicIpOrName {
    addr: string;
    type: string;
}

export interface ClusterNodeStaticRoute {
    disableGatewayMonitor: string;
    ifName: string;
    labels?: outputs.ClusterNodeStaticRouteLabel[];
    nextHops: outputs.ClusterNodeStaticRouteNextHop[];
    prefixes: outputs.ClusterNodeStaticRoutePrefix[];
    routeId: string;
}

export interface ClusterNodeStaticRouteLabel {
    key: string;
    value: string;
}

export interface ClusterNodeStaticRouteNextHop {
    addr: string;
    type: string;
}

export interface ClusterNodeStaticRoutePrefix {
    ipAddrs: outputs.ClusterNodeStaticRoutePrefixIpAddr[];
    mask: string;
}

export interface ClusterNodeStaticRoutePrefixIpAddr {
    addr: string;
    type: string;
}

export interface ClusterVirtualIp {
    addr: string;
    type: string;
}

export interface ClusterVirtualIp6 {
    addr: string;
    type: string;
}

export interface ClusterclouddetailsAzureInfo {
    cloudCredentialRef: string;
    subscriptionId: string;
}

export interface ClusterclouddetailsConfigpbAttribute {
    version: string;
}

export interface ControllerportalregistrationAsset {
    assetId: string;
}

export interface ControllerportalregistrationPortalAuth {
    accessToken: string;
    grantType?: string;
    instanceUrl: string;
    jwtToken: string;
    tenant: string;
}

export interface ControllerpropertiesConfigpbAttribute {
    version: string;
}

export interface ControllerpropertiesFalsePositiveLearningConfig {
    maxAppsSupported?: string;
    minMonitorTime?: string;
    minTransPerApplication?: string;
    minTransPerUri?: string;
}

export interface ControllerpropertiesUserAgentCacheConfig {
    batchSize?: string;
    controllerCacheSize?: string;
    maxAge?: string;
    maxLastHitTime?: string;
    maxUpstreamQueries?: string;
    maxWaitTime?: string;
    numEntriesUpstreamUpdate?: string;
    percentReservedForBadBots?: string;
    percentReservedForBrowsers?: string;
    percentReservedForGoodBots?: string;
    percentReservedForOutstanding?: string;
    seCacheSize?: string;
    upstreamUpdateInterval?: string;
}

export interface ControllersiteConfigpbAttribute {
    version: string;
}

export interface CsrfpolicyConfigpbAttribute {
    version: string;
}

export interface CsrfpolicyRule {
    action?: string;
    enable?: string;
    index: string;
    matches: outputs.CsrfpolicyRuleMatch[];
    name: string;
}

export interface CsrfpolicyRuleMatch {
    botDetectionResults?: outputs.CsrfpolicyRuleMatchBotDetectionResult[];
    clientIps?: outputs.CsrfpolicyRuleMatchClientIp[];
    cookies?: outputs.CsrfpolicyRuleMatchCookie[];
    geoMatches?: outputs.CsrfpolicyRuleMatchGeoMatch[];
    hdrs?: outputs.CsrfpolicyRuleMatchHdr[];
    hostHdrs?: outputs.CsrfpolicyRuleMatchHostHdr[];
    ipReputationTypes?: outputs.CsrfpolicyRuleMatchIpReputationType[];
    methods?: outputs.CsrfpolicyRuleMatchMethod[];
    paths?: outputs.CsrfpolicyRuleMatchPath[];
    protocols?: outputs.CsrfpolicyRuleMatchProtocol[];
    queries?: outputs.CsrfpolicyRuleMatchQuery[];
    sourceIps?: outputs.CsrfpolicyRuleMatchSourceIp[];
    tlsFingerprintMatches?: outputs.CsrfpolicyRuleMatchTlsFingerprintMatch[];
    versions?: outputs.CsrfpolicyRuleMatchVersion[];
    vsPorts?: outputs.CsrfpolicyRuleMatchVsPort[];
}

export interface CsrfpolicyRuleMatchBotDetectionResult {
    classifications?: outputs.CsrfpolicyRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface CsrfpolicyRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface CsrfpolicyRuleMatchClientIp {
    addrs?: outputs.CsrfpolicyRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.CsrfpolicyRuleMatchClientIpPrefix[];
    ranges?: outputs.CsrfpolicyRuleMatchClientIpRange[];
}

export interface CsrfpolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.CsrfpolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface CsrfpolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchClientIpRange {
    begins: outputs.CsrfpolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.CsrfpolicyRuleMatchClientIpRangeEnd[];
}

export interface CsrfpolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchCookie {
    matchCase?: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface CsrfpolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface CsrfpolicyRuleMatchHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface CsrfpolicyRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface CsrfpolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface CsrfpolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface CsrfpolicyRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface CsrfpolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface CsrfpolicyRuleMatchQuery {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface CsrfpolicyRuleMatchSourceIp {
    addrs?: outputs.CsrfpolicyRuleMatchSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.CsrfpolicyRuleMatchSourceIpPrefix[];
    ranges?: outputs.CsrfpolicyRuleMatchSourceIpRange[];
}

export interface CsrfpolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.CsrfpolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface CsrfpolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchSourceIpRange {
    begins: outputs.CsrfpolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.CsrfpolicyRuleMatchSourceIpRangeEnd[];
}

export interface CsrfpolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface CsrfpolicyRuleMatchTlsFingerprintMatch {
    fingerprints?: string[];
    matchOperation: string;
    stringGroupRefs?: string[];
}

export interface CsrfpolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface CsrfpolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface CustomipamdnsprofileConfigpbAttribute {
    version: string;
}

export interface CustomipamdnsprofileScriptParam {
    isDynamic?: string;
    isSensitive?: string;
    name: string;
    value: string;
}

export interface DnspolicyConfigpbAttribute {
    version: string;
}

export interface DnspolicyMarker {
    key: string;
    values?: string[];
}

export interface DnspolicyRule {
    actions?: outputs.DnspolicyRuleAction[];
    enable?: string;
    index: string;
    log: string;
    matches?: outputs.DnspolicyRuleMatch[];
    name: string;
}

export interface DnspolicyRuleAction {
    allows?: outputs.DnspolicyRuleActionAllow[];
    dnsRateLimiters?: outputs.DnspolicyRuleActionDnsRateLimiter[];
    gsGroupSelections?: outputs.DnspolicyRuleActionGsGroupSelection[];
    gslbSiteSelections?: outputs.DnspolicyRuleActionGslbSiteSelection[];
    poolSwitchings?: outputs.DnspolicyRuleActionPoolSwitching[];
    responses?: outputs.DnspolicyRuleActionResponse[];
}

export interface DnspolicyRuleActionAllow {
    allow?: string;
    resetConn?: string;
}

export interface DnspolicyRuleActionDnsRateLimiter {
    actions: outputs.DnspolicyRuleActionDnsRateLimiterAction[];
    rateLimiterObjects: outputs.DnspolicyRuleActionDnsRateLimiterRateLimiterObject[];
}

export interface DnspolicyRuleActionDnsRateLimiterAction {
    type?: string;
}

export interface DnspolicyRuleActionDnsRateLimiterRateLimiterObject {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface DnspolicyRuleActionGsGroupSelection {
    groupName: string;
}

export interface DnspolicyRuleActionGslbSiteSelection {
    fallbackSiteNames?: string[];
    isSitePreferred?: string;
    siteName: string;
}

export interface DnspolicyRuleActionPoolSwitching {
    poolGroupRef: string;
    poolRef: string;
}

export interface DnspolicyRuleActionResponse {
    authoritative?: string;
    rcode?: string;
    resourceRecordSets?: outputs.DnspolicyRuleActionResponseResourceRecordSet[];
    truncation?: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSet {
    resourceRecordSets: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSet[];
    section?: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSet {
    cnames?: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetCname[];
    fqdn: string;
    ip6Addresses?: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6Address[];
    ipAddresses?: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddress[];
    nses?: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNse[];
    ttl: string;
    type: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetCname {
    cname: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6Address {
    ip6Addresses: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6AddressIp6Address[];
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6AddressIp6Address {
    addr: string;
    type: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddress {
    ipAddresses: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddressIpAddress[];
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddressIpAddress {
    addr: string;
    type: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNse {
    ip6Addresses?: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIp6Address[];
    ipAddresses?: outputs.DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIpAddress[];
    nsname: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIp6Address {
    addr: string;
    type: string;
}

export interface DnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIpAddress {
    addr: string;
    type: string;
}

export interface DnspolicyRuleMatch {
    clientIpAddresses?: outputs.DnspolicyRuleMatchClientIpAddress[];
    clientPortNumbers?: outputs.DnspolicyRuleMatchClientPortNumber[];
    geoLocations?: outputs.DnspolicyRuleMatchGeoLocation[];
    protocols?: outputs.DnspolicyRuleMatchProtocol[];
    queryNames?: outputs.DnspolicyRuleMatchQueryName[];
    queryTypes?: outputs.DnspolicyRuleMatchQueryType[];
}

export interface DnspolicyRuleMatchClientIpAddress {
    clientIps: outputs.DnspolicyRuleMatchClientIpAddressClientIp[];
    useEdnsClientSubnetIp?: string;
}

export interface DnspolicyRuleMatchClientIpAddressClientIp {
    addrs?: outputs.DnspolicyRuleMatchClientIpAddressClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.DnspolicyRuleMatchClientIpAddressClientIpPrefix[];
    ranges?: outputs.DnspolicyRuleMatchClientIpAddressClientIpRange[];
}

export interface DnspolicyRuleMatchClientIpAddressClientIpAddr {
    addr: string;
    type: string;
}

export interface DnspolicyRuleMatchClientIpAddressClientIpPrefix {
    ipAddrs: outputs.DnspolicyRuleMatchClientIpAddressClientIpPrefixIpAddr[];
    mask: string;
}

export interface DnspolicyRuleMatchClientIpAddressClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface DnspolicyRuleMatchClientIpAddressClientIpRange {
    begins: outputs.DnspolicyRuleMatchClientIpAddressClientIpRangeBegin[];
    ends: outputs.DnspolicyRuleMatchClientIpAddressClientIpRangeEnd[];
}

export interface DnspolicyRuleMatchClientIpAddressClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface DnspolicyRuleMatchClientIpAddressClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface DnspolicyRuleMatchClientPortNumber {
    clientPorts: outputs.DnspolicyRuleMatchClientPortNumberClientPort[];
}

export interface DnspolicyRuleMatchClientPortNumberClientPort {
    matchCriteria: string;
    ports?: number[];
    ranges?: outputs.DnspolicyRuleMatchClientPortNumberClientPortRange[];
}

export interface DnspolicyRuleMatchClientPortNumberClientPortRange {
    end: string;
    start: string;
}

export interface DnspolicyRuleMatchGeoLocation {
    geolocationName: string;
    geolocationTag: string;
    matchCriteria: string;
    useEdnsClientSubnetIp?: string;
}

export interface DnspolicyRuleMatchProtocol {
    matchCriteria: string;
    protocol: string;
}

export interface DnspolicyRuleMatchQueryName {
    matchCriteria: string;
    queryDomainNames?: string[];
    stringGroupRefs?: string[];
}

export interface DnspolicyRuleMatchQueryType {
    matchCriteria: string;
    queryTypes?: string[];
}

export interface DynamicdnsrecordCname {
    cname: string;
}

export interface DynamicdnsrecordIp6Address {
    ip6Addresses: outputs.DynamicdnsrecordIp6AddressIp6Address[];
}

export interface DynamicdnsrecordIp6AddressIp6Address {
    addr: string;
    type: string;
}

export interface DynamicdnsrecordIpAddress {
    ipAddresses: outputs.DynamicdnsrecordIpAddressIpAddress[];
}

export interface DynamicdnsrecordIpAddressIpAddress {
    addr: string;
    type: string;
}

export interface DynamicdnsrecordMxRecord {
    host: string;
    priority: string;
}

export interface DynamicdnsrecordN {
    ip6Addresses?: outputs.DynamicdnsrecordNIp6Address[];
    ipAddresses?: outputs.DynamicdnsrecordNIpAddress[];
    nsname: string;
}

export interface DynamicdnsrecordNIp6Address {
    addr: string;
    type: string;
}

export interface DynamicdnsrecordNIpAddress {
    addr: string;
    type: string;
}

export interface DynamicdnsrecordServiceLocator {
    port: string;
    priority?: string;
    target?: string;
    weight?: string;
}

export interface DynamicdnsrecordTxtRecord {
    textStr: string;
}

export interface ErrorpagebodyConfigpbAttribute {
    version: string;
}

export interface ErrorpagebodyMarker {
    key: string;
    values?: string[];
}

export interface ErrorpageprofileConfigpbAttribute {
    version: string;
}

export interface ErrorpageprofileErrorPage {
    enable?: string;
    errorPageBodyRef: string;
    errorRedirect: string;
    index: string;
    matches?: outputs.ErrorpageprofileErrorPageMatch[];
}

export interface ErrorpageprofileErrorPageMatch {
    matchCriteria: string;
    ranges?: outputs.ErrorpageprofileErrorPageMatchRange[];
    statusCodes?: number[];
}

export interface ErrorpageprofileErrorPageMatchRange {
    begin: string;
    end: string;
}

export interface ErrorpageprofileMarker {
    key: string;
    values?: string[];
}

export interface FederationcheckpointConfigpbAttribute {
    version: string;
}

export interface FileobjectConfigpbAttribute {
    version: string;
}

export interface FileobjectCrlInfo {
    commonName: string;
    distinguishedName: string;
    etag: string;
    fingerprint: string;
    lastRefreshed: string;
    lastUpdate: string;
    nextUpdate: string;
    serverUrl: string;
    text: string;
    updateInterval?: string;
}

export interface GeodbFile {
    enabled?: string;
    fileRef: string;
    index: string;
    name: string;
    vendor: string;
}

export interface GeodbMapping {
    description: string;
    elements: outputs.GeodbMappingElement[];
    name: string;
}

export interface GeodbMappingElement {
    attribute: string;
    values: string[];
}

export interface GetActiongroupconfigConfigpbAttribute {
    version: string;
}

export interface GetAlbservicesconfigAppSignatureConfig {
    appSignatureSyncInterval: string;
}

export interface GetAlbservicesconfigAssetContact {
    accountId: string;
    accountName: string;
    email: string;
    managedAccounts: outputs.GetAlbservicesconfigAssetContactManagedAccount[];
    name: string;
    phone: string;
}

export interface GetAlbservicesconfigAssetContactManagedAccount {
    id: string;
    name: string;
    users: outputs.GetAlbservicesconfigAssetContactManagedAccountUser[];
}

export interface GetAlbservicesconfigAssetContactManagedAccountUser {
    email: string;
    name: string;
    phone: string;
}

export interface GetAlbservicesconfigCaseConfig {
    additionalEmails: string[];
    enableAutoCaseCreationOnControllerFailure: string;
    enableAutoCaseCreationOnSeFailure: string;
    enableCleanupOfAttachedFiles: string;
}

export interface GetAlbservicesconfigConfigpbAttribute {
    version: string;
}

export interface GetAlbservicesconfigFeatureOptInStatus {
    enableAppsignatureSync: string;
    enableIpReputation: string;
    enablePulseCaseManagement: string;
    enablePulseInventory: string;
    enablePulseWafManagement: string;
    enableUserAgentDbSync: string;
}

export interface GetAlbservicesconfigInventoryConfig {
    enableSearchInfo: string;
}

export interface GetAlbservicesconfigIpReputationConfig {
    ipReputationFileObjectExpiryDuration: string;
    ipReputationSyncInterval: string;
}

export interface GetAlbservicesconfigSaasLicensingConfig {
    maxServiceUnits: string;
    reserveServiceUnits: string;
}

export interface GetAlbservicesconfigSessionConfig {
    sessionHeaders: outputs.GetAlbservicesconfigSessionConfigSessionHeader[];
}

export interface GetAlbservicesconfigSessionConfigSessionHeader {
    name: string;
    value: string;
}

export interface GetAlbservicesconfigSplitProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface GetAlbservicesconfigTenantConfig {
    heartbeatInterval: string;
    licenseEscrowInterval: string;
    licenseExpiryInterval: string;
    licenseReconcileInterval: string;
    licenseRefreshInterval: string;
    licenseRenewalInterval: string;
    tokenRefreshInterval: string;
}

export interface GetAlbservicesconfigUserAgentDbConfig {
    allowedBatchSize: string;
}

export interface GetAlbservicesconfigWafConfig {
    enableAutoDownloadWafSignatures: string;
    enableWafSignaturesNotifications: string;
}

export interface GetAlbservicesfiledownloadConfigpbAttribute {
    version: string;
}

export interface GetAlbservicesfiledownloadMetadata {
    checksum: string;
    checksumType: string;
    chunkSize: string;
    isMultiPartDownload: string;
    signedUrl: string;
    totalSize: string;
}

export interface GetAlbservicesjobConfigpbAttribute {
    version: string;
}

export interface GetAlbservicesjobEndTime {
    secs: string;
    usecs: string;
}

export interface GetAlbservicesjobParam {
    key: string;
    value: string;
}

export interface GetAlbservicesjobStartTime {
    secs: string;
    usecs: string;
}

export interface GetAlbservicesjobStatusUpdateTime {
    secs: string;
    usecs: string;
}

export interface GetAlertconfigAlertRule {
    connAppLogRules: outputs.GetAlertconfigAlertRuleConnAppLogRule[];
    eventMatchFilter: string;
    metricsRules: outputs.GetAlertconfigAlertRuleMetricsRule[];
    operator: string;
    sysEventRules: outputs.GetAlertconfigAlertRuleSysEventRule[];
}

export interface GetAlertconfigAlertRuleConnAppLogRule {
    filterAction: string;
    filterString: string;
}

export interface GetAlertconfigAlertRuleMetricsRule {
    duration: string;
    metricId: string;
    metricThresholds: outputs.GetAlertconfigAlertRuleMetricsRuleMetricThreshold[];
}

export interface GetAlertconfigAlertRuleMetricsRuleMetricThreshold {
    comparator: string;
    threshold: string;
}

export interface GetAlertconfigAlertRuleSysEventRule {
    eventDetails: outputs.GetAlertconfigAlertRuleSysEventRuleEventDetail[];
    eventId: string;
    notCond: string;
}

export interface GetAlertconfigAlertRuleSysEventRuleEventDetail {
    comparator: string;
    eventDetailsKey: string;
    eventDetailsValue: string;
}

export interface GetAlertconfigConfigpbAttribute {
    version: string;
}

export interface GetAlertemailconfigConfigpbAttribute {
    version: string;
}

export interface GetAlertscriptconfigConfigpbAttribute {
    version: string;
}

export interface GetAlertsyslogconfigConfigpbAttribute {
    version: string;
}

export interface GetAlertsyslogconfigSyslogServer {
    anonAuth: string;
    format: string;
    pkiprofileRef: string;
    sslKeyAndCertificateRef: string;
    strictCertVerify: string;
    syslogServer: string;
    syslogServerPort: string;
    tlsEnable: string;
    udp: string;
}

export interface GetAnalyticsprofileClientLogConfig {
    enableSignificantLogCollection: string;
    filteredLogProcessing: string;
    nonSignificantLogProcessing: string;
    significantLogProcessing: string;
}

export interface GetAnalyticsprofileClientLogStreamingConfig {
    externalServer: string;
    externalServerPort: string;
    formatConfigs: outputs.GetAnalyticsprofileClientLogStreamingConfigFormatConfig[];
    logTypesToSend: string;
    markerKeys: outputs.GetAnalyticsprofileClientLogStreamingConfigMarkerKey[];
    maxLogsPerSecond: string;
    protocol: string;
    syslogConfigs: outputs.GetAnalyticsprofileClientLogStreamingConfigSyslogConfig[];
}

export interface GetAnalyticsprofileClientLogStreamingConfigFormatConfig {
    format: string;
    includedFields: string[];
}

export interface GetAnalyticsprofileClientLogStreamingConfigMarkerKey {
    key: string;
    values: string[];
}

export interface GetAnalyticsprofileClientLogStreamingConfigSyslogConfig {
    facility: string;
    filteredLogSeverity: string;
    hostname: string;
    msgId: string;
    nonSignificantLogSeverity: string;
    procId: string;
    significantLogSeverity: string;
}

export interface GetAnalyticsprofileConfigpbAttribute {
    version: string;
}

export interface GetAnalyticsprofileLatencyAuditProp {
    connEstAuditMode: string;
    connEstThreshold: string;
    latencyAuditMode: string;
    latencyThreshold: string;
}

export interface GetAnalyticsprofileMarker {
    key: string;
    values: string[];
}

export interface GetAnalyticsprofileRange {
    begin: string;
    end: string;
}

export interface GetAnalyticsprofileSensitiveLogProfile {
    headerFieldRules: outputs.GetAnalyticsprofileSensitiveLogProfileHeaderFieldRule[];
    uriQueryFieldRules: outputs.GetAnalyticsprofileSensitiveLogProfileUriQueryFieldRule[];
    wafFieldRules: outputs.GetAnalyticsprofileSensitiveLogProfileWafFieldRule[];
}

export interface GetAnalyticsprofileSensitiveLogProfileHeaderFieldRule {
    action: string;
    enabled: string;
    index: string;
    matches: outputs.GetAnalyticsprofileSensitiveLogProfileHeaderFieldRuleMatch[];
    name: string;
}

export interface GetAnalyticsprofileSensitiveLogProfileHeaderFieldRuleMatch {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetAnalyticsprofileSensitiveLogProfileUriQueryFieldRule {
    action: string;
    enabled: string;
    index: string;
    matches: outputs.GetAnalyticsprofileSensitiveLogProfileUriQueryFieldRuleMatch[];
    name: string;
}

export interface GetAnalyticsprofileSensitiveLogProfileUriQueryFieldRuleMatch {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetAnalyticsprofileSensitiveLogProfileWafFieldRule {
    action: string;
    enabled: string;
    index: string;
    matches: outputs.GetAnalyticsprofileSensitiveLogProfileWafFieldRuleMatch[];
    name: string;
}

export interface GetAnalyticsprofileSensitiveLogProfileWafFieldRuleMatch {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetAnalyticsprofileTimeTrackerProp {
    beConnEstAuditMode: string;
    beConnEstThreshold: string;
    feConnEstAuditMode: string;
    feConnEstThreshold: string;
    ingressSigLog: string;
}

export interface GetApplicationpersistenceprofileAppCookiePersistenceProfile {
    encryptionKey: string;
    prstHdrName: string;
    timeout: string;
}

export interface GetApplicationpersistenceprofileConfigpbAttribute {
    version: string;
}

export interface GetApplicationpersistenceprofileHdrPersistenceProfile {
    prstHdrName: string;
}

export interface GetApplicationpersistenceprofileHttpCookiePersistenceProfile {
    alwaysSendCookie: string;
    cookieName: string;
    encryptionKey: string;
    httpOnly: string;
    isPersistentCookie: string;
    keys: outputs.GetApplicationpersistenceprofileHttpCookiePersistenceProfileKey[];
    timeout: string;
}

export interface GetApplicationpersistenceprofileHttpCookiePersistenceProfileKey {
    aesKey: string;
    hmacKey: string;
    name: string;
}

export interface GetApplicationpersistenceprofileIpPersistenceProfile {
    ipMask: string;
    ipPersistentTimeout: string;
}

export interface GetApplicationpersistenceprofileMarker {
    key: string;
    values: string[];
}

export interface GetApplicationprofileConfigpbAttribute {
    version: string;
}

export interface GetApplicationprofileDnsServiceProfile {
    aaaaEmptyResponse: string;
    adminEmail: string;
    clientDnsTcpRequestTimeout: string;
    closeTcpConnectionPostResponse: string;
    dnsOverTcpEnabled: string;
    dnsZones: outputs.GetApplicationprofileDnsServiceProfileDnsZone[];
    domainNames: string[];
    ecsStrippingEnabled: string;
    edns: string;
    ednsClientSubnetPrefixLen: string;
    errorResponse: string;
    nameServer: string;
    negativeCachingTtl: string;
    numDnsIp: string;
    ttl: string;
}

export interface GetApplicationprofileDnsServiceProfileDnsZone {
    adminEmail: string;
    domainName: string;
    nameServer: string;
}

export interface GetApplicationprofileDosRlProfile {
    dosProfiles: outputs.GetApplicationprofileDosRlProfileDosProfile[];
    rlProfiles: outputs.GetApplicationprofileDosRlProfileRlProfile[];
}

export interface GetApplicationprofileDosRlProfileDosProfile {
    threshInfos: outputs.GetApplicationprofileDosRlProfileDosProfileThreshInfo[];
    threshPeriod: string;
}

export interface GetApplicationprofileDosRlProfileDosProfileThreshInfo {
    attack: string;
    maxValue: string;
    minValue: string;
}

export interface GetApplicationprofileDosRlProfileRlProfile {
    clientIpConnectionsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimit[];
    clientIpFailedRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimit[];
    clientIpRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimit[];
    clientIpScannersRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimit[];
    clientIpToUriFailedRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimit[];
    clientIpToUriRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimit[];
    customRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimit[];
    httpHeaderRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimit[];
    uriFailedRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimit[];
    uriRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimit[];
    uriScannersRequestsRateLimits: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimit[];
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpConnectionsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpFailedRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpScannersRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriFailedRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileClientIpToUriRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileCustomRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileHttpHeaderRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriFailedRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimit {
    actions: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitRateLimiter[];
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitAction {
    files: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionFile[];
    redirects: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetApplicationprofileDosRlProfileRlProfileUriScannersRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetApplicationprofileHttpProfile {
    allowDotsInHeaderName: string;
    cacheConfigs: outputs.GetApplicationprofileHttpProfileCacheConfig[];
    clientBodyTimeout: string;
    clientHeaderTimeout: string;
    clientMaxBodySize: string;
    clientMaxHeaderSize: string;
    clientMaxRequestSize: string;
    closeServerSideConnectionOnError: string;
    collectClientTlsFingerprint: string;
    compressionProfiles: outputs.GetApplicationprofileHttpProfileCompressionProfile[];
    connectionMultiplexingEnabled: string;
    detectNtlmApp: string;
    disableKeepalivePostsMsie6: string;
    disableSniHostnameCheck: string;
    enableChunkMerge: string;
    enableFireAndForget: string;
    enableRequestBodyBuffering: string;
    enableRequestBodyMetrics: string;
    fwdCloseHdrForBoundConnections: string;
    hstsEnabled: string;
    hstsMaxAge: string;
    hstsSubdomainsEnabled: string;
    http2Profiles: outputs.GetApplicationprofileHttpProfileHttp2Profile[];
    httpToHttps: string;
    httpUpstreamBufferSize: string;
    httponlyEnabled: string;
    keepaliveHeader: string;
    keepaliveTimeout: string;
    maxBadRpsCip: string;
    maxBadRpsCipUri: string;
    maxBadRpsUri: string;
    maxHeaderCount: string;
    maxKeepaliveRequests: string;
    maxResponseHeadersSize: string;
    maxRpsCip: string;
    maxRpsCipUri: string;
    maxRpsUnknownCip: string;
    maxRpsUnknownUri: string;
    maxRpsUri: string;
    passThroughXAccelHeaders: string;
    pkiProfileRef: string;
    postAcceptTimeout: string;
    resetConnHttpOnSslPort: string;
    respondWith100Continue: string;
    secureCookieEnabled: string;
    serverSideRedirectToHttps: string;
    sessionConfigs: outputs.GetApplicationprofileHttpProfileSessionConfig[];
    sslClientCertificateActions: outputs.GetApplicationprofileHttpProfileSslClientCertificateAction[];
    sslClientCertificateMode: string;
    trueClientIps: outputs.GetApplicationprofileHttpProfileTrueClientIp[];
    useAppKeepaliveTimeout: string;
    useTrueClientIp: string;
    websocketsEnabled: string;
    xForwardedProtoEnabled: string;
    xffAlternateName: string;
    xffEnabled: string;
    xffUpdate: string;
}

export interface GetApplicationprofileHttpProfileCacheConfig {
    ageHeader: string;
    aggressive: string;
    dateHeader: string;
    defaultExpire: string;
    enabled: string;
    heuristicExpire: string;
    ignoreRequestCacheControl: string;
    maxCacheSize: string;
    maxObjectSize: string;
    mimeTypesBlockGroupRefs: string[];
    mimeTypesBlockLists: string[];
    mimeTypesGroupRefs: string[];
    mimeTypesLists: string[];
    minObjectSize: string;
    queryCacheable: string;
    uriNonCacheables: outputs.GetApplicationprofileHttpProfileCacheConfigUriNonCacheable[];
    xcacheHeader: string;
}

export interface GetApplicationprofileHttpProfileCacheConfigUriNonCacheable {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetApplicationprofileHttpProfileCompressionProfile {
    bufNum: string;
    bufSize: string;
    compressibleContentRef: string;
    compression: string;
    filters: outputs.GetApplicationprofileHttpProfileCompressionProfileFilter[];
    hashSize: string;
    levelAggressive: string;
    levelNormal: string;
    maxLowRtt: string;
    minHighRtt: string;
    minLength: string;
    mobileStrRef: string;
    removeAcceptEncodingHeader: string;
    type: string;
    windowSize: string;
}

export interface GetApplicationprofileHttpProfileCompressionProfileFilter {
    devicesRef: string;
    index: string;
    ipAddrPrefixes: outputs.GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefix[];
    ipAddrRanges: outputs.GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrRange[];
    ipAddrs: outputs.GetApplicationprofileHttpProfileCompressionProfileFilterIpAddr[];
    ipAddrsRef: string;
    level: string;
    match: string;
    name: string;
    userAgents: string[];
}

export interface GetApplicationprofileHttpProfileCompressionProfileFilterIpAddr {
    addr: string;
    type: string;
}

export interface GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefix {
    ipAddrs: outputs.GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefixIpAddr[];
    mask: string;
}

export interface GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrRange {
    begins: outputs.GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeBegin[];
    ends: outputs.GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeEnd[];
}

export interface GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeBegin {
    addr: string;
    type: string;
}

export interface GetApplicationprofileHttpProfileCompressionProfileFilterIpAddrRangeEnd {
    addr: string;
    type: string;
}

export interface GetApplicationprofileHttpProfileHttp2Profile {
    enableHttp2ServerPush: string;
    http2InitialWindowSize: string;
    maxHttp2ConcurrentPushesPerConnection: string;
    maxHttp2ConcurrentStreamsPerConnection: string;
    maxHttp2ControlFramesPerConnection: string;
    maxHttp2EmptyDataFramesPerConnection: string;
    maxHttp2HeaderFieldSize: string;
    maxHttp2QueuedFramesToClientPerConnection: string;
    maxHttp2RequestsPerConnection: string;
}

export interface GetApplicationprofileHttpProfileSessionConfig {
    sessionCookieHttponly: string;
    sessionCookieName: string;
    sessionCookieSamesite: string;
    sessionCookieSecure: string;
    sessionEstablishmentTimeout: string;
    sessionIdleTimeout: string;
    sessionMaximumTimeout: string;
}

export interface GetApplicationprofileHttpProfileSslClientCertificateAction {
    closeConnection: string;
    headers: outputs.GetApplicationprofileHttpProfileSslClientCertificateActionHeader[];
}

export interface GetApplicationprofileHttpProfileSslClientCertificateActionHeader {
    requestHeader: string;
    requestHeaderValue: string;
}

export interface GetApplicationprofileHttpProfileTrueClientIp {
    direction: string;
    headers: string[];
    indexInHeader: string;
}

export interface GetApplicationprofileL4SslProfile {
    sslStreamIdleTimeout: string;
}

export interface GetApplicationprofileMarker {
    key: string;
    values: string[];
}

export interface GetApplicationprofileSipServiceProfile {
    transactionTimeout: string;
}

export interface GetApplicationprofileTcpAppProfile {
    ftpProfiles: outputs.GetApplicationprofileTcpAppProfileFtpProfile[];
    pkiProfileRef: string;
    proxyProtocolEnabled: string;
    proxyProtocolVersion: string;
    sslClientCertificateMode: string;
}

export interface GetApplicationprofileTcpAppProfileFtpProfile {
    deactivateActive: string;
    deactivatePassive: string;
}

export interface GetAuthmappingprofileConfigpbAttribute {
    version: string;
}

export interface GetAuthmappingprofileMappingRule {
    assignPolicy: string;
    assignRole: string;
    assignTenant: string;
    assignUserprofile: string;
    attributeMatches: outputs.GetAuthmappingprofileMappingRuleAttributeMatch[];
    defaultTenantRef: string;
    groupMatches: outputs.GetAuthmappingprofileMappingRuleGroupMatch[];
    index: string;
    isSuperuser: string;
    policyAttributeName: string;
    roleAttributeName: string;
    roleRefs: string[];
    tenantAttributeName: string;
    tenantRefs: string[];
    userprofileAttributeName: string;
    userprofileRef: string;
}

export interface GetAuthmappingprofileMappingRuleAttributeMatch {
    criteria: string;
    name: string;
    values: string[];
}

export interface GetAuthmappingprofileMappingRuleGroupMatch {
    criteria: string;
    groups: string[];
}

export interface GetAuthprofileConfigpbAttribute {
    version: string;
}

export interface GetAuthprofileHttp {
    cacheExpirationTime: string;
    requestHeader: string;
    requireUserGroups: string[];
}

export interface GetAuthprofileLdap {
    baseDn: string;
    bindAsAdministrator: string;
    emailAttribute: string;
    fullNameAttribute: string;
    port: string;
    securityMode: string;
    servers: string[];
    settings: outputs.GetAuthprofileLdapSetting[];
    userBinds: outputs.GetAuthprofileLdapUserBind[];
}

export interface GetAuthprofileLdapSetting {
    adminBindDn: string;
    groupFilter: string;
    groupMemberAttribute: string;
    groupMemberIsFullDn: string;
    groupSearchDn: string;
    groupSearchScope: string;
    ignoreReferrals: string;
    password: string;
    userAttributes: string[];
    userIdAttribute: string;
    userSearchDn: string;
    userSearchScope: string;
}

export interface GetAuthprofileLdapUserBind {
    dnTemplate: string;
    token: string;
    userAttributes: string[];
    userIdAttribute: string;
}

export interface GetAuthprofileMarker {
    key: string;
    values: string[];
}

export interface GetAuthprofileOauthProfile {
    authorizationEndpoint: string;
    endSessionEndpoint: string;
    instanceId: string;
    introspectionEndpoint: string;
    issuer: string;
    jwksTimeout: string;
    jwksUri: string;
    oauthControllerSettings: outputs.GetAuthprofileOauthProfileOauthControllerSetting[];
    oauthProfileType: string;
    oauthProvider: string;
    oauthRespBufferSz: string;
    orgId: string;
    poolRef: string;
    redirectUri: string;
    serviceId: string;
    serviceName: string;
    tokenEndpoint: string;
    userinfoEndpoint: string;
}

export interface GetAuthprofileOauthProfileOauthControllerSetting {
    clientId: string;
    clientSecret: string;
    oidcConfigs: outputs.GetAuthprofileOauthProfileOauthControllerSettingOidcConfig[];
    scopes: string[];
}

export interface GetAuthprofileOauthProfileOauthControllerSettingOidcConfig {
    oidcEnable: string;
    profile: string;
    userinfo: string;
}

export interface GetAuthprofileSaml {
    idps: outputs.GetAuthprofileSamlIdp[];
    sps: outputs.GetAuthprofileSamlSp[];
}

export interface GetAuthprofileSamlIdp {
    metaDataDownloadInterval: string;
    metadata: string;
    metadataUrl: string;
    periodicDownload: string;
}

export interface GetAuthprofileSamlSp {
    fqdn: string;
    orgDisplayName: string;
    orgName: string;
    orgUrl: string;
    samlEntityType: string;
    spNodes: outputs.GetAuthprofileSamlSpSpNode[];
    techContactEmail: string;
    techContactName: string;
}

export interface GetAuthprofileSamlSpSpNode {
    entityId: string;
    name: string;
    signingSslKeyAndCertificateRef: string;
    singleSignonUrl: string;
}

export interface GetAuthprofileTacacsPlus {
    authorizationAttrs: outputs.GetAuthprofileTacacsPlusAuthorizationAttr[];
    password: string;
    port: string;
    servers: string[];
    service: string;
}

export interface GetAuthprofileTacacsPlusAuthorizationAttr {
    mandatory: string;
    name: string;
    value: string;
}

export interface GetAutoscalelaunchconfigConfigpbAttribute {
    version: string;
}

export interface GetAutoscalelaunchconfigMarker {
    key: string;
    values: string[];
}

export interface GetAutoscalelaunchconfigMeso {
    force: string;
}

export interface GetAutoscalelaunchconfigOpenstack {
    heatScaleDownUrl: string;
    heatScaleUpUrl: string;
}

export interface GetAvailabilityzoneConfigpbAttribute {
    version: string;
}

export interface GetBackupconfigurationConfigpbAttribute {
    version: string;
}

export interface GetBotdetectionpolicyAllowList {
    rules: outputs.GetBotdetectionpolicyAllowListRule[];
}

export interface GetBotdetectionpolicyAllowListRule {
    action: string;
    conditions: outputs.GetBotdetectionpolicyAllowListRuleCondition[];
    index: string;
    name: string;
}

export interface GetBotdetectionpolicyAllowListRuleCondition {
    botDetectionResults: outputs.GetBotdetectionpolicyAllowListRuleConditionBotDetectionResult[];
    clientIps: outputs.GetBotdetectionpolicyAllowListRuleConditionClientIp[];
    cookies: outputs.GetBotdetectionpolicyAllowListRuleConditionCookie[];
    geoMatches: outputs.GetBotdetectionpolicyAllowListRuleConditionGeoMatch[];
    hdrs: outputs.GetBotdetectionpolicyAllowListRuleConditionHdr[];
    hostHdrs: outputs.GetBotdetectionpolicyAllowListRuleConditionHostHdr[];
    ipReputationTypes: outputs.GetBotdetectionpolicyAllowListRuleConditionIpReputationType[];
    methods: outputs.GetBotdetectionpolicyAllowListRuleConditionMethod[];
    paths: outputs.GetBotdetectionpolicyAllowListRuleConditionPath[];
    protocols: outputs.GetBotdetectionpolicyAllowListRuleConditionProtocol[];
    queries: outputs.GetBotdetectionpolicyAllowListRuleConditionQuery[];
    sourceIps: outputs.GetBotdetectionpolicyAllowListRuleConditionSourceIp[];
    tlsFingerprintMatches: outputs.GetBotdetectionpolicyAllowListRuleConditionTlsFingerprintMatch[];
    versions: outputs.GetBotdetectionpolicyAllowListRuleConditionVersion[];
    vsPorts: outputs.GetBotdetectionpolicyAllowListRuleConditionVsPort[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionBotDetectionResult {
    classifications: outputs.GetBotdetectionpolicyAllowListRuleConditionBotDetectionResultClassification[];
    matchOperation: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionClientIp {
    addrs: outputs.GetBotdetectionpolicyAllowListRuleConditionClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetBotdetectionpolicyAllowListRuleConditionClientIpPrefix[];
    ranges: outputs.GetBotdetectionpolicyAllowListRuleConditionClientIpRange[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionClientIpAddr {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionClientIpPrefix {
    ipAddrs: outputs.GetBotdetectionpolicyAllowListRuleConditionClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionClientIpRange {
    begins: outputs.GetBotdetectionpolicyAllowListRuleConditionClientIpRangeBegin[];
    ends: outputs.GetBotdetectionpolicyAllowListRuleConditionClientIpRangeEnd[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionCookie {
    matchCase: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionQuery {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionSourceIp {
    addrs: outputs.GetBotdetectionpolicyAllowListRuleConditionSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetBotdetectionpolicyAllowListRuleConditionSourceIpPrefix[];
    ranges: outputs.GetBotdetectionpolicyAllowListRuleConditionSourceIpRange[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionSourceIpPrefix {
    ipAddrs: outputs.GetBotdetectionpolicyAllowListRuleConditionSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionSourceIpRange {
    begins: outputs.GetBotdetectionpolicyAllowListRuleConditionSourceIpRangeBegin[];
    ends: outputs.GetBotdetectionpolicyAllowListRuleConditionSourceIpRangeEnd[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetBotdetectionpolicyAllowListRuleConditionTlsFingerprintMatch {
    fingerprints: string[];
    matchOperation: string;
    stringGroupRefs: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionVersion {
    matchCriteria: string;
    versions: string[];
}

export interface GetBotdetectionpolicyAllowListRuleConditionVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetBotdetectionpolicyClientBehaviorDetector {
    badRequestPercent: string;
    enabled: string;
    minimumRequests: string;
    minimumRequestsWithReferer: string;
}

export interface GetBotdetectionpolicyIpLocationDetector {
    enabled: string;
    ipLocationDbRef: string;
    systemCloudProvidersRef: string;
    systemSearchEnginesRef: string;
}

export interface GetBotdetectionpolicyIpReputationDetector {
    enabled: string;
    ipReputationDbRef: string;
    systemIpReputationMappingRef: string;
}

export interface GetBotdetectionpolicyUserAgentDetector {
    enabled: string;
    useTlsFingerprint: string;
}

export interface GetBotipreputationtypemappingIpReputationMapping {
    botIdentifications: outputs.GetBotipreputationtypemappingIpReputationMappingBotIdentification[];
    ipReputationType: string;
}

export interface GetBotipreputationtypemappingIpReputationMappingBotIdentification {
    class: string;
    identifier: string;
    type: string;
}

export interface GetBotmappingMappingRule {
    classifications: outputs.GetBotmappingMappingRuleClassification[];
    index: string;
    matches: outputs.GetBotmappingMappingRuleMatch[];
    name: string;
}

export interface GetBotmappingMappingRuleClassification {
    type: string;
    userDefinedType: string;
}

export interface GetBotmappingMappingRuleMatch {
    classMatchers: outputs.GetBotmappingMappingRuleMatchClassMatcher[];
    clientIps: outputs.GetBotmappingMappingRuleMatchClientIp[];
    componentMatcher: string;
    hdrs: outputs.GetBotmappingMappingRuleMatchHdr[];
    hostHdrs: outputs.GetBotmappingMappingRuleMatchHostHdr[];
    identifierMatchers: outputs.GetBotmappingMappingRuleMatchIdentifierMatcher[];
    methods: outputs.GetBotmappingMappingRuleMatchMethod[];
    paths: outputs.GetBotmappingMappingRuleMatchPath[];
    typeMatchers: outputs.GetBotmappingMappingRuleMatchTypeMatcher[];
}

export interface GetBotmappingMappingRuleMatchClassMatcher {
    clientClasses: string[];
    op: string;
}

export interface GetBotmappingMappingRuleMatchClientIp {
    addrs: outputs.GetBotmappingMappingRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetBotmappingMappingRuleMatchClientIpPrefix[];
    ranges: outputs.GetBotmappingMappingRuleMatchClientIpRange[];
}

export interface GetBotmappingMappingRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetBotmappingMappingRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetBotmappingMappingRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetBotmappingMappingRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetBotmappingMappingRuleMatchClientIpRange {
    begins: outputs.GetBotmappingMappingRuleMatchClientIpRangeBegin[];
    ends: outputs.GetBotmappingMappingRuleMatchClientIpRangeEnd[];
}

export interface GetBotmappingMappingRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetBotmappingMappingRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetBotmappingMappingRuleMatchHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetBotmappingMappingRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetBotmappingMappingRuleMatchIdentifierMatcher {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetBotmappingMappingRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetBotmappingMappingRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetBotmappingMappingRuleMatchTypeMatcher {
    clientTypes: string[];
    op: string;
}

export interface GetCertificatemanagementprofileConfigpbAttribute {
    version: string;
}

export interface GetCertificatemanagementprofileMarker {
    key: string;
    values: string[];
}

export interface GetCertificatemanagementprofileScriptParam {
    isDynamic: string;
    isSensitive: string;
    name: string;
    value: string;
}

export interface GetCloudAwsConfiguration {
    accessKeyId: string;
    asgPollInterval: string;
    ebsEncryptions: outputs.GetCloudAwsConfigurationEbsEncryption[];
    freeElasticips: string;
    iamAssumeRole: string;
    publishVipToPublicZone: string;
    region: string;
    route53Integration: string;
    s3Encryptions: outputs.GetCloudAwsConfigurationS3Encryption[];
    secretAccessKey: string;
    sqsEncryptions: outputs.GetCloudAwsConfigurationSqsEncryption[];
    ttl: string;
    useIamRoles: string;
    useSnsSqs: string;
    vpc: string;
    vpcId: string;
    zones: outputs.GetCloudAwsConfigurationZone[];
}

export interface GetCloudAwsConfigurationEbsEncryption {
    masterKey: string;
    mode: string;
}

export interface GetCloudAwsConfigurationS3Encryption {
    masterKey: string;
    mode: string;
}

export interface GetCloudAwsConfigurationSqsEncryption {
    masterKey: string;
    mode: string;
}

export interface GetCloudAwsConfigurationZone {
    availabilityZone: string;
    mgmtNetworkName: string;
    mgmtNetworkUuid: string;
}

export interface GetCloudAzureConfiguration {
    availabilityZones: string[];
    cloudCredentialsRef: string;
    desId: string;
    location: string;
    networkInfos: outputs.GetCloudAzureConfigurationNetworkInfo[];
    resourceGroup: string;
    seStorageAccount: string;
    subscriptionId: string;
    useAzureDns: string;
    useEnhancedHa: string;
    useManagedDisks: string;
    useStandardAlb: string;
}

export interface GetCloudAzureConfigurationNetworkInfo {
    managementNetworkId: string;
    seNetworkId: string;
    virtualNetworkId: string;
}

export interface GetCloudCloudstackConfiguration {
    accessKeyId: string;
    apiUrl: string;
    cntrPublicIp: string;
    hypervisor: string;
    mgmtNetworkName: string;
    mgmtNetworkUuid: string;
    secretAccessKey: string;
}

export interface GetCloudConfigpbAttribute {
    version: string;
}

export interface GetCloudCustomTag {
    tagKey: string;
    tagVal: string;
}

export interface GetCloudDnsResolver {
    fixedTtl: string;
    minTtl: string;
    nameserverIps: outputs.GetCloudDnsResolverNameserverIp[];
    resolverName: string;
    useMgmt: string;
}

export interface GetCloudDnsResolverNameserverIp {
    addr: string;
    type: string;
}

export interface GetCloudDockerConfiguration {
    appSyncFrequency: string;
    caTlsKeyAndCertificateRef: string;
    clientTlsKeyAndCertificateRef: string;
    containerPortMatchHttpService: string;
    coredumpDirectory: string;
    disableAutoBackendServiceSync: string;
    disableAutoFrontendServiceSync: string;
    disableAutoSeCreation: string;
    dockerRegistrySes: outputs.GetCloudDockerConfigurationDockerRegistrySe[];
    eastWestPlacementSubnets: outputs.GetCloudDockerConfigurationEastWestPlacementSubnet[];
    enableEventSubscription: string;
    feproxyContainerPortAsService: string;
    feproxyVipsEnableProxyArp: string;
    fleetEndpoint: string;
    httpContainerPorts: number[];
    seDeploymentMethod: string;
    seExcludeAttributes: outputs.GetCloudDockerConfigurationSeExcludeAttribute[];
    seIncludeAttributes: outputs.GetCloudDockerConfigurationSeIncludeAttribute[];
    seSpawnRate: string;
    seVolume: string;
    servicesAccessibleAllInterfaces: string;
    sshUserRef: string;
    ucpNodes: string[];
    useContainerIpPort: string;
    useControllerImage: string;
}

export interface GetCloudDockerConfigurationDockerRegistrySe {
    oshiftRegistries: outputs.GetCloudDockerConfigurationDockerRegistrySeOshiftRegistry[];
    password: string;
    private: string;
    registry: string;
    username: string;
}

export interface GetCloudDockerConfigurationDockerRegistrySeOshiftRegistry {
    registryNamespace: string;
    registryService: string;
    registryVips: outputs.GetCloudDockerConfigurationDockerRegistrySeOshiftRegistryRegistryVip[];
}

export interface GetCloudDockerConfigurationDockerRegistrySeOshiftRegistryRegistryVip {
    addr: string;
    type: string;
}

export interface GetCloudDockerConfigurationEastWestPlacementSubnet {
    ipAddrs: outputs.GetCloudDockerConfigurationEastWestPlacementSubnetIpAddr[];
    mask: string;
}

export interface GetCloudDockerConfigurationEastWestPlacementSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetCloudDockerConfigurationSeExcludeAttribute {
    attribute: string;
    value: string;
}

export interface GetCloudDockerConfigurationSeIncludeAttribute {
    attribute: string;
    value: string;
}

export interface GetCloudGcpConfiguration {
    cloudCredentialsRef: string;
    encryptionKeys: outputs.GetCloudGcpConfigurationEncryptionKey[];
    firewallTargetTags: string[];
    gcpServiceAccountEmail: string;
    gcsBucketName: string;
    gcsProjectId: string;
    networkConfigs: outputs.GetCloudGcpConfigurationNetworkConfig[];
    regionName: string;
    seProjectId: string;
    vipAllocationStrategies: outputs.GetCloudGcpConfigurationVipAllocationStrategy[];
    zones: string[];
}

export interface GetCloudGcpConfigurationEncryptionKey {
    gcsBucketKmsKeyId: string;
    gcsObjectsKmsKeyId: string;
    seDiskKmsKeyId: string;
    seImageKmsKeyId: string;
}

export interface GetCloudGcpConfigurationNetworkConfig {
    config: string;
    inbands: outputs.GetCloudGcpConfigurationNetworkConfigInband[];
    oneArms: outputs.GetCloudGcpConfigurationNetworkConfigOneArm[];
    twoArms: outputs.GetCloudGcpConfigurationNetworkConfigTwoArm[];
}

export interface GetCloudGcpConfigurationNetworkConfigInband {
    vpcNetworkName: string;
    vpcProjectId: string;
    vpcSubnetName: string;
}

export interface GetCloudGcpConfigurationNetworkConfigOneArm {
    dataVpcNetworkName: string;
    dataVpcProjectId: string;
    dataVpcSubnetName: string;
    managementVpcNetworkName: string;
    managementVpcProjectId: string;
    managementVpcSubnetName: string;
}

export interface GetCloudGcpConfigurationNetworkConfigTwoArm {
    backendDataVpcNetworkName: string;
    backendDataVpcProjectId: string;
    backendDataVpcSubnetName: string;
    frontendDataVpcNetworkName: string;
    frontendDataVpcProjectId: string;
    frontendDataVpcSubnetName: string;
    managementVpcNetworkName: string;
    managementVpcProjectId: string;
    managementVpcSubnetName: string;
}

export interface GetCloudGcpConfigurationVipAllocationStrategy {
    ilbs: outputs.GetCloudGcpConfigurationVipAllocationStrategyIlb[];
    mode: string;
    routes: outputs.GetCloudGcpConfigurationVipAllocationStrategyRoute[];
}

export interface GetCloudGcpConfigurationVipAllocationStrategyIlb {
    cloudRouterNames: string[];
}

export interface GetCloudGcpConfigurationVipAllocationStrategyRoute {
    matchSeGroupSubnet: string;
    routePriority: string;
}

export interface GetCloudLinuxserverConfiguration {
    hosts: outputs.GetCloudLinuxserverConfigurationHost[];
    seInbandMgmt: string;
    seLogDiskPath: string;
    seLogDiskSizeGb: string;
    seSysDiskPath: string;
    seSysDiskSizeGb: string;
    sshUserRef: string;
}

export interface GetCloudLinuxserverConfigurationHost {
    hostAttrs: outputs.GetCloudLinuxserverConfigurationHostHostAttr[];
    hostIps: outputs.GetCloudLinuxserverConfigurationHostHostIp[];
    nodeAvailabilityZone: string;
    seGroupRef: string;
}

export interface GetCloudLinuxserverConfigurationHostHostAttr {
    attrKey: string;
    attrVal: string;
}

export interface GetCloudLinuxserverConfigurationHostHostIp {
    addr: string;
    type: string;
}

export interface GetCloudMarker {
    key: string;
    values: string[];
}

export interface GetCloudNsxtConfiguration {
    automateDfwObjects: string;
    automateDfwRules: string;
    dataNetworkConfigs: outputs.GetCloudNsxtConfigurationDataNetworkConfig[];
    domainId: string;
    enforcementpointId: string;
    managementNetworkConfigs: outputs.GetCloudNsxtConfigurationManagementNetworkConfig[];
    nsxtCredentialsRef: string;
    nsxtUrl: string;
    siteId: string;
    vmcMode: string;
    vpcMode: string;
}

export interface GetCloudNsxtConfigurationDataNetworkConfig {
    tier1SegmentConfigs: outputs.GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfig[];
    transportZone: string;
    tzType: string;
    vlanSegments: string[];
}

export interface GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfig {
    automatics: outputs.GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomatic[];
    manuals: outputs.GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManual[];
    segmentConfigMode: string;
}

export interface GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomatic {
    nsxtSegmentSubnets: outputs.GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnet[];
    numSePerSegment: string;
    tier1LrIds: string[];
}

export interface GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnet {
    ipAddrs: outputs.GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnetIpAddr[];
    mask: string;
}

export interface GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigAutomaticNsxtSegmentSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManual {
    tier1Lrs: outputs.GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManualTier1Lr[];
}

export interface GetCloudNsxtConfigurationDataNetworkConfigTier1SegmentConfigManualTier1Lr {
    localeService: string;
    segmentId: string;
    tier1LrId: string;
}

export interface GetCloudNsxtConfigurationManagementNetworkConfig {
    overlaySegments: outputs.GetCloudNsxtConfigurationManagementNetworkConfigOverlaySegment[];
    transportZone: string;
    tzType: string;
    vlanSegment: string;
}

export interface GetCloudNsxtConfigurationManagementNetworkConfigOverlaySegment {
    localeService: string;
    segmentId: string;
    tier1LrId: string;
}

export interface GetCloudNtpConfiguration {
    ntpAuthenticationKeys: outputs.GetCloudNtpConfigurationNtpAuthenticationKey[];
    ntpServerLists: outputs.GetCloudNtpConfigurationNtpServerList[];
    ntpServers: outputs.GetCloudNtpConfigurationNtpServer[];
}

export interface GetCloudNtpConfigurationNtpAuthenticationKey {
    algorithm: string;
    key: string;
    keyNumber: string;
}

export interface GetCloudNtpConfigurationNtpServer {
    keyNumber: string;
    servers: outputs.GetCloudNtpConfigurationNtpServerServer[];
}

export interface GetCloudNtpConfigurationNtpServerList {
    addr: string;
    type: string;
}

export interface GetCloudNtpConfigurationNtpServerServer {
    addr: string;
    type: string;
}

export interface GetCloudOpenstackConfiguration {
    adminTenant: string;
    adminTenantUuid: string;
    allowedAddressPairs: string;
    antiAffinity: string;
    authUrl: string;
    configDrive: string;
    contrailDisablePolicy: string;
    contrailEndpoint: string;
    contrailPlugin: string;
    customSeImageProperties: outputs.GetCloudOpenstackConfigurationCustomSeImageProperty[];
    enableOsObjectCaching: string;
    enableTagging: string;
    externalNetworks: string;
    freeFloatingips: string;
    hypervisor: string;
    hypervisorProperties: outputs.GetCloudOpenstackConfigurationHypervisorProperty[];
    imgFormat: string;
    importKeystoneTenants: string;
    insecure: string;
    keystoneHost: string;
    mapAdminToCloudadmin: string;
    mgmtNetworkName: string;
    mgmtNetworkUuid: string;
    nameOwner: string;
    neutronRbac: string;
    password: string;
    privilege: string;
    provNames: string[];
    providerVipNetworks: outputs.GetCloudOpenstackConfigurationProviderVipNetwork[];
    region: string;
    roleMappings: outputs.GetCloudOpenstackConfigurationRoleMapping[];
    securityGroups: string;
    tenantSe: string;
    useAdminUrl: string;
    useInternalEndpoints: string;
    useKeystoneAuth: string;
    username: string;
    vipPortInAdminTenant: string;
}

export interface GetCloudOpenstackConfigurationCustomSeImageProperty {
    name: string;
    value: string;
}

export interface GetCloudOpenstackConfigurationHypervisorProperty {
    hypervisor: string;
    imageProperties: outputs.GetCloudOpenstackConfigurationHypervisorPropertyImageProperty[];
}

export interface GetCloudOpenstackConfigurationHypervisorPropertyImageProperty {
    name: string;
    value: string;
}

export interface GetCloudOpenstackConfigurationProviderVipNetwork {
    osNetworkUuid: string;
    osTenantUuids: string[];
}

export interface GetCloudOpenstackConfigurationRoleMapping {
    aviRole: string;
    osRole: string;
}

export interface GetCloudProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface GetCloudRancherConfiguration {
    accessKey: string;
    appSyncFrequency: string;
    containerPortMatchHttpService: string;
    coredumpDirectory: string;
    disableAutoBackendServiceSync: string;
    disableAutoFrontendServiceSync: string;
    disableAutoSeCreation: string;
    dockerRegistrySes: outputs.GetCloudRancherConfigurationDockerRegistrySe[];
    eastWestPlacementSubnets: outputs.GetCloudRancherConfigurationEastWestPlacementSubnet[];
    enableEventSubscription: string;
    feproxyContainerPortAsService: string;
    feproxyVipsEnableProxyArp: string;
    fleetEndpoint: string;
    httpContainerPorts: number[];
    nuageControllers: outputs.GetCloudRancherConfigurationNuageController[];
    rancherServers: string[];
    seDeploymentMethod: string;
    seExcludeAttributes: outputs.GetCloudRancherConfigurationSeExcludeAttribute[];
    seIncludeAttributes: outputs.GetCloudRancherConfigurationSeIncludeAttribute[];
    seSpawnRate: string;
    seVolume: string;
    secretKey: string;
    servicesAccessibleAllInterfaces: string;
    sshUserRef: string;
    useContainerIpPort: string;
    useControllerImage: string;
}

export interface GetCloudRancherConfigurationDockerRegistrySe {
    oshiftRegistries: outputs.GetCloudRancherConfigurationDockerRegistrySeOshiftRegistry[];
    password: string;
    private: string;
    registry: string;
    username: string;
}

export interface GetCloudRancherConfigurationDockerRegistrySeOshiftRegistry {
    registryNamespace: string;
    registryService: string;
    registryVips: outputs.GetCloudRancherConfigurationDockerRegistrySeOshiftRegistryRegistryVip[];
}

export interface GetCloudRancherConfigurationDockerRegistrySeOshiftRegistryRegistryVip {
    addr: string;
    type: string;
}

export interface GetCloudRancherConfigurationEastWestPlacementSubnet {
    ipAddrs: outputs.GetCloudRancherConfigurationEastWestPlacementSubnetIpAddr[];
    mask: string;
}

export interface GetCloudRancherConfigurationEastWestPlacementSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetCloudRancherConfigurationNuageController {
    nuageOrganization: string;
    nuagePassword: string;
    nuagePort: string;
    nuageUsername: string;
    nuageVsdHost: string;
    seDomain: string;
    seEnterprise: string;
    seNetwork: string;
    sePolicyGroup: string;
    seUser: string;
    seZone: string;
}

export interface GetCloudRancherConfigurationSeExcludeAttribute {
    attribute: string;
    value: string;
}

export interface GetCloudRancherConfigurationSeIncludeAttribute {
    attribute: string;
    value: string;
}

export interface GetCloudVcaConfiguration {
    privilege: string;
    vcaHost: string;
    vcaInstance: string;
    vcaMgmtNetwork: string;
    vcaOrgnization: string;
    vcaPassword: string;
    vcaUsername: string;
    vcaVdc: string;
}

export interface GetCloudVcenterConfiguration {
    contentLibs: outputs.GetCloudVcenterConfigurationContentLib[];
    datacenter: string;
    datacenterManagedObjectId: string;
    isNsxEnvironment: string;
    managementIpSubnets: outputs.GetCloudVcenterConfigurationManagementIpSubnet[];
    managementNetwork: string;
    password: string;
    privilege: string;
    useContentLib: string;
    username: string;
    vcenterTemplateSeLocation: string;
    vcenterUrl: string;
}

export interface GetCloudVcenterConfigurationContentLib {
    id: string;
    name: string;
}

export interface GetCloudVcenterConfigurationManagementIpSubnet {
    ipAddrs: outputs.GetCloudVcenterConfigurationManagementIpSubnetIpAddr[];
    mask: string;
}

export interface GetCloudVcenterConfigurationManagementIpSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetCloudconnectoruserAzureServiceprincipal {
    applicationId: string;
    authenticationToken: string;
    tenantId: string;
}

export interface GetCloudconnectoruserAzureUserpass {
    password: string;
    tenantName: string;
    username: string;
}

export interface GetCloudconnectoruserConfigpbAttribute {
    version: string;
}

export interface GetCloudconnectoruserGcpCredential {
    serviceAccountKeyfileData: string;
}

export interface GetCloudconnectoruserNsxtCredential {
    password: string;
    username: string;
}

export interface GetCloudconnectoruserOciCredential {
    fingerprint: string;
    keyContent: string;
    passPhrase: string;
    user: string;
}

export interface GetCloudconnectoruserTencentCredential {
    secretId: string;
    secretKey: string;
}

export interface GetCloudconnectoruserVcenterCredential {
    password: string;
    username: string;
}

export interface GetCloudpropertiesCcProp {
    rpcPollInterval: string;
    rpcQueueSize: string;
}

export interface GetCloudpropertiesConfigpbAttribute {
    version: string;
}

export interface GetCloudpropertiesHypProp {
    htype: string;
    maxIpsPerNic: string;
    maxNics: string;
}

export interface GetCloudpropertiesInfo {
    ccaProps: outputs.GetCloudpropertiesInfoCcaProp[];
    controllerProps: outputs.GetCloudpropertiesInfoControllerProp[];
    flavorProps: outputs.GetCloudpropertiesInfoFlavorProp[];
    flavorRegexFilter: string;
    htypes: string[];
    vtype: string;
}

export interface GetCloudpropertiesInfoCcaProp {
    asyncRetries: string;
    asyncRetriesDelay: string;
    pollDurationTarget: string;
    pollFastTarget: string;
    pollSlowTarget: string;
    vcenterHostPingInterval: string;
    vcenterInventoryMaxObjectUpdates: string;
    vcenterMaxDatastoreGoRoutines: string;
    vcenterReconcileInterval: string;
    vnicRetries: string;
    vnicRetriesDelay: string;
}

export interface GetCloudpropertiesInfoControllerProp {
    alertManagerUseEvms: string;
    allowAdminNetworkUpdates: string;
    allowIpForwarding: string;
    allowUnauthenticatedApis: string;
    allowUnauthenticatedNodes: string;
    apiIdleTimeout: string;
    apiPerfLoggingThreshold: string;
    appviewxCompatMode: string;
    asyncPatchMergePeriod: string;
    asyncPatchRequestCleanupDuration: string;
    attachIpRetryInterval: string;
    attachIpRetryLimit: string;
    bmUseAnsible: string;
    checkVsvipFqdnSyntax: string;
    cleanupExpiredAuthtokenTimeoutPeriod: string;
    cleanupSessionsTimeoutPeriod: string;
    cloudDiscoveryInterval: string;
    cloudReconcile: string;
    cloudReconcileInterval: string;
    clusterIpGratuitousArpPeriod: string;
    configpbAttributes: outputs.GetCloudpropertiesInfoControllerPropConfigpbAttribute[];
    consistencyCheckTimeoutPeriod: string;
    controllerResourceInfoCollectionPeriod: string;
    crashedSeReboot: string;
    deadSeDetectionTimer: string;
    defaultMinimumApiTimeout: string;
    delOfflineSeAfterRebootDelay: string;
    detachIpRetryInterval: string;
    detachIpRetryLimit: string;
    detachIpTimeout: string;
    dnsRefreshPeriod: string;
    dummy: string;
    editSystemLimits: string;
    enableApiSharding: string;
    enableMemoryBalancer: string;
    enablePerProcessStop: string;
    enableResmgrLogCachePrint: string;
    eventManagerMaxGoroutines: string;
    eventManagerMaxSubscribers: string;
    eventManagerProcessingTimeThreshold: string;
    falsePositiveLearningConfigs: outputs.GetCloudpropertiesInfoControllerPropFalsePositiveLearningConfig[];
    fatalErrorLeaseTime: string;
    federatedDatastoreCleanupDuration: string;
    fileObjectCleanupPeriod: string;
    fileobjectMaxFileVersions: string;
    gslbPurgeBatchSize: string;
    gslbPurgeSleepTimeMs: string;
    ignoreVrfInNetworksubnetlist: string;
    maxDeadSeInGrp: string;
    maxPcapPerTenant: string;
    maxSeSpawnIntervalDelay: string;
    maxSeqAttachIpFailures: string;
    maxSeqVnicFailures: string;
    maxThreadsCcVipBgWorker: string;
    permissionScopedSharedAdminNetworks: string;
    persistenceKeyRotatePeriod: string;
    portalRequestBurstLimit: string;
    portalRequestRateLimit: string;
    portalToken: string;
    postgresVacuumPeriod: string;
    processLockedUseraccountsTimeoutPeriod: string;
    processPkiProfileTimeoutPeriod: string;
    queryHostFail: string;
    resmgrLogCachingPeriod: string;
    restrictCloudReadAccess: string;
    safenetHsmVersion: string;
    seCreateTimeout: string;
    seFailoverAttemptInterval: string;
    seFromMarketplace: string;
    seOfflineDel: string;
    seSpawnRetryInterval: string;
    seUpgradeFlowCleanupTimeout: string;
    seVnicCooldown: string;
    seVnicGcWaitTime: string;
    secureChannelCleanupTimeout: string;
    secureChannelControllerTokenTimeout: string;
    secureChannelSeTokenTimeout: string;
    seupgradeCopyBufferSize: string;
    seupgradeCopyPoolSize: string;
    seupgradeFabricPoolSize: string;
    seupgradeSegroupMinDeadTimeout: string;
    sharedSslCertificates: string;
    skopeoRetryInterval: string;
    skopeoRetryLimit: string;
    softMinMemPerSeLimit: string;
    sslCertificateExpiryWarningDays: number[];
    systemReportCleanupInterval: string;
    systemReportLimit: string;
    unresponsiveSeReboot: string;
    updateDnsEntryRetryLimit: string;
    updateDnsEntryTimeout: string;
    upgradeDnsTtl: string;
    upgradeFatSeLeaseTime: string;
    upgradeLeaseTime: string;
    upgradeSePerVsScaleOpsTxnTime: string;
    userAgentCacheConfigs: outputs.GetCloudpropertiesInfoControllerPropUserAgentCacheConfig[];
    uuid: string;
    vnicOpFailTime: string;
    vsAwaitingSeTimeout: string;
    vsKeyRotatePeriod: string;
    vsScaleoutReadyCheckInterval: string;
    vsSeAttachIpFail: string;
    vsSeBootupFail: string;
    vsSeBootupFailPatch: string;
    vsSeCreateFail: string;
    vsSePingFail: string;
    vsSeVnicFail: string;
    vsSeVnicIpFail: string;
    vsphereHaDetectionTimeout: string;
    vsphereHaRecoveryTimeout: string;
    vsphereHaTimerInterval: string;
    warmstartSeReconnectWaitTime: string;
    warmstartVsResyncWaitTime: string;
}

export interface GetCloudpropertiesInfoControllerPropConfigpbAttribute {
    version: string;
}

export interface GetCloudpropertiesInfoControllerPropFalsePositiveLearningConfig {
    maxAppsSupported: string;
    minMonitorTime: string;
    minTransPerApplication: string;
    minTransPerUri: string;
}

export interface GetCloudpropertiesInfoControllerPropUserAgentCacheConfig {
    batchSize: string;
    controllerCacheSize: string;
    maxAge: string;
    maxLastHitTime: string;
    maxUpstreamQueries: string;
    maxWaitTime: string;
    numEntriesUpstreamUpdate: string;
    percentReservedForBadBots: string;
    percentReservedForBrowsers: string;
    percentReservedForGoodBots: string;
    percentReservedForOutstanding: string;
    seCacheSize: string;
    upstreamUpdateInterval: string;
}

export interface GetCloudpropertiesInfoFlavorProp {
    cost: string;
    diskGb: string;
    enhancedNw: string;
    id: string;
    isRecommended: string;
    maxIp6sPerNic: string;
    maxIpsPerNic: string;
    maxNics: string;
    metas: outputs.GetCloudpropertiesInfoFlavorPropMeta[];
    name: string;
    public: string;
    ramMb: string;
    vcpus: string;
}

export interface GetCloudpropertiesInfoFlavorPropMeta {
    key: string;
    value: string;
}

export interface GetClusterClusterState {
    progress: string;
    state: string;
    upSince: string;
}

export interface GetClusterNode {
    categories: string[];
    interfaces: outputs.GetClusterNodeInterface[];
    ip6s: outputs.GetClusterNodeIp6[];
    ips: outputs.GetClusterNodeIp[];
    name: string;
    password: string;
    publicIpOrNames: outputs.GetClusterNodePublicIpOrName[];
    staticRoutes: outputs.GetClusterNodeStaticRoute[];
    vmHostname: string;
    vmMor: string;
    vmName: string;
    vmUuid: string;
}

export interface GetClusterNodeInterface {
    gateway6s: outputs.GetClusterNodeInterfaceGateway6[];
    gateways: outputs.GetClusterNodeInterfaceGateway[];
    ifName: string;
    ip6s: outputs.GetClusterNodeInterfaceIp6[];
    ips: outputs.GetClusterNodeInterfaceIp[];
    labels: string[];
    macAddress: string;
    mode: string;
    mode6: string;
    publicIpOrNames: outputs.GetClusterNodeInterfacePublicIpOrName[];
    v4Enabled: string;
    v6Enabled: string;
}

export interface GetClusterNodeInterfaceGateway {
    addr: string;
    type: string;
}

export interface GetClusterNodeInterfaceGateway6 {
    addr: string;
    type: string;
}

export interface GetClusterNodeInterfaceIp {
    ipAddrs: outputs.GetClusterNodeInterfaceIpIpAddr[];
    mask: string;
}

export interface GetClusterNodeInterfaceIp6 {
    ipAddrs: outputs.GetClusterNodeInterfaceIp6IpAddr[];
    mask: string;
}

export interface GetClusterNodeInterfaceIp6IpAddr {
    addr: string;
    type: string;
}

export interface GetClusterNodeInterfaceIpIpAddr {
    addr: string;
    type: string;
}

export interface GetClusterNodeInterfacePublicIpOrName {
    addr: string;
    type: string;
}

export interface GetClusterNodeIp {
    addr: string;
    type: string;
}

export interface GetClusterNodeIp6 {
    addr: string;
    type: string;
}

export interface GetClusterNodePublicIpOrName {
    addr: string;
    type: string;
}

export interface GetClusterNodeStaticRoute {
    disableGatewayMonitor: string;
    ifName: string;
    labels: outputs.GetClusterNodeStaticRouteLabel[];
    nextHops: outputs.GetClusterNodeStaticRouteNextHop[];
    prefixes: outputs.GetClusterNodeStaticRoutePrefix[];
    routeId: string;
}

export interface GetClusterNodeStaticRouteLabel {
    key: string;
    value: string;
}

export interface GetClusterNodeStaticRouteNextHop {
    addr: string;
    type: string;
}

export interface GetClusterNodeStaticRoutePrefix {
    ipAddrs: outputs.GetClusterNodeStaticRoutePrefixIpAddr[];
    mask: string;
}

export interface GetClusterNodeStaticRoutePrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetClusterVirtualIp {
    addr: string;
    type: string;
}

export interface GetClusterVirtualIp6 {
    addr: string;
    type: string;
}

export interface GetClusterclouddetailsAzureInfo {
    cloudCredentialRef: string;
    subscriptionId: string;
}

export interface GetClusterclouddetailsConfigpbAttribute {
    version: string;
}

export interface GetControllerportalregistrationAsset {
    assetId: string;
}

export interface GetControllerportalregistrationPortalAuth {
    accessToken: string;
    grantType: string;
    instanceUrl: string;
    jwtToken: string;
    tenant: string;
}

export interface GetControllerpropertiesConfigpbAttribute {
    version: string;
}

export interface GetControllerpropertiesFalsePositiveLearningConfig {
    maxAppsSupported: string;
    minMonitorTime: string;
    minTransPerApplication: string;
    minTransPerUri: string;
}

export interface GetControllerpropertiesUserAgentCacheConfig {
    batchSize: string;
    controllerCacheSize: string;
    maxAge: string;
    maxLastHitTime: string;
    maxUpstreamQueries: string;
    maxWaitTime: string;
    numEntriesUpstreamUpdate: string;
    percentReservedForBadBots: string;
    percentReservedForBrowsers: string;
    percentReservedForGoodBots: string;
    percentReservedForOutstanding: string;
    seCacheSize: string;
    upstreamUpdateInterval: string;
}

export interface GetControllersiteConfigpbAttribute {
    version: string;
}

export interface GetCsrfpolicyConfigpbAttribute {
    version: string;
}

export interface GetCsrfpolicyRule {
    action: string;
    enable: string;
    index: string;
    matches: outputs.GetCsrfpolicyRuleMatch[];
    name: string;
}

export interface GetCsrfpolicyRuleMatch {
    botDetectionResults: outputs.GetCsrfpolicyRuleMatchBotDetectionResult[];
    clientIps: outputs.GetCsrfpolicyRuleMatchClientIp[];
    cookies: outputs.GetCsrfpolicyRuleMatchCookie[];
    geoMatches: outputs.GetCsrfpolicyRuleMatchGeoMatch[];
    hdrs: outputs.GetCsrfpolicyRuleMatchHdr[];
    hostHdrs: outputs.GetCsrfpolicyRuleMatchHostHdr[];
    ipReputationTypes: outputs.GetCsrfpolicyRuleMatchIpReputationType[];
    methods: outputs.GetCsrfpolicyRuleMatchMethod[];
    paths: outputs.GetCsrfpolicyRuleMatchPath[];
    protocols: outputs.GetCsrfpolicyRuleMatchProtocol[];
    queries: outputs.GetCsrfpolicyRuleMatchQuery[];
    sourceIps: outputs.GetCsrfpolicyRuleMatchSourceIp[];
    tlsFingerprintMatches: outputs.GetCsrfpolicyRuleMatchTlsFingerprintMatch[];
    versions: outputs.GetCsrfpolicyRuleMatchVersion[];
    vsPorts: outputs.GetCsrfpolicyRuleMatchVsPort[];
}

export interface GetCsrfpolicyRuleMatchBotDetectionResult {
    classifications: outputs.GetCsrfpolicyRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface GetCsrfpolicyRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface GetCsrfpolicyRuleMatchClientIp {
    addrs: outputs.GetCsrfpolicyRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetCsrfpolicyRuleMatchClientIpPrefix[];
    ranges: outputs.GetCsrfpolicyRuleMatchClientIpRange[];
}

export interface GetCsrfpolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetCsrfpolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetCsrfpolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchClientIpRange {
    begins: outputs.GetCsrfpolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.GetCsrfpolicyRuleMatchClientIpRangeEnd[];
}

export interface GetCsrfpolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchCookie {
    matchCase: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface GetCsrfpolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface GetCsrfpolicyRuleMatchHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetCsrfpolicyRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetCsrfpolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface GetCsrfpolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetCsrfpolicyRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetCsrfpolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface GetCsrfpolicyRuleMatchQuery {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetCsrfpolicyRuleMatchSourceIp {
    addrs: outputs.GetCsrfpolicyRuleMatchSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetCsrfpolicyRuleMatchSourceIpPrefix[];
    ranges: outputs.GetCsrfpolicyRuleMatchSourceIpRange[];
}

export interface GetCsrfpolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.GetCsrfpolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetCsrfpolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchSourceIpRange {
    begins: outputs.GetCsrfpolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.GetCsrfpolicyRuleMatchSourceIpRangeEnd[];
}

export interface GetCsrfpolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetCsrfpolicyRuleMatchTlsFingerprintMatch {
    fingerprints: string[];
    matchOperation: string;
    stringGroupRefs: string[];
}

export interface GetCsrfpolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface GetCsrfpolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetCustomipamdnsprofileConfigpbAttribute {
    version: string;
}

export interface GetCustomipamdnsprofileScriptParam {
    isDynamic: string;
    isSensitive: string;
    name: string;
    value: string;
}

export interface GetDnspolicyConfigpbAttribute {
    version: string;
}

export interface GetDnspolicyMarker {
    key: string;
    values: string[];
}

export interface GetDnspolicyRule {
    actions: outputs.GetDnspolicyRuleAction[];
    enable: string;
    index: string;
    log: string;
    matches: outputs.GetDnspolicyRuleMatch[];
    name: string;
}

export interface GetDnspolicyRuleAction {
    allows: outputs.GetDnspolicyRuleActionAllow[];
    dnsRateLimiters: outputs.GetDnspolicyRuleActionDnsRateLimiter[];
    gsGroupSelections: outputs.GetDnspolicyRuleActionGsGroupSelection[];
    gslbSiteSelections: outputs.GetDnspolicyRuleActionGslbSiteSelection[];
    poolSwitchings: outputs.GetDnspolicyRuleActionPoolSwitching[];
    responses: outputs.GetDnspolicyRuleActionResponse[];
}

export interface GetDnspolicyRuleActionAllow {
    allow: string;
    resetConn: string;
}

export interface GetDnspolicyRuleActionDnsRateLimiter {
    actions: outputs.GetDnspolicyRuleActionDnsRateLimiterAction[];
    rateLimiterObjects: outputs.GetDnspolicyRuleActionDnsRateLimiterRateLimiterObject[];
}

export interface GetDnspolicyRuleActionDnsRateLimiterAction {
    type: string;
}

export interface GetDnspolicyRuleActionDnsRateLimiterRateLimiterObject {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetDnspolicyRuleActionGsGroupSelection {
    groupName: string;
}

export interface GetDnspolicyRuleActionGslbSiteSelection {
    fallbackSiteNames: string[];
    isSitePreferred: string;
    siteName: string;
}

export interface GetDnspolicyRuleActionPoolSwitching {
    poolGroupRef: string;
    poolRef: string;
}

export interface GetDnspolicyRuleActionResponse {
    authoritative: string;
    rcode: string;
    resourceRecordSets: outputs.GetDnspolicyRuleActionResponseResourceRecordSet[];
    truncation: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSet {
    resourceRecordSets: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSet[];
    section: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSet {
    cnames: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetCname[];
    fqdn: string;
    ip6Addresses: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6Address[];
    ipAddresses: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddress[];
    nses: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNse[];
    ttl: string;
    type: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetCname {
    cname: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6Address {
    ip6Addresses: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6AddressIp6Address[];
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIp6AddressIp6Address {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddress {
    ipAddresses: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddressIpAddress[];
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetIpAddressIpAddress {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNse {
    ip6Addresses: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIp6Address[];
    ipAddresses: outputs.GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIpAddress[];
    nsname: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIp6Address {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleActionResponseResourceRecordSetResourceRecordSetNseIpAddress {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleMatch {
    clientIpAddresses: outputs.GetDnspolicyRuleMatchClientIpAddress[];
    clientPortNumbers: outputs.GetDnspolicyRuleMatchClientPortNumber[];
    geoLocations: outputs.GetDnspolicyRuleMatchGeoLocation[];
    protocols: outputs.GetDnspolicyRuleMatchProtocol[];
    queryNames: outputs.GetDnspolicyRuleMatchQueryName[];
    queryTypes: outputs.GetDnspolicyRuleMatchQueryType[];
}

export interface GetDnspolicyRuleMatchClientIpAddress {
    clientIps: outputs.GetDnspolicyRuleMatchClientIpAddressClientIp[];
    useEdnsClientSubnetIp: string;
}

export interface GetDnspolicyRuleMatchClientIpAddressClientIp {
    addrs: outputs.GetDnspolicyRuleMatchClientIpAddressClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetDnspolicyRuleMatchClientIpAddressClientIpPrefix[];
    ranges: outputs.GetDnspolicyRuleMatchClientIpAddressClientIpRange[];
}

export interface GetDnspolicyRuleMatchClientIpAddressClientIpAddr {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleMatchClientIpAddressClientIpPrefix {
    ipAddrs: outputs.GetDnspolicyRuleMatchClientIpAddressClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetDnspolicyRuleMatchClientIpAddressClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleMatchClientIpAddressClientIpRange {
    begins: outputs.GetDnspolicyRuleMatchClientIpAddressClientIpRangeBegin[];
    ends: outputs.GetDnspolicyRuleMatchClientIpAddressClientIpRangeEnd[];
}

export interface GetDnspolicyRuleMatchClientIpAddressClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleMatchClientIpAddressClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetDnspolicyRuleMatchClientPortNumber {
    clientPorts: outputs.GetDnspolicyRuleMatchClientPortNumberClientPort[];
}

export interface GetDnspolicyRuleMatchClientPortNumberClientPort {
    matchCriteria: string;
    ports: number[];
    ranges: outputs.GetDnspolicyRuleMatchClientPortNumberClientPortRange[];
}

export interface GetDnspolicyRuleMatchClientPortNumberClientPortRange {
    end: string;
    start: string;
}

export interface GetDnspolicyRuleMatchGeoLocation {
    geolocationName: string;
    geolocationTag: string;
    matchCriteria: string;
    useEdnsClientSubnetIp: string;
}

export interface GetDnspolicyRuleMatchProtocol {
    matchCriteria: string;
    protocol: string;
}

export interface GetDnspolicyRuleMatchQueryName {
    matchCriteria: string;
    queryDomainNames: string[];
    stringGroupRefs: string[];
}

export interface GetDnspolicyRuleMatchQueryType {
    matchCriteria: string;
    queryTypes: string[];
}

export interface GetDynamicdnsrecordCname {
    cname: string;
}

export interface GetDynamicdnsrecordIp6Address {
    ip6Addresses: outputs.GetDynamicdnsrecordIp6AddressIp6Address[];
}

export interface GetDynamicdnsrecordIp6AddressIp6Address {
    addr: string;
    type: string;
}

export interface GetDynamicdnsrecordIpAddress {
    ipAddresses: outputs.GetDynamicdnsrecordIpAddressIpAddress[];
}

export interface GetDynamicdnsrecordIpAddressIpAddress {
    addr: string;
    type: string;
}

export interface GetDynamicdnsrecordMxRecord {
    host: string;
    priority: string;
}

export interface GetDynamicdnsrecordN {
    ip6Addresses: outputs.GetDynamicdnsrecordNIp6Address[];
    ipAddresses: outputs.GetDynamicdnsrecordNIpAddress[];
    nsname: string;
}

export interface GetDynamicdnsrecordNIp6Address {
    addr: string;
    type: string;
}

export interface GetDynamicdnsrecordNIpAddress {
    addr: string;
    type: string;
}

export interface GetDynamicdnsrecordServiceLocator {
    port: string;
    priority: string;
    target: string;
    weight: string;
}

export interface GetDynamicdnsrecordTxtRecord {
    textStr: string;
}

export interface GetErrorpagebodyConfigpbAttribute {
    version: string;
}

export interface GetErrorpagebodyMarker {
    key: string;
    values: string[];
}

export interface GetErrorpageprofileConfigpbAttribute {
    version: string;
}

export interface GetErrorpageprofileErrorPage {
    enable: string;
    errorPageBodyRef: string;
    errorRedirect: string;
    index: string;
    matches: outputs.GetErrorpageprofileErrorPageMatch[];
}

export interface GetErrorpageprofileErrorPageMatch {
    matchCriteria: string;
    ranges: outputs.GetErrorpageprofileErrorPageMatchRange[];
    statusCodes: number[];
}

export interface GetErrorpageprofileErrorPageMatchRange {
    begin: string;
    end: string;
}

export interface GetErrorpageprofileMarker {
    key: string;
    values: string[];
}

export interface GetFederationcheckpointConfigpbAttribute {
    version: string;
}

export interface GetFileobjectConfigpbAttribute {
    version: string;
}

export interface GetFileobjectCrlInfo {
    commonName: string;
    distinguishedName: string;
    etag: string;
    fingerprint: string;
    lastRefreshed: string;
    lastUpdate: string;
    nextUpdate: string;
    serverUrl: string;
    text: string;
    updateInterval: string;
}

export interface GetGeodbFile {
    enabled: string;
    fileRef: string;
    index: string;
    name: string;
    vendor: string;
}

export interface GetGeodbMapping {
    description: string;
    elements: outputs.GetGeodbMappingElement[];
    name: string;
}

export interface GetGeodbMappingElement {
    attribute: string;
    values: string[];
}

export interface GetGslbClientIpAddrGroup {
    addrs: outputs.GetGslbClientIpAddrGroupAddr[];
    prefixes: outputs.GetGslbClientIpAddrGroupPrefix[];
    ranges: outputs.GetGslbClientIpAddrGroupRange[];
    type: string;
}

export interface GetGslbClientIpAddrGroupAddr {
    addr: string;
    type: string;
}

export interface GetGslbClientIpAddrGroupPrefix {
    ipAddrs: outputs.GetGslbClientIpAddrGroupPrefixIpAddr[];
    mask: string;
}

export interface GetGslbClientIpAddrGroupPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetGslbClientIpAddrGroupRange {
    begins: outputs.GetGslbClientIpAddrGroupRangeBegin[];
    ends: outputs.GetGslbClientIpAddrGroupRangeEnd[];
}

export interface GetGslbClientIpAddrGroupRangeBegin {
    addr: string;
    type: string;
}

export interface GetGslbClientIpAddrGroupRangeEnd {
    addr: string;
    type: string;
}

export interface GetGslbConfigpbAttribute {
    version: string;
}

export interface GetGslbDnsConfig {
    domainName: string;
}

export interface GetGslbReplicationPolicy {
    checkpointRef: string;
    replicationMode: string;
}

export interface GetGslbSite {
    address: string;
    clusterUuid: string;
    dnsVses: outputs.GetGslbSiteDnsVse[];
    enabled: string;
    hmProxies: outputs.GetGslbSiteHmProxy[];
    hmShardEnabled: string;
    ipAddresses: outputs.GetGslbSiteIpAddress[];
    locations: outputs.GetGslbSiteLocation[];
    memberType: string;
    name: string;
    password: string;
    port: string;
    ratio: string;
    suspendMode: string;
    username: string;
    uuid: string;
}

export interface GetGslbSiteDnsVse {
    dnsVsUuid: string;
    domainNames: string[];
}

export interface GetGslbSiteHmProxy {
    proxyType: string;
    siteUuid: string;
}

export interface GetGslbSiteIpAddress {
    addr: string;
    type: string;
}

export interface GetGslbSiteLocation {
    locations: outputs.GetGslbSiteLocationLocation[];
    source: string;
}

export interface GetGslbSiteLocationLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GetGslbThirdPartySite {
    clusterUuid: string;
    enabled: string;
    hmProxies: outputs.GetGslbThirdPartySiteHmProxy[];
    locations: outputs.GetGslbThirdPartySiteLocation[];
    name: string;
    ratio: string;
    uuid: string;
}

export interface GetGslbThirdPartySiteHmProxy {
    proxyType: string;
    siteUuid: string;
}

export interface GetGslbThirdPartySiteLocation {
    locations: outputs.GetGslbThirdPartySiteLocationLocation[];
    source: string;
}

export interface GetGslbThirdPartySiteLocationLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GetGslbgeodbprofileConfigpbAttribute {
    version: string;
}

export interface GetGslbgeodbprofileEntry {
    files: outputs.GetGslbgeodbprofileEntryFile[];
    priority: string;
}

export interface GetGslbgeodbprofileEntryFile {
    checksum: string;
    fileId: string;
    fileIdChecksum: string;
    filename: string;
    format: string;
    timestamp: string;
}

export interface GetGslbgeodbprofileMarker {
    key: string;
    values: string[];
}

export interface GetGslbserviceConfigpbAttribute {
    version: string;
}

export interface GetGslbserviceDownResponse {
    fallbackCname: string;
    fallbackIp6s: outputs.GetGslbserviceDownResponseFallbackIp6[];
    fallbackIps: outputs.GetGslbserviceDownResponseFallbackIp[];
    type: string;
}

export interface GetGslbserviceDownResponseFallbackIp {
    addr: string;
    type: string;
}

export interface GetGslbserviceDownResponseFallbackIp6 {
    addr: string;
    type: string;
}

export interface GetGslbserviceGroup {
    algorithm: string;
    consistentHashMask: string;
    consistentHashMask6: string;
    description: string;
    enabled: string;
    fallbackAlgorithm: string;
    manualResume: string;
    members: outputs.GetGslbserviceGroupMember[];
    minHealthMonitorsUp: string;
    name: string;
    priority: string;
}

export interface GetGslbserviceGroupMember {
    cloudUuid: string;
    clusterUuid: string;
    description: string;
    enabled: string;
    fqdn: string;
    hostname: string;
    ips: outputs.GetGslbserviceGroupMemberIp[];
    locations: outputs.GetGslbserviceGroupMemberLocation[];
    preferenceOrder: string;
    publicIps: outputs.GetGslbserviceGroupMemberPublicIp[];
    ratio: string;
    resolveFqdnToV6: string;
    vsUuid: string;
}

export interface GetGslbserviceGroupMemberIp {
    addr: string;
    type: string;
}

export interface GetGslbserviceGroupMemberLocation {
    locations: outputs.GetGslbserviceGroupMemberLocationLocation[];
    source: string;
}

export interface GetGslbserviceGroupMemberLocationLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GetGslbserviceGroupMemberPublicIp {
    ips: outputs.GetGslbserviceGroupMemberPublicIpIp[];
}

export interface GetGslbserviceGroupMemberPublicIpIp {
    addr: string;
    type: string;
}

export interface GetGslbserviceMarker {
    key: string;
    values: string[];
}

export interface GetHardwaresecuritymodulegroupConfigpbAttribute {
    version: string;
}

export interface GetHardwaresecuritymodulegroupHsm {
    cloudhsms: outputs.GetHardwaresecuritymodulegroupHsmCloudhsm[];
    nethsms: outputs.GetHardwaresecuritymodulegroupHsmNethsm[];
    rfs: outputs.GetHardwaresecuritymodulegroupHsmRf[];
    slunas: outputs.GetHardwaresecuritymodulegroupHsmSluna[];
    type: string;
}

export interface GetHardwaresecuritymodulegroupHsmCloudhsm {
    clientConfig: string;
    clusterCert: string;
    cryptoUserName: string;
    cryptoUserPassword: string;
    hsmIps: string[];
    mgmtConfig: string;
}

export interface GetHardwaresecuritymodulegroupHsmNethsm {
    esn: string;
    keyhash: string;
    moduleId: string;
    priority: string;
    remoteIps: outputs.GetHardwaresecuritymodulegroupHsmNethsmRemoteIp[];
    remotePort: string;
}

export interface GetHardwaresecuritymodulegroupHsmNethsmRemoteIp {
    addr: string;
    type: string;
}

export interface GetHardwaresecuritymodulegroupHsmRf {
    ips: outputs.GetHardwaresecuritymodulegroupHsmRfIp[];
    port: string;
}

export interface GetHardwaresecuritymodulegroupHsmRfIp {
    addr: string;
    type: string;
}

export interface GetHardwaresecuritymodulegroupHsmSluna {
    haGroupNum: string;
    isHa: string;
    nodeInfos: outputs.GetHardwaresecuritymodulegroupHsmSlunaNodeInfo[];
    serverPem: string;
    servers: outputs.GetHardwaresecuritymodulegroupHsmSlunaServer[];
    useDedicatedNetwork: string;
}

export interface GetHardwaresecuritymodulegroupHsmSlunaNodeInfo {
    chrystokiConf: string;
    clientCert: string;
    clientIp: string;
    clientPrivKey: string;
    sessionMajorNumber: string;
    sessionMinorNumber: string;
}

export interface GetHardwaresecuritymodulegroupHsmSlunaServer {
    index: string;
    partitionPasswd: string;
    partitionSerialNumber: string;
    remoteIp: string;
    serverCert: string;
}

export interface GetHardwaresecuritymodulegroupMarker {
    key: string;
    values: string[];
}

export interface GetHealthmonitorAuthentication {
    password: string;
    username: string;
}

export interface GetHealthmonitorConfigpbAttribute {
    version: string;
}

export interface GetHealthmonitorDnsMonitor {
    qtype: string;
    queryName: string;
    rcode: string;
    recordType: string;
    responseString: string;
}

export interface GetHealthmonitorExternalMonitor {
    commandCode: string;
    commandParameters: string;
    commandPath: string;
    commandVariables: string;
}

export interface GetHealthmonitorFtpMonitor {
    filename: string;
    mode: string;
    sslAttributes: outputs.GetHealthmonitorFtpMonitorSslAttribute[];
}

export interface GetHealthmonitorFtpMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorFtpsMonitor {
    filename: string;
    mode: string;
    sslAttributes: outputs.GetHealthmonitorFtpsMonitorSslAttribute[];
}

export interface GetHealthmonitorFtpsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorHttpMonitor {
    authType: string;
    exactHttpRequest: string;
    httpRequest: string;
    httpRequestBody: string;
    httpResponse: string;
    httpResponseCodes: string[];
    maintenanceCodes: number[];
    maintenanceResponse: string;
    responseSize: string;
    sslAttributes: outputs.GetHealthmonitorHttpMonitorSslAttribute[];
}

export interface GetHealthmonitorHttpMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorHttpsMonitor {
    authType: string;
    exactHttpRequest: string;
    httpRequest: string;
    httpRequestBody: string;
    httpResponse: string;
    httpResponseCodes: string[];
    maintenanceCodes: number[];
    maintenanceResponse: string;
    responseSize: string;
    sslAttributes: outputs.GetHealthmonitorHttpsMonitorSslAttribute[];
}

export interface GetHealthmonitorHttpsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorImapMonitor {
    folder: string;
    sslAttributes: outputs.GetHealthmonitorImapMonitorSslAttribute[];
}

export interface GetHealthmonitorImapMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorImapsMonitor {
    folder: string;
    sslAttributes: outputs.GetHealthmonitorImapsMonitorSslAttribute[];
}

export interface GetHealthmonitorImapsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorLdapMonitor {
    attributes: string;
    baseDn: string;
    filter: string;
    scope: string;
    sslAttributes: outputs.GetHealthmonitorLdapMonitorSslAttribute[];
}

export interface GetHealthmonitorLdapMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorLdapsMonitor {
    attributes: string;
    baseDn: string;
    filter: string;
    scope: string;
    sslAttributes: outputs.GetHealthmonitorLdapsMonitorSslAttribute[];
}

export interface GetHealthmonitorLdapsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorMarker {
    key: string;
    values: string[];
}

export interface GetHealthmonitorPop3Monitor {
    sslAttributes: outputs.GetHealthmonitorPop3MonitorSslAttribute[];
}

export interface GetHealthmonitorPop3MonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorPop3sMonitor {
    sslAttributes: outputs.GetHealthmonitorPop3sMonitorSslAttribute[];
}

export interface GetHealthmonitorPop3sMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorRadiusMonitor {
    password: string;
    sharedSecret: string;
    username: string;
}

export interface GetHealthmonitorSctpMonitor {
    sctpRequest: string;
    sctpResponse: string;
}

export interface GetHealthmonitorSipMonitor {
    sipMonitorTransport: string;
    sipRequestCode: string;
    sipResponse: string;
}

export interface GetHealthmonitorSmtpMonitor {
    domainname: string;
    mailData: string;
    recipientsIds: string[];
    senderId: string;
    sslAttributes: outputs.GetHealthmonitorSmtpMonitorSslAttribute[];
}

export interface GetHealthmonitorSmtpMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorSmtpsMonitor {
    domainname: string;
    mailData: string;
    recipientsIds: string[];
    senderId: string;
    sslAttributes: outputs.GetHealthmonitorSmtpsMonitorSslAttribute[];
}

export interface GetHealthmonitorSmtpsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface GetHealthmonitorTcpMonitor {
    maintenanceResponse: string;
    tcpHalfOpen: string;
    tcpRequest: string;
    tcpResponse: string;
}

export interface GetHealthmonitorUdpMonitor {
    maintenanceResponse: string;
    udpRequest: string;
    udpResponse: string;
}

export interface GetHttppolicysetConfigpbAttribute {
    version: string;
}

export interface GetHttppolicysetHttpRequestPolicy {
    rules: outputs.GetHttppolicysetHttpRequestPolicyRule[];
}

export interface GetHttppolicysetHttpRequestPolicyRule {
    allHeaders: string;
    enable: string;
    hdrActions: outputs.GetHttppolicysetHttpRequestPolicyRuleHdrAction[];
    index: string;
    log: string;
    matches: outputs.GetHttppolicysetHttpRequestPolicyRuleMatch[];
    name: string;
    redirectActions: outputs.GetHttppolicysetHttpRequestPolicyRuleRedirectAction[];
    rewriteUrlActions: outputs.GetHttppolicysetHttpRequestPolicyRuleRewriteUrlAction[];
    switchingActions: outputs.GetHttppolicysetHttpRequestPolicyRuleSwitchingAction[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleHdrAction {
    action: string;
    cookies: outputs.GetHttppolicysetHttpRequestPolicyRuleHdrActionCookie[];
    hdrIndex: string;
    hdrs: outputs.GetHttppolicysetHttpRequestPolicyRuleHdrActionHdr[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleHdrActionCookie {
    name: string;
    value: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleHdrActionHdr {
    name: string;
    values: outputs.GetHttppolicysetHttpRequestPolicyRuleHdrActionHdrValue[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleHdrActionHdrValue {
    isSensitive: string;
    val: string;
    var: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatch {
    botDetectionResults: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchBotDetectionResult[];
    clientIps: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchClientIp[];
    cookies: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchCookie[];
    geoMatches: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchGeoMatch[];
    hdrs: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchHdr[];
    hostHdrs: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchHostHdr[];
    ipReputationTypes: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchIpReputationType[];
    methods: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchMethod[];
    paths: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchPath[];
    protocols: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchProtocol[];
    queries: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchQuery[];
    sourceIps: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchSourceIp[];
    tlsFingerprintMatches: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchTlsFingerprintMatch[];
    versions: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchVersion[];
    vsPorts: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchVsPort[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchBotDetectionResult {
    classifications: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchClientIp {
    addrs: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchClientIpPrefix[];
    ranges: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchClientIpRange[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchClientIpRange {
    begins: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchClientIpRangeEnd[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchCookie {
    matchCase: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchQuery {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchSourceIp {
    addrs: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefix[];
    ranges: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpRange[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpRange {
    begins: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeEnd[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchTlsFingerprintMatch {
    fingerprints: string[];
    matchOperation: string;
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleRedirectAction {
    addString: string;
    hosts: outputs.GetHttppolicysetHttpRequestPolicyRuleRedirectActionHost[];
    keepQuery: string;
    paths: outputs.GetHttppolicysetHttpRequestPolicyRuleRedirectActionPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRedirectActionHost {
    tokens: outputs.GetHttppolicysetHttpRequestPolicyRuleRedirectActionHostToken[];
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRedirectActionHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRedirectActionPath {
    tokens: outputs.GetHttppolicysetHttpRequestPolicyRuleRedirectActionPathToken[];
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRedirectActionPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRewriteUrlAction {
    hostHdrs: outputs.GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdr[];
    paths: outputs.GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionPath[];
    queries: outputs.GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionQuery[];
}

export interface GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdr {
    tokens: outputs.GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdrToken[];
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdrToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionPath {
    tokens: outputs.GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionPathToken[];
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleRewriteUrlActionQuery {
    addString: string;
    keepQuery: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleSwitchingAction {
    action: string;
    files: outputs.GetHttppolicysetHttpRequestPolicyRuleSwitchingActionFile[];
    otherStatusCode: string;
    poolGroupRef: string;
    poolRef: string;
    servers: outputs.GetHttppolicysetHttpRequestPolicyRuleSwitchingActionServer[];
    statusCode: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleSwitchingActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleSwitchingActionServer {
    hostname: string;
    ips: outputs.GetHttppolicysetHttpRequestPolicyRuleSwitchingActionServerIp[];
    port: string;
}

export interface GetHttppolicysetHttpRequestPolicyRuleSwitchingActionServerIp {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicy {
    rules: outputs.GetHttppolicysetHttpResponsePolicyRule[];
}

export interface GetHttppolicysetHttpResponsePolicyRule {
    allHeaders: string;
    enable: string;
    hdrActions: outputs.GetHttppolicysetHttpResponsePolicyRuleHdrAction[];
    index: string;
    locHdrActions: outputs.GetHttppolicysetHttpResponsePolicyRuleLocHdrAction[];
    log: string;
    matches: outputs.GetHttppolicysetHttpResponsePolicyRuleMatch[];
    name: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleHdrAction {
    action: string;
    cookies: outputs.GetHttppolicysetHttpResponsePolicyRuleHdrActionCookie[];
    hdrIndex: string;
    hdrs: outputs.GetHttppolicysetHttpResponsePolicyRuleHdrActionHdr[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleHdrActionCookie {
    name: string;
    value: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleHdrActionHdr {
    name: string;
    values: outputs.GetHttppolicysetHttpResponsePolicyRuleHdrActionHdrValue[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleHdrActionHdrValue {
    isSensitive: string;
    val: string;
    var: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleLocHdrAction {
    hosts: outputs.GetHttppolicysetHttpResponsePolicyRuleLocHdrActionHost[];
    keepQuery: string;
    paths: outputs.GetHttppolicysetHttpResponsePolicyRuleLocHdrActionPath[];
    port: string;
    protocol: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleLocHdrActionHost {
    tokens: outputs.GetHttppolicysetHttpResponsePolicyRuleLocHdrActionHostToken[];
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleLocHdrActionHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleLocHdrActionPath {
    tokens: outputs.GetHttppolicysetHttpResponsePolicyRuleLocHdrActionPathToken[];
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleLocHdrActionPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatch {
    clientIps: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchClientIp[];
    cookies: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchCookie[];
    hdrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchHdr[];
    hostHdrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchHostHdr[];
    locHdrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchLocHdr[];
    methods: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchMethod[];
    paths: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchPath[];
    protocols: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchProtocol[];
    queries: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchQuery[];
    rspHdrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchRspHdr[];
    sourceIps: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchSourceIp[];
    statuses: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchStatus[];
    versions: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchVersion[];
    vsPorts: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchVsPort[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchClientIp {
    addrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchClientIpPrefix[];
    ranges: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchClientIpRange[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchClientIpRange {
    begins: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchClientIpRangeEnd[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchCookie {
    matchCase: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchLocHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchQuery {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchRspHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchSourceIp {
    addrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefix[];
    ranges: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpRange[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpRange {
    begins: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeEnd[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchStatus {
    matchCriteria: string;
    ranges: outputs.GetHttppolicysetHttpResponsePolicyRuleMatchStatusRange[];
    statusCodes: number[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchStatusRange {
    begin: string;
    end: string;
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface GetHttppolicysetHttpResponsePolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetHttppolicysetHttpSecurityPolicy {
    rules: outputs.GetHttppolicysetHttpSecurityPolicyRule[];
}

export interface GetHttppolicysetHttpSecurityPolicyRule {
    actions: outputs.GetHttppolicysetHttpSecurityPolicyRuleAction[];
    enable: string;
    index: string;
    log: string;
    matches: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatch[];
    name: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleAction {
    action: string;
    files: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionFile[];
    httpsPort: string;
    rateProfiles: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfile[];
    statusCode: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfile {
    actions: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileAction[];
    perClientIp: string;
    perUriPath: string;
    rateLimiters: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileRateLimiter[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileAction {
    files: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionFile[];
    redirects: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirect {
    addString: string;
    hosts: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHost {
    tokens: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHostToken[];
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPath {
    tokens: outputs.GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPathToken[];
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleActionRateProfileRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatch {
    botDetectionResults: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResult[];
    clientIps: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchClientIp[];
    cookies: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchCookie[];
    geoMatches: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchGeoMatch[];
    hdrs: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchHdr[];
    hostHdrs: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchHostHdr[];
    ipReputationTypes: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchIpReputationType[];
    methods: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchMethod[];
    paths: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchPath[];
    protocols: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchProtocol[];
    queries: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchQuery[];
    sourceIps: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIp[];
    tlsFingerprintMatches: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchTlsFingerprintMatch[];
    versions: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchVersion[];
    vsPorts: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchVsPort[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResult {
    classifications: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchClientIp {
    addrs: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefix[];
    ranges: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpRange[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpRange {
    begins: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeEnd[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchCookie {
    matchCase: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchQuery {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIp {
    addrs: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefix[];
    ranges: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpRange[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpRange {
    begins: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeEnd[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchTlsFingerprintMatch {
    fingerprints: string[];
    matchOperation: string;
    stringGroupRefs: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface GetHttppolicysetHttpSecurityPolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetHttppolicysetMarker {
    key: string;
    values: string[];
}

export interface GetIcapprofileConfigpbAttribute {
    version: string;
}

export interface GetIcapprofileNsxDefenderConfig {
    statusUrl: string;
}

export interface GetImageCloudInfoValue {
    cloudDataValues: outputs.GetImageCloudInfoValueCloudDataValue[];
    cloudName: string;
}

export interface GetImageCloudInfoValueCloudDataValue {
    key: string;
    values: string[];
}

export interface GetImageControllerInfo {
    builds: outputs.GetImageControllerInfoBuild[];
    hash: string;
    patches: outputs.GetImageControllerInfoPatch[];
    path: string;
}

export interface GetImageControllerInfoBuild {
    buildNo: string;
    date: string;
    minVersion: string;
    patchVersion: string;
    product: string;
    productName: string;
    remoteImageRef: string;
    tag: string;
    version: string;
}

export interface GetImageControllerInfoPatch {
    patchType: string;
    reboot: string;
    rebootLists: outputs.GetImageControllerInfoPatchRebootList[];
}

export interface GetImageControllerInfoPatchRebootList {
    patchVersion: string;
    reboot: string;
}

export interface GetImageEvent {
    nodesEvents: outputs.GetImageEventNodesEvent[];
    subEvents: outputs.GetImageEventSubEvent[];
    taskName: string;
}

export interface GetImageEventNodesEvent {
    duration: string;
    endTime: string;
    ips: outputs.GetImageEventNodesEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks: string[];
}

export interface GetImageEventNodesEventIp {
    addr: string;
    type: string;
}

export interface GetImageEventSubEvent {
    duration: string;
    endTime: string;
    ips: outputs.GetImageEventSubEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks: string[];
}

export interface GetImageEventSubEventIp {
    addr: string;
    type: string;
}

export interface GetImageImgState {
    lastChangedTimes: outputs.GetImageImgStateLastChangedTime[];
    reason: string;
    state: string;
}

export interface GetImageImgStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetImageMigration {
    apiVersion: string;
    controllerHostMinFreeDiskSize: string;
    controllerMinCores: string;
    controllerMinDockerVersion: string;
    controllerMinFreeDiskSize: string;
    controllerMinMemory: string;
    controllerMinTotalDisk: string;
    maxActiveVersions: string;
    minSupportedApiVersion: string;
    podmanControllerHostMinFreeDiskSize: string;
    podmanSeHostMinFreeDiskSize: string;
    rollbackControllerDiskSpace: string;
    rollbackSeDiskSpace: string;
    seHostMinFreeDiskSize: string;
    seMinCores: string;
    seMinFreeDiskSize: string;
    seMinMemory: string;
    seMinTotalDisk: string;
    versions: string[];
}

export interface GetImageSeInfo {
    builds: outputs.GetImageSeInfoBuild[];
    hash: string;
    patches: outputs.GetImageSeInfoPatch[];
    path: string;
}

export interface GetImageSeInfoBuild {
    buildNo: string;
    date: string;
    minVersion: string;
    patchVersion: string;
    product: string;
    productName: string;
    remoteImageRef: string;
    tag: string;
    version: string;
}

export interface GetImageSeInfoPatch {
    patchType: string;
    reboot: string;
    rebootLists: outputs.GetImageSeInfoPatchRebootList[];
}

export interface GetImageSeInfoPatchRebootList {
    patchVersion: string;
    reboot: string;
}

export interface GetInventoryfaultconfigConfigpbAttribute {
    version: string;
}

export interface GetInventoryfaultconfigControllerFault {
    backupSchedulerFaults: string;
    clusterFaults: string;
    deprecatedApiVersionFaults: string;
    licenseFaults: string;
    migrationFaults: string;
    sslprofileFaults: string;
}

export interface GetInventoryfaultconfigServiceengineFault {
    debugFaults: string;
}

export interface GetInventoryfaultconfigVirtualserviceFault {
    debugFaults: string;
    poolServerFaults: string;
    scaleoutFaults: string;
    sharedVipFaults: string;
    sslCertExpiryFaults: string;
    sslCertStatusFaults: string;
}

export interface GetIpaddrgroupAddr {
    addr: string;
    type: string;
}

export interface GetIpaddrgroupConfigpbAttribute {
    version: string;
}

export interface GetIpaddrgroupIpPort {
    hostname: string;
    ips: outputs.GetIpaddrgroupIpPortIp[];
    name: string;
    port: string;
}

export interface GetIpaddrgroupIpPortIp {
    addr: string;
    type: string;
}

export interface GetIpaddrgroupMarker {
    key: string;
    values: string[];
}

export interface GetIpaddrgroupPrefix {
    ipAddrs: outputs.GetIpaddrgroupPrefixIpAddr[];
    mask: string;
}

export interface GetIpaddrgroupPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetIpaddrgroupRange {
    begins: outputs.GetIpaddrgroupRangeBegin[];
    ends: outputs.GetIpaddrgroupRangeEnd[];
}

export interface GetIpaddrgroupRangeBegin {
    addr: string;
    type: string;
}

export interface GetIpaddrgroupRangeEnd {
    addr: string;
    type: string;
}

export interface GetIpamdnsproviderprofileAwsProfile {
    accessKeyId: string;
    egressServiceSubnets: string[];
    iamAssumeRole: string;
    publishVipToPublicZone: string;
    region: string;
    secretAccessKey: string;
    ttl: string;
    usableDomains: string[];
    usableNetworkUuids: string[];
    useIamRoles: string;
    vpc: string;
    vpcId: string;
    zones: outputs.GetIpamdnsproviderprofileAwsProfileZone[];
}

export interface GetIpamdnsproviderprofileAwsProfileZone {
    availabilityZone: string;
    usableNetworkUuids: string[];
}

export interface GetIpamdnsproviderprofileAzureProfile {
    azureServiceprincipals: outputs.GetIpamdnsproviderprofileAzureProfileAzureServiceprincipal[];
    azureUserpasses: outputs.GetIpamdnsproviderprofileAzureProfileAzureUserpass[];
    egressServiceSubnets: string[];
    resourceGroup: string;
    subscriptionId: string;
    usableDomains: string[];
    usableNetworkUuids: string[];
    useEnhancedHa: string;
    useStandardAlb: string;
    virtualNetworkIds: string[];
}

export interface GetIpamdnsproviderprofileAzureProfileAzureServiceprincipal {
    applicationId: string;
    authenticationToken: string;
    tenantId: string;
}

export interface GetIpamdnsproviderprofileAzureProfileAzureUserpass {
    password: string;
    tenantName: string;
    username: string;
}

export interface GetIpamdnsproviderprofileConfigpbAttribute {
    version: string;
}

export interface GetIpamdnsproviderprofileCustomProfile {
    customIpamDnsProfileRef: string;
    dynamicParams: outputs.GetIpamdnsproviderprofileCustomProfileDynamicParam[];
    usableAllocSubnets: outputs.GetIpamdnsproviderprofileCustomProfileUsableAllocSubnet[];
    usableDomains: string[];
}

export interface GetIpamdnsproviderprofileCustomProfileDynamicParam {
    isDynamic: string;
    isSensitive: string;
    name: string;
    value: string;
}

export interface GetIpamdnsproviderprofileCustomProfileUsableAllocSubnet {
    networkId: string;
    subnet6s: outputs.GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6[];
    subnets: outputs.GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet[];
}

export interface GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet {
    ipAddrs: outputs.GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnetIpAddr[];
    mask: string;
}

export interface GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6 {
    ipAddrs: outputs.GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6IpAddr[];
    mask: string;
}

export interface GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetIpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetIpamdnsproviderprofileGcpProfile {
    matchSeGroupSubnet: string;
    networkHostProjectId: string;
    regionName: string;
    seProjectId: string;
    usableNetworkRefs: string[];
    useGcpNetwork: string;
    vpcNetworkName: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfile {
    dnsView: string;
    extensibleAttributes: outputs.GetIpamdnsproviderprofileInfobloxProfileExtensibleAttribute[];
    ip6Addresses: outputs.GetIpamdnsproviderprofileInfobloxProfileIp6Address[];
    ipAddresses: outputs.GetIpamdnsproviderprofileInfobloxProfileIpAddress[];
    networkView: string;
    password: string;
    profileUrl: string;
    usableAllocSubnets: outputs.GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnet[];
    usableDomains: string[];
    username: string;
    wapiVersion: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfileExtensibleAttribute {
    isDynamic: string;
    isSensitive: string;
    name: string;
    value: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfileIp6Address {
    addr: string;
    type: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfileIpAddress {
    addr: string;
    type: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnet {
    subnet6s: outputs.GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6[];
    subnets: outputs.GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet[];
}

export interface GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet {
    ipAddrs: outputs.GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnetIpAddr[];
    mask: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6 {
    ipAddrs: outputs.GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6IpAddr[];
    mask: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetIpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetIpamdnsproviderprofileInternalProfile {
    dnsServiceDomains: outputs.GetIpamdnsproviderprofileInternalProfileDnsServiceDomain[];
    dnsVirtualserviceRef: string;
    ttl: string;
    usableNetworks: outputs.GetIpamdnsproviderprofileInternalProfileUsableNetwork[];
}

export interface GetIpamdnsproviderprofileInternalProfileDnsServiceDomain {
    domainName: string;
    passThrough: string;
    recordTtl: string;
}

export interface GetIpamdnsproviderprofileInternalProfileUsableNetwork {
    labels: outputs.GetIpamdnsproviderprofileInternalProfileUsableNetworkLabel[];
    nwRef: string;
}

export interface GetIpamdnsproviderprofileInternalProfileUsableNetworkLabel {
    key: string;
    value: string;
}

export interface GetIpamdnsproviderprofileMarker {
    key: string;
    values: string[];
}

export interface GetIpamdnsproviderprofileOciProfile {
    cloudCredentialsRef: string;
    region: string;
    tenancy: string;
    vcnCompartmentId: string;
    vcnId: string;
}

export interface GetIpamdnsproviderprofileOpenstackProfile {
    keystoneHost: string;
    password: string;
    region: string;
    tenant: string;
    username: string;
    vipNetworkName: string;
}

export interface GetIpamdnsproviderprofileProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface GetIpamdnsproviderprofileTencentProfile {
    cloudCredentialsRef: string;
    region: string;
    usableSubnetIds: string[];
    vpcId: string;
    zones: outputs.GetIpamdnsproviderprofileTencentProfileZone[];
}

export interface GetIpamdnsproviderprofileTencentProfileZone {
    availabilityZone: string;
    usableSubnetId: string;
}

export interface GetIpreputationdbConfigpbAttribute {
    version: string;
}

export interface GetIpreputationdbMarker {
    key: string;
    values: string[];
}

export interface GetIpreputationdbServiceStatus {
    error: string;
    lastSuccessfulUpdateChecks: outputs.GetIpreputationdbServiceStatusLastSuccessfulUpdateCheck[];
}

export interface GetIpreputationdbServiceStatusLastSuccessfulUpdateCheck {
    secs: string;
    usecs: string;
}

export interface GetJwtserverprofileConfigpbAttribute {
    version: string;
}

export interface GetJwtserverprofileControllerInternalAuth {
    symmetricJwksKeys: outputs.GetJwtserverprofileControllerInternalAuthSymmetricJwksKey[];
}

export interface GetJwtserverprofileControllerInternalAuthSymmetricJwksKey {
    alg: string;
    key: string;
    kid: string;
    kty: string;
}

export interface GetL4policysetConfigpbAttribute {
    version: string;
}

export interface GetL4policysetL4ConnectionPolicy {
    rules: outputs.GetL4policysetL4ConnectionPolicyRule[];
}

export interface GetL4policysetL4ConnectionPolicyRule {
    actions: outputs.GetL4policysetL4ConnectionPolicyRuleAction[];
    enable: string;
    index: string;
    matches: outputs.GetL4policysetL4ConnectionPolicyRuleMatch[];
    name: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleAction {
    selectPools: outputs.GetL4policysetL4ConnectionPolicyRuleActionSelectPool[];
}

export interface GetL4policysetL4ConnectionPolicyRuleActionSelectPool {
    actionType: string;
    poolGroupRef: string;
    poolRef: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleMatch {
    clientIps: outputs.GetL4policysetL4ConnectionPolicyRuleMatchClientIp[];
    ports: outputs.GetL4policysetL4ConnectionPolicyRuleMatchPort[];
    protocols: outputs.GetL4policysetL4ConnectionPolicyRuleMatchProtocol[];
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchClientIp {
    addrs: outputs.GetL4policysetL4ConnectionPolicyRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetL4policysetL4ConnectionPolicyRuleMatchClientIpPrefix[];
    ranges: outputs.GetL4policysetL4ConnectionPolicyRuleMatchClientIpRange[];
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetL4policysetL4ConnectionPolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchClientIpRange {
    begins: outputs.GetL4policysetL4ConnectionPolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.GetL4policysetL4ConnectionPolicyRuleMatchClientIpRangeEnd[];
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchPort {
    matchCriteria: string;
    portRanges: outputs.GetL4policysetL4ConnectionPolicyRuleMatchPortPortRange[];
    ports: number[];
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchPortPortRange {
    end: string;
    start: string;
}

export interface GetL4policysetL4ConnectionPolicyRuleMatchProtocol {
    matchCriteria: string;
    protocol: string;
}

export interface GetL4policysetMarker {
    key: string;
    values: string[];
}

export interface GetLabelgroupConfigpbAttribute {
    version: string;
}

export interface GetLabelgroupLabel {
    matchLabels: outputs.GetLabelgroupLabelMatchLabel[];
    matchOperation: string;
}

export interface GetLabelgroupLabelMatchLabel {
    key: string;
    values: string[];
}

export interface GetLicenseledgerdetailsEscrowInfo {
    lastUpdated: string;
    serviceCores: string;
    tenantUuid: string;
    tier: string;
    uuid: string;
}

export interface GetLicenseledgerdetailsSeInfo {
    lastUpdated: string;
    serviceCores: string;
    tenantUuid: string;
    tier: string;
    uuid: string;
}

export interface GetLicenseledgerdetailsTierUsage {
    tier: string;
    usages: outputs.GetLicenseledgerdetailsTierUsageUsage[];
}

export interface GetLicenseledgerdetailsTierUsageUsage {
    available: string;
    consumed: string;
    escrow: string;
    remaining: string;
}

export interface GetLicensestatusConfigpbAttribute {
    version: string;
}

export interface GetLicensestatusSaasStatus {
    connected: string;
    enabled: string;
    expired: string;
    message: string;
    name: string;
    publicKey: string;
    reserveServiceUnits: string;
}

export interface GetLicensestatusServiceUpdate {
    name: string;
    serviceUnits: outputs.GetLicensestatusServiceUpdateServiceUnit[];
}

export interface GetLicensestatusServiceUpdateServiceUnit {
    availableServiceUnits: string;
    orgId: string;
    usedServiceUnits: string;
}

export interface GetMemorybalancerrequestConfigpbAttribute {
    version: string;
}

export interface GetMemorybalancerrequestControllerInfo {
    currentControllerMemUsage: string;
}

export interface GetMemorybalancerrequestProcessInfo {
    currentProcessId: string;
    currentProcessMemUsage: string;
    intimationCount: string;
    memoryLimit: string;
    memoryTrendUsage: string;
    processMode: string;
    thresholdPercent: string;
}

export interface GetMicroservicegroupConfigpbAttribute {
    version: string;
}

export interface GetNatpolicyConfigpbAttribute {
    version: string;
}

export interface GetNatpolicyMarker {
    key: string;
    values: string[];
}

export interface GetNatpolicyRule {
    actions: outputs.GetNatpolicyRuleAction[];
    createdBy: string;
    enable: string;
    index: string;
    matches: outputs.GetNatpolicyRuleMatch[];
    name: string;
}

export interface GetNatpolicyRuleAction {
    natInfos: outputs.GetNatpolicyRuleActionNatInfo[];
    type: string;
}

export interface GetNatpolicyRuleActionNatInfo {
    natIpRanges: outputs.GetNatpolicyRuleActionNatInfoNatIpRange[];
    natIps: outputs.GetNatpolicyRuleActionNatInfoNatIp[];
}

export interface GetNatpolicyRuleActionNatInfoNatIp {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleActionNatInfoNatIpRange {
    begins: outputs.GetNatpolicyRuleActionNatInfoNatIpRangeBegin[];
    ends: outputs.GetNatpolicyRuleActionNatInfoNatIpRangeEnd[];
}

export interface GetNatpolicyRuleActionNatInfoNatIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleActionNatInfoNatIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatch {
    destinationIps: outputs.GetNatpolicyRuleMatchDestinationIp[];
    services: outputs.GetNatpolicyRuleMatchService[];
    sourceIps: outputs.GetNatpolicyRuleMatchSourceIp[];
}

export interface GetNatpolicyRuleMatchDestinationIp {
    addrs: outputs.GetNatpolicyRuleMatchDestinationIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetNatpolicyRuleMatchDestinationIpPrefix[];
    ranges: outputs.GetNatpolicyRuleMatchDestinationIpRange[];
}

export interface GetNatpolicyRuleMatchDestinationIpAddr {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatchDestinationIpPrefix {
    ipAddrs: outputs.GetNatpolicyRuleMatchDestinationIpPrefixIpAddr[];
    mask: string;
}

export interface GetNatpolicyRuleMatchDestinationIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatchDestinationIpRange {
    begins: outputs.GetNatpolicyRuleMatchDestinationIpRangeBegin[];
    ends: outputs.GetNatpolicyRuleMatchDestinationIpRangeEnd[];
}

export interface GetNatpolicyRuleMatchDestinationIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatchDestinationIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatchService {
    destinationPorts: outputs.GetNatpolicyRuleMatchServiceDestinationPort[];
    protocols: outputs.GetNatpolicyRuleMatchServiceProtocol[];
    sourcePorts: outputs.GetNatpolicyRuleMatchServiceSourcePort[];
}

export interface GetNatpolicyRuleMatchServiceDestinationPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetNatpolicyRuleMatchServiceProtocol {
    matchCriteria: string;
    protocol: string;
}

export interface GetNatpolicyRuleMatchServiceSourcePort {
    matchCriteria: string;
    ports: number[];
}

export interface GetNatpolicyRuleMatchSourceIp {
    addrs: outputs.GetNatpolicyRuleMatchSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetNatpolicyRuleMatchSourceIpPrefix[];
    ranges: outputs.GetNatpolicyRuleMatchSourceIpRange[];
}

export interface GetNatpolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.GetNatpolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetNatpolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatchSourceIpRange {
    begins: outputs.GetNatpolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.GetNatpolicyRuleMatchSourceIpRangeEnd[];
}

export interface GetNatpolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetNatpolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetNetworkAttr {
    key: string;
    value: string;
}

export interface GetNetworkConfigpbAttribute {
    version: string;
}

export interface GetNetworkConfiguredSubnet {
    prefixes: outputs.GetNetworkConfiguredSubnetPrefix[];
    staticIpRanges: outputs.GetNetworkConfiguredSubnetStaticIpRange[];
}

export interface GetNetworkConfiguredSubnetPrefix {
    ipAddrs: outputs.GetNetworkConfiguredSubnetPrefixIpAddr[];
    mask: string;
}

export interface GetNetworkConfiguredSubnetPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetNetworkConfiguredSubnetStaticIpRange {
    ranges: outputs.GetNetworkConfiguredSubnetStaticIpRangeRange[];
    type: string;
}

export interface GetNetworkConfiguredSubnetStaticIpRangeRange {
    begins: outputs.GetNetworkConfiguredSubnetStaticIpRangeRangeBegin[];
    ends: outputs.GetNetworkConfiguredSubnetStaticIpRangeRangeEnd[];
}

export interface GetNetworkConfiguredSubnetStaticIpRangeRangeBegin {
    addr: string;
    type: string;
}

export interface GetNetworkConfiguredSubnetStaticIpRangeRangeEnd {
    addr: string;
    type: string;
}

export interface GetNetworkMarker {
    key: string;
    values: string[];
}

export interface GetNetworkprofileConfigpbAttribute {
    version: string;
}

export interface GetNetworkprofileMarker {
    key: string;
    values: string[];
}

export interface GetNetworkprofileProfile {
    sctpFastPathProfiles: outputs.GetNetworkprofileProfileSctpFastPathProfile[];
    sctpProxyProfiles: outputs.GetNetworkprofileProfileSctpProxyProfile[];
    tcpFastPathProfiles: outputs.GetNetworkprofileProfileTcpFastPathProfile[];
    tcpProxyProfiles: outputs.GetNetworkprofileProfileTcpProxyProfile[];
    type: string;
    udpFastPathProfiles: outputs.GetNetworkprofileProfileUdpFastPathProfile[];
    udpProxyProfiles: outputs.GetNetworkprofileProfileUdpProxyProfile[];
}

export interface GetNetworkprofileProfileSctpFastPathProfile {
    enableInitChunkProtection: string;
    idleTimeout: string;
}

export interface GetNetworkprofileProfileSctpProxyProfile {
    cookieExpirationTimeout: string;
    heartbeatInterval: string;
    idleTimeout: string;
    maxRetransmissionsAssociation: string;
    maxRetransmissionsInitChunks: string;
    numberOfStreams: string;
    receiveWindow: string;
    resetTimeout: string;
}

export interface GetNetworkprofileProfileTcpFastPathProfile {
    dsrProfiles: outputs.GetNetworkprofileProfileTcpFastPathProfileDsrProfile[];
    enableSynProtection: string;
    sessionIdleTimeout: string;
}

export interface GetNetworkprofileProfileTcpFastPathProfileDsrProfile {
    dsrEncapType: string;
    dsrType: string;
}

export interface GetNetworkprofileProfileTcpProxyProfile {
    aggressiveCongestionAvoidance: string;
    autoWindowGrowth: string;
    automatic: string;
    ccAlgo: string;
    congestionRecoveryScalingFactor: string;
    idleConnectionTimeout: string;
    idleConnectionType: string;
    ignoreTimeWait: string;
    ipDscp: string;
    keepaliveInHalfcloseState: string;
    maxRetransmissions: string;
    maxSegmentSize: string;
    maxSynRetransmissions: string;
    minRexmtTimeout: string;
    naglesAlgorithm: string;
    reassemblyQueueSize: string;
    receiveWindow: string;
    reorderThreshold: string;
    slowStartScalingFactor: string;
    timeWaitDelay: string;
    useInterfaceMtu: string;
}

export interface GetNetworkprofileProfileUdpFastPathProfile {
    dsrProfiles: outputs.GetNetworkprofileProfileUdpFastPathProfileDsrProfile[];
    perPktLoadbalance: string;
    sessionIdleTimeout: string;
    snat: string;
}

export interface GetNetworkprofileProfileUdpFastPathProfileDsrProfile {
    dsrEncapType: string;
    dsrType: string;
}

export interface GetNetworkprofileProfileUdpProxyProfile {
    sessionIdleTimeout: string;
}

export interface GetNetworksecuritypolicyConfigpbAttribute {
    version: string;
}

export interface GetNetworksecuritypolicyMarker {
    key: string;
    values: string[];
}

export interface GetNetworksecuritypolicyRule {
    action: string;
    age: string;
    createdBy: string;
    enable: string;
    index: string;
    log: string;
    matches: outputs.GetNetworksecuritypolicyRuleMatch[];
    name: string;
    rlParams: outputs.GetNetworksecuritypolicyRuleRlParam[];
}

export interface GetNetworksecuritypolicyRuleMatch {
    clientIps: outputs.GetNetworksecuritypolicyRuleMatchClientIp[];
    clientPorts: outputs.GetNetworksecuritypolicyRuleMatchClientPort[];
    geoMatches: outputs.GetNetworksecuritypolicyRuleMatchGeoMatch[];
    ipReputationTypes: outputs.GetNetworksecuritypolicyRuleMatchIpReputationType[];
    microservices: outputs.GetNetworksecuritypolicyRuleMatchMicroservice[];
    vsPorts: outputs.GetNetworksecuritypolicyRuleMatchVsPort[];
}

export interface GetNetworksecuritypolicyRuleMatchClientIp {
    addrs: outputs.GetNetworksecuritypolicyRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetNetworksecuritypolicyRuleMatchClientIpPrefix[];
    ranges: outputs.GetNetworksecuritypolicyRuleMatchClientIpRange[];
}

export interface GetNetworksecuritypolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetNetworksecuritypolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetNetworksecuritypolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetNetworksecuritypolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetNetworksecuritypolicyRuleMatchClientIpRange {
    begins: outputs.GetNetworksecuritypolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.GetNetworksecuritypolicyRuleMatchClientIpRangeEnd[];
}

export interface GetNetworksecuritypolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetNetworksecuritypolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetNetworksecuritypolicyRuleMatchClientPort {
    matchCriteria: string;
    ports: number[];
    ranges: outputs.GetNetworksecuritypolicyRuleMatchClientPortRange[];
}

export interface GetNetworksecuritypolicyRuleMatchClientPortRange {
    end: string;
    start: string;
}

export interface GetNetworksecuritypolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface GetNetworksecuritypolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface GetNetworksecuritypolicyRuleMatchMicroservice {
    groupRef: string;
    matchCriteria: string;
}

export interface GetNetworksecuritypolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetNetworksecuritypolicyRuleRlParam {
    burstSize: string;
    maxRate: string;
}

export interface GetNetworkserviceConfigpbAttribute {
    version: string;
}

export interface GetNetworkserviceMarker {
    key: string;
    values: string[];
}

export interface GetNetworkserviceRoutingService {
    advertiseBackendNetworks: string;
    enableAutoGateway: string;
    enableRouting: string;
    enableVipOnAllInterfaces: string;
    enableVmac: string;
    floatingIntfIp6Addresses: outputs.GetNetworkserviceRoutingServiceFloatingIntfIp6Address[];
    floatingIntfIp6Se2Addresses: outputs.GetNetworkserviceRoutingServiceFloatingIntfIp6Se2Address[];
    floatingIntfIpSe2s: outputs.GetNetworkserviceRoutingServiceFloatingIntfIpSe2[];
    floatingIntfIps: outputs.GetNetworkserviceRoutingServiceFloatingIntfIp[];
    flowtableProfiles: outputs.GetNetworkserviceRoutingServiceFlowtableProfile[];
    gracefulRestart: string;
    natPolicyRef: string;
    routingByLinuxIpstack: string;
}

export interface GetNetworkserviceRoutingServiceFloatingIntfIp {
    addr: string;
    type: string;
}

export interface GetNetworkserviceRoutingServiceFloatingIntfIp6Address {
    addr: string;
    type: string;
}

export interface GetNetworkserviceRoutingServiceFloatingIntfIp6Se2Address {
    addr: string;
    type: string;
}

export interface GetNetworkserviceRoutingServiceFloatingIntfIpSe2 {
    addr: string;
    type: string;
}

export interface GetNetworkserviceRoutingServiceFlowtableProfile {
    icmpIdleTimeout: string;
    tcpClosedTimeout: string;
    tcpConnectionSetupTimeout: string;
    tcpHalfClosedTimeout: string;
    tcpIdleTimeout: string;
    tcpResetTimeout: string;
    udpIdleTimeout: string;
}

export interface GetPkiprofileCaCert {
    certificate: string;
    certificateSigningRequest: string;
    chainVerified: string;
    daysUntilExpire: string;
    expiryStatus: string;
    fingerprint: string;
    issuers: outputs.GetPkiprofileCaCertIssuer[];
    keyParams: outputs.GetPkiprofileCaCertKeyParam[];
    notAfter: string;
    notBefore: string;
    publicKey: string;
    selfSigned: string;
    serialNumber: string;
    signature: string;
    signatureAlgorithm: string;
    subjectAltNames: string[];
    subjects: outputs.GetPkiprofileCaCertSubject[];
    text: string;
    version: string;
}

export interface GetPkiprofileCaCertIssuer {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface GetPkiprofileCaCertKeyParam {
    algorithm: string;
    ecParams: outputs.GetPkiprofileCaCertKeyParamEcParam[];
    rsaParams: outputs.GetPkiprofileCaCertKeyParamRsaParam[];
}

export interface GetPkiprofileCaCertKeyParamEcParam {
    curve: string;
}

export interface GetPkiprofileCaCertKeyParamRsaParam {
    exponent: string;
    keySize: string;
}

export interface GetPkiprofileCaCertSubject {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface GetPkiprofileConfigpbAttribute {
    version: string;
}

export interface GetPkiprofileMarker {
    key: string;
    values: string[];
}

export interface GetPoolAnalyticsPolicy {
    enableRealtimeMetrics: string;
}

export interface GetPoolConfigpbAttribute {
    version: string;
}

export interface GetPoolConnPoolProperty {
    upstreamConnpoolConnIdleTmo: string;
    upstreamConnpoolConnLifeTmo: string;
    upstreamConnpoolConnMaxReuse: string;
    upstreamConnpoolServerMaxCache: string;
}

export interface GetPoolFailAction {
    localRsps: outputs.GetPoolFailActionLocalRsp[];
    redirects: outputs.GetPoolFailActionRedirect[];
    type: string;
}

export interface GetPoolFailActionLocalRsp {
    files: outputs.GetPoolFailActionLocalRspFile[];
    statusCode: string;
}

export interface GetPoolFailActionLocalRspFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetPoolFailActionRedirect {
    host: string;
    path: string;
    protocol: string;
    query: string;
    statusCode: string;
}

export interface GetPoolHorizonProfile {
    blastPort: string;
    pcoipPort: string;
}

export interface GetPoolHttp2Property {
    maxHttp2ControlFramesPerConnection: string;
    maxHttp2HeaderFieldSize: string;
}

export interface GetPoolMarker {
    key: string;
    values: string[];
}

export interface GetPoolMaxConnRatePerServer {
    actions: outputs.GetPoolMaxConnRatePerServerAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetPoolMaxConnRatePerServerRateLimiter[];
}

export interface GetPoolMaxConnRatePerServerAction {
    files: outputs.GetPoolMaxConnRatePerServerActionFile[];
    redirects: outputs.GetPoolMaxConnRatePerServerActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetPoolMaxConnRatePerServerActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetPoolMaxConnRatePerServerActionRedirect {
    addString: string;
    hosts: outputs.GetPoolMaxConnRatePerServerActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetPoolMaxConnRatePerServerActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetPoolMaxConnRatePerServerActionRedirectHost {
    tokens: outputs.GetPoolMaxConnRatePerServerActionRedirectHostToken[];
    type: string;
}

export interface GetPoolMaxConnRatePerServerActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetPoolMaxConnRatePerServerActionRedirectPath {
    tokens: outputs.GetPoolMaxConnRatePerServerActionRedirectPathToken[];
    type: string;
}

export interface GetPoolMaxConnRatePerServerActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetPoolMaxConnRatePerServerRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetPoolNetwork {
    networkRef: string;
    serverFilter: string;
}

export interface GetPoolPlacementNetwork {
    networkRef: string;
    subnets: outputs.GetPoolPlacementNetworkSubnet[];
}

export interface GetPoolPlacementNetworkSubnet {
    ipAddrs: outputs.GetPoolPlacementNetworkSubnetIpAddr[];
    mask: string;
}

export interface GetPoolPlacementNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetPoolServer {
    autoscalingGroupName: string;
    availabilityZone: string;
    description: string;
    discoveredNetworks: outputs.GetPoolServerDiscoveredNetwork[];
    enabled: string;
    externalOrchestrationId: string;
    externalUuid: string;
    hostname: string;
    ips: outputs.GetPoolServerIp[];
    locations: outputs.GetPoolServerLocation[];
    macAddress: string;
    nwRef: string;
    port: string;
    preferenceOrder: string;
    prstHdrVal: string;
    ratio: string;
    resolveServerByDns: string;
    rewriteHostHeader: string;
    serverNode: string;
    static: string;
    verifyNetwork: string;
    vmRef: string;
}

export interface GetPoolServerDiscoveredNetwork {
    networkRef: string;
    subnet6s: outputs.GetPoolServerDiscoveredNetworkSubnet6[];
    subnets: outputs.GetPoolServerDiscoveredNetworkSubnet[];
}

export interface GetPoolServerDiscoveredNetworkSubnet {
    ipAddrs: outputs.GetPoolServerDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface GetPoolServerDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.GetPoolServerDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface GetPoolServerDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetPoolServerDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetPoolServerIp {
    addr: string;
    type: string;
}

export interface GetPoolServerLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GetPoolServerReselect {
    enabled: string;
    numRetries: string;
    retryNonidempotent: string;
    retryTimeout: string;
    svrRespCodes: outputs.GetPoolServerReselectSvrRespCode[];
}

export interface GetPoolServerReselectSvrRespCode {
    codes: number[];
    ranges: outputs.GetPoolServerReselectSvrRespCodeRange[];
    respCodeBlocks: string[];
}

export interface GetPoolServerReselectSvrRespCodeRange {
    begin: string;
    end: string;
}

export interface GetPoolSpGsInfo {
    fqdns: string[];
    gsRef: string;
}

export interface GetPoolgroupConfigpbAttribute {
    version: string;
}

export interface GetPoolgroupFailAction {
    localRsps: outputs.GetPoolgroupFailActionLocalRsp[];
    redirects: outputs.GetPoolgroupFailActionRedirect[];
    type: string;
}

export interface GetPoolgroupFailActionLocalRsp {
    files: outputs.GetPoolgroupFailActionLocalRspFile[];
    statusCode: string;
}

export interface GetPoolgroupFailActionLocalRspFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetPoolgroupFailActionRedirect {
    host: string;
    path: string;
    protocol: string;
    query: string;
    statusCode: string;
}

export interface GetPoolgroupMarker {
    key: string;
    values: string[];
}

export interface GetPoolgroupMember {
    deploymentState: string;
    poolRef: string;
    priorityLabel: string;
    ratio: string;
}

export interface GetPoolgroupdeploymentpolicyConfigpbAttribute {
    version: string;
}

export interface GetPoolgroupdeploymentpolicyMarker {
    key: string;
    values: string[];
}

export interface GetPoolgroupdeploymentpolicyRule {
    metricId: string;
    operator: string;
    threshold: string;
}

export interface GetPrioritylabelsConfigpbAttribute {
    version: string;
}

export interface GetPrioritylabelsEquivalentLabel {
    labels: string[];
}

export interface GetPrioritylabelsMarker {
    key: string;
    values: string[];
}

export interface GetProtocolparserConfigpbAttribute {
    version: string;
}

export interface GetProtocolparserMarker {
    key: string;
    values: string[];
}

export interface GetRoleConfigpbAttribute {
    version: string;
}

export interface GetRoleFilter {
    enabled: string;
    matchLabels: outputs.GetRoleFilterMatchLabel[];
    matchOperation: string;
    name: string;
}

export interface GetRoleFilterMatchLabel {
    key: string;
    values: string[];
}

export interface GetRolePrivilege {
    resource: string;
    subresources: outputs.GetRolePrivilegeSubresource[];
    type: string;
}

export interface GetRolePrivilegeSubresource {
    excludeSubresources: string;
    subresources: string[];
}

export interface GetSchedulerConfigpbAttribute {
    version: string;
}

export interface GetSecuritymanagerdataAppLearningInfo {
    appId: string;
    uriInfos: outputs.GetSecuritymanagerdataAppLearningInfoUriInfo[];
    vsUuid: string;
}

export interface GetSecuritymanagerdataAppLearningInfoUriInfo {
    paramInfos: outputs.GetSecuritymanagerdataAppLearningInfoUriInfoParamInfo[];
    uriHits: string;
    uriKey: string;
}

export interface GetSecuritymanagerdataAppLearningInfoUriInfoParamInfo {
    paramHits: string;
    paramKey: string;
    paramSizeClasses: outputs.GetSecuritymanagerdataAppLearningInfoUriInfoParamInfoParamSizeClass[];
    paramTypeClasses: outputs.GetSecuritymanagerdataAppLearningInfoUriInfoParamInfoParamTypeClass[];
}

export interface GetSecuritymanagerdataAppLearningInfoUriInfoParamInfoParamSizeClass {
    hits: string;
    len: string;
}

export interface GetSecuritymanagerdataAppLearningInfoUriInfoParamInfoParamTypeClass {
    hits: string;
    type: string;
}

export interface GetSecuritypolicyConfigpbAttribute {
    version: string;
}

export interface GetSecuritypolicyDnsAmplificationDenyport {
    matchCriteria: string;
    ports: number[];
    ranges: outputs.GetSecuritypolicyDnsAmplificationDenyportRange[];
}

export interface GetSecuritypolicyDnsAmplificationDenyportRange {
    end: string;
    start: string;
}

export interface GetSecuritypolicyDnsAttack {
    attacks: outputs.GetSecuritypolicyDnsAttackAttack[];
    operMode: string;
}

export interface GetSecuritypolicyDnsAttackAttack {
    attackVector: string;
    enabled: string;
    maxMitigationAge: string;
    mitigationActions: outputs.GetSecuritypolicyDnsAttackAttackMitigationAction[];
    threshold: string;
}

export interface GetSecuritypolicyDnsAttackAttackMitigationAction {
    deny: string;
}

export interface GetSecuritypolicyMarker {
    key: string;
    values: string[];
}

export interface GetSecuritypolicyTcpAttack {
}

export interface GetSecuritypolicyUdpAttack {
}

export interface GetSepropertiesConfigpbAttribute {
    version: string;
}

export interface GetSepropertiesSeAgentProperty {
    controllerEchoMissAggressiveLimit: string;
    controllerEchoMissLimit: string;
    controllerEchoRpcAggressiveTimeout: string;
    controllerEchoRpcTimeout: string;
    controllerHeartbeatMissLimit: string;
    controllerHeartbeatTimeoutSec: string;
    controllerRegistrationTimeoutSec: string;
    controllerRpcTimeout: string;
    cpustatsInterval: string;
    ctrlRegPendingMaxWaitTime: string;
    debugMode: string;
    dpAggressiveDeqIntervalMsec: string;
    dpAggressiveEnqIntervalMsec: string;
    dpBatchSize: string;
    dpDeqIntervalMsec: string;
    dpEnqIntervalMsec: string;
    dpMaxWaitRspTimeSec: string;
    dpRegPendingMaxWaitTime: string;
    headlessTimeoutSec: string;
    ignoreDockerMacChange: string;
    nsHelperDeqIntervalMsec: string;
    sdbFlushInterval: string;
    sdbPipelineSize: string;
    sdbScanCount: string;
    seGrpChangeDisruptive: string;
    seagentStatecacheProperties: outputs.GetSepropertiesSeAgentPropertySeagentStatecacheProperty[];
    sendSeReadyTimeout: string;
    statesFlushInterval: string;
    vnicDhcpIpCheckInterval: string;
    vnicDhcpIpMaxRetries: string;
    vnicIpDeleteInterval: string;
    vnicProbeInterval: string;
    vnicRpcRetryInterval: string;
    vnicdbCmdHistorySize: string;
}

export interface GetSepropertiesSeAgentPropertySeagentStatecacheProperty {
    scBatchBufferFlushLimit: string;
    scCfgQBatchDequeueLimit: string;
    scCfgQMaxSize: string;
    scDnsQBatchDequeueLimit: string;
    scDnsQMaxSize: string;
    scShardCleanupMaxTime: string;
    scStateRingBatchDequeueLimit: string;
    scStatesFlushInterval: string;
    scStreamCheckInterval: string;
    scThreadQBatchDequeueLimit: string;
    scThreadQMaxSize: string;
    scThreadSleepInterval: string;
}

export interface GetSepropertiesSeBootupProperty {
    dockerBackendPortend: string;
    dockerBackendPortstart: string;
    fairQueueingEnabled: string;
    geoDbGranularity: string;
    l7ConnsPerCore: string;
    l7ResvdListenConnsPerCore: string;
    logAgentDebugEnabled: string;
    logAgentTraceEnabled: string;
    seDpCompressions: outputs.GetSepropertiesSeBootupPropertySeDpCompression[];
    seEmulatedCores: string;
    seIpEncapIpc: string;
    seL3EncapIpc: string;
    seLogBufferAppBlockingDequeue: string;
    seLogBufferApplogSize: string;
    seLogBufferChunkCount: string;
    seLogBufferConnBlockingDequeue: string;
    seLogBufferConnlogSize: string;
    seLogBufferEventsBlockingDequeue: string;
    seLogBufferEventsSize: string;
    sslSessCachePerVs: string;
    tcpSyncacheHashsize: string;
}

export interface GetSepropertiesSeBootupPropertySeDpCompression {
    bufNum: string;
    bufSize: string;
    hashSize: string;
    levelAggressive: string;
    levelNormal: string;
    windowSize: string;
}

export interface GetSepropertiesSeRuntimeProperty {
    adminSshEnabled: string;
    appHeaders: outputs.GetSepropertiesSeRuntimePropertyAppHeader[];
    baremetalDispatcherHandlesFlows: string;
    connectionsLossyLogRateLimiterThreshold: string;
    connectionsUdfnfLogRateLimiterThreshold: string;
    disableFlowProbes: string;
    dosProfiles: outputs.GetSepropertiesSeRuntimePropertyDosProfile[];
    downstreamSendTimeout: string;
    dpAggressiveHbFrequency: string;
    dpAggressiveHbTimeoutCount: string;
    dpHbFrequency: string;
    dpHbTimeoutCount: string;
    dupipFrequency: string;
    dupipTimeoutCount: string;
    enableHsmLog: string;
    feproxyVipsEnableProxyArp: string;
    flowTableBatchPushFrequency: string;
    globalMtu: string;
    httpRumConsoleLog: string;
    httpRumMinContentLength: string;
    lbactionNumRequestsToDispatch: string;
    lbactionRqPerRequestMaxRetries: string;
    logAgentCompressLogs: string;
    logAgentFileSzAppl: string;
    logAgentFileSzConn: string;
    logAgentFileSzDebug: string;
    logAgentFileSzEvent: string;
    logAgentLogStorageMinSz: string;
    logAgentMaxConcurrentRsync: string;
    logAgentMaxStorageExcessPercent: string;
    logAgentMaxStorageIgnorePercent: string;
    logAgentMinStoragePerVs: string;
    logAgentSleepInterval: string;
    logAgentUnknownVsTimer: string;
    logMessageMaxFileListSize: string;
    ngxFreeConnectionStack: string;
    persistenceMemMax: string;
    scaleoutUdpPerPkt: string;
    seAuthLdapBindTimeout: string;
    seAuthLdapCacheSize: string;
    seAuthLdapConnectTimeout: string;
    seAuthLdapConnsPerServer: string;
    seAuthLdapReconnectTimeout: string;
    seAuthLdapRequestTimeout: string;
    seAuthLdapServersFailoverOnly: string;
    seDpCompressions: outputs.GetSepropertiesSeRuntimePropertySeDpCompression[];
    seDpHmDrops: string;
    seDpIfStatePollInterval: string;
    seDpLogNfEnqueuePercent: string;
    seDpLogUdfEnqueuePercent: string;
    seDumpCoreOnAssert: string;
    seHandleInterfaceRoutes: string;
    seHbPersistFudgeBits: string;
    seMacErrorThresholdToDisablePromiscious: string;
    seMemoryPoison: string;
    seMetricsInterval: string;
    seMetricsRtEnabled: string;
    seMetricsRtInterval: string;
    sePacketBufferMax: string;
    seRandomTcpDrops: string;
    seRateLimiters: outputs.GetSepropertiesSeRuntimePropertySeRateLimiter[];
    serviceIpSubnets: outputs.GetSepropertiesSeRuntimePropertyServiceIpSubnet[];
    servicePortRanges: outputs.GetSepropertiesSeRuntimePropertyServicePortRange[];
    servicesAccessibleAllInterfaces: string;
    tcpSyncacheMaxRetransmitDefault: string;
    upstreamConnectTimeout: string;
    upstreamConnpoolCacheThresh: string;
    upstreamConnpoolConnIdleThreshTmo: string;
    upstreamConnpoolCoreMaxCache: string;
    upstreamConnpoolEnable: string;
    upstreamKeepalive: string;
    upstreamReadTimeout: string;
    upstreamSendTimeout: string;
    userDefinedMetricAge: string;
}

export interface GetSepropertiesSeRuntimePropertyAppHeader {
    hdrMatchCase: string;
    hdrName: string;
    hdrStringOp: string;
}

export interface GetSepropertiesSeRuntimePropertyDosProfile {
    threshInfos: outputs.GetSepropertiesSeRuntimePropertyDosProfileThreshInfo[];
    threshPeriod: string;
}

export interface GetSepropertiesSeRuntimePropertyDosProfileThreshInfo {
    attack: string;
    maxValue: string;
    minValue: string;
}

export interface GetSepropertiesSeRuntimePropertySeDpCompression {
    maxLowRtt: string;
    minHighRtt: string;
    minLength: string;
    mobileStrs: string[];
}

export interface GetSepropertiesSeRuntimePropertySeRateLimiter {
    arpRl: string;
    defaultRl: string;
    flowProbeRl: string;
    icmpRl: string;
    icmpRspRl: string;
    rstRl: string;
}

export interface GetSepropertiesSeRuntimePropertyServiceIpSubnet {
    ipAddrs: outputs.GetSepropertiesSeRuntimePropertyServiceIpSubnetIpAddr[];
    mask: string;
}

export interface GetSepropertiesSeRuntimePropertyServiceIpSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetSepropertiesSeRuntimePropertyServicePortRange {
    end: string;
    start: string;
}

export interface GetServerDiscoveredNetwork {
    networkRef: string;
    subnet6s: outputs.GetServerDiscoveredNetworkSubnet6[];
    subnets: outputs.GetServerDiscoveredNetworkSubnet[];
}

export interface GetServerDiscoveredNetworkSubnet {
    ipAddrs: outputs.GetServerDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface GetServerDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.GetServerDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface GetServerDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetServerDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetServerLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GetServerautoscalepolicyConfigpbAttribute {
    version: string;
}

export interface GetServerautoscalepolicyMarker {
    key: string;
    values: string[];
}

export interface GetServerautoscalepolicyScheduledScaling {
    autoscalingDuration: string;
    cronExpression: string;
    desiredCapacity: string;
    enable: string;
    endDate: string;
    scheduleMaxStep: string;
    startDate: string;
}

export interface GetServiceauthprofileConfigpbAttribute {
    version: string;
}

export interface GetServiceauthprofileServiceOauthProfile {
    authorizationEndpoint: string;
    clientId: string;
    orgId: string;
    serviceId: string;
    serviceName: string;
}

export interface GetServiceengineDataVnic {
    adapter: string;
    aggregatorChgd: string;
    canSeDpTakeover: string;
    connected: string;
    delPending: string;
    deleteVnic: string;
    dhcpEnabled: string;
    dpDeletionDone: string;
    enabled: string;
    ifName: string;
    ip6AutocfgEnabled: string;
    isAsm: string;
    isAviInternalNetwork: string;
    isHsm: string;
    isMgmt: string;
    isPortchannel: string;
    linkUp: string;
    linuxName: string;
    macAddress: string;
    members: outputs.GetServiceengineDataVnicMember[];
    mtu: string;
    networkName: string;
    networkRef: string;
    numRxDescriptors: string;
    numTxDescriptors: string;
    pciId: string;
    portUuid: string;
    vlanId: string;
    vlanInterfaces: outputs.GetServiceengineDataVnicVlanInterface[];
    vnicNetworks: outputs.GetServiceengineDataVnicVnicNetwork[];
    vrfId: string;
    vrfRef: string;
}

export interface GetServiceengineDataVnicMember {
    active: string;
    ifName: string;
    macAddress: string;
}

export interface GetServiceengineDataVnicVlanInterface {
    dhcpEnabled: string;
    enabled: string;
    ifName: string;
    ip6AutocfgEnabled: string;
    isMgmt: string;
    vlanId: string;
    vnicNetworks: outputs.GetServiceengineDataVnicVlanInterfaceVnicNetwork[];
    vrfRef: string;
}

export interface GetServiceengineDataVnicVlanInterfaceVnicNetwork {
    ctlrAlloc: string;
    ips: outputs.GetServiceengineDataVnicVlanInterfaceVnicNetworkIp[];
    mode: string;
}

export interface GetServiceengineDataVnicVlanInterfaceVnicNetworkIp {
    ipAddrs: outputs.GetServiceengineDataVnicVlanInterfaceVnicNetworkIpIpAddr[];
    mask: string;
}

export interface GetServiceengineDataVnicVlanInterfaceVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceengineDataVnicVnicNetwork {
    ctlrAlloc: string;
    ips: outputs.GetServiceengineDataVnicVnicNetworkIp[];
    mode: string;
}

export interface GetServiceengineDataVnicVnicNetworkIp {
    ipAddrs: outputs.GetServiceengineDataVnicVnicNetworkIpIpAddr[];
    mask: string;
}

export interface GetServiceengineDataVnicVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceengineMgmtVnic {
    adapter: string;
    aggregatorChgd: string;
    canSeDpTakeover: string;
    connected: string;
    delPending: string;
    deleteVnic: string;
    dhcpEnabled: string;
    dpDeletionDone: string;
    enabled: string;
    ifName: string;
    ip6AutocfgEnabled: string;
    isAsm: string;
    isAviInternalNetwork: string;
    isHsm: string;
    isMgmt: string;
    isPortchannel: string;
    linkUp: string;
    linuxName: string;
    macAddress: string;
    members: outputs.GetServiceengineMgmtVnicMember[];
    mtu: string;
    networkName: string;
    networkRef: string;
    numRxDescriptors: string;
    numTxDescriptors: string;
    pciId: string;
    portUuid: string;
    vlanId: string;
    vlanInterfaces: outputs.GetServiceengineMgmtVnicVlanInterface[];
    vnicNetworks: outputs.GetServiceengineMgmtVnicVnicNetwork[];
    vrfId: string;
    vrfRef: string;
}

export interface GetServiceengineMgmtVnicMember {
    active: string;
    ifName: string;
    macAddress: string;
}

export interface GetServiceengineMgmtVnicVlanInterface {
    dhcpEnabled: string;
    enabled: string;
    ifName: string;
    ip6AutocfgEnabled: string;
    isMgmt: string;
    vlanId: string;
    vnicNetworks: outputs.GetServiceengineMgmtVnicVlanInterfaceVnicNetwork[];
    vrfRef: string;
}

export interface GetServiceengineMgmtVnicVlanInterfaceVnicNetwork {
    ctlrAlloc: string;
    ips: outputs.GetServiceengineMgmtVnicVlanInterfaceVnicNetworkIp[];
    mode: string;
}

export interface GetServiceengineMgmtVnicVlanInterfaceVnicNetworkIp {
    ipAddrs: outputs.GetServiceengineMgmtVnicVlanInterfaceVnicNetworkIpIpAddr[];
    mask: string;
}

export interface GetServiceengineMgmtVnicVlanInterfaceVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceengineMgmtVnicVnicNetwork {
    ctlrAlloc: string;
    ips: outputs.GetServiceengineMgmtVnicVnicNetworkIp[];
    mode: string;
}

export interface GetServiceengineMgmtVnicVnicNetworkIp {
    ipAddrs: outputs.GetServiceengineMgmtVnicVnicNetworkIpIpAddr[];
    mask: string;
}

export interface GetServiceengineMgmtVnicVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceengineResource {
    coresPerSocket: string;
    disk: string;
    hyperThreading: string;
    hypervisorMode: string;
    memory: string;
    numDatapathProcesses: string;
    numVcpus: string;
    sockets: string;
}

export interface GetServiceenginegroupConfigpbAttribute {
    version: string;
}

export interface GetServiceenginegroupCustomTag {
    tagKey: string;
    tagVal: string;
}

export interface GetServiceenginegroupGcpConfig {
    backendDataVpcNetworkName: string;
    backendDataVpcProjectId: string;
    backendDataVpcSubnetName: string;
}

export interface GetServiceenginegroupInstanceFlavorInfo {
    cost: string;
    diskGb: string;
    enhancedNw: string;
    id: string;
    isRecommended: string;
    maxIp6sPerNic: string;
    maxIpsPerNic: string;
    maxNics: string;
    metas: outputs.GetServiceenginegroupInstanceFlavorInfoMeta[];
    name: string;
    public: string;
    ramMb: string;
    vcpus: string;
}

export interface GetServiceenginegroupInstanceFlavorInfoMeta {
    key: string;
    value: string;
}

export interface GetServiceenginegroupIptable {
    chain: string;
    rules: outputs.GetServiceenginegroupIptableRule[];
    table: string;
}

export interface GetServiceenginegroupIptableRule {
    action: string;
    dnatIps: outputs.GetServiceenginegroupIptableRuleDnatIp[];
    dstIps: outputs.GetServiceenginegroupIptableRuleDstIp[];
    dstPorts: outputs.GetServiceenginegroupIptableRuleDstPort[];
    inputInterface: string;
    outputInterface: string;
    proto: string;
    srcIps: outputs.GetServiceenginegroupIptableRuleSrcIp[];
    srcPorts: outputs.GetServiceenginegroupIptableRuleSrcPort[];
    tag: string;
}

export interface GetServiceenginegroupIptableRuleDnatIp {
    addr: string;
    type: string;
}

export interface GetServiceenginegroupIptableRuleDstIp {
    ipAddrs: outputs.GetServiceenginegroupIptableRuleDstIpIpAddr[];
    mask: string;
}

export interface GetServiceenginegroupIptableRuleDstIpIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceenginegroupIptableRuleDstPort {
    end: string;
    start: string;
}

export interface GetServiceenginegroupIptableRuleSrcIp {
    ipAddrs: outputs.GetServiceenginegroupIptableRuleSrcIpIpAddr[];
    mask: string;
}

export interface GetServiceenginegroupIptableRuleSrcIpIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceenginegroupIptableRuleSrcPort {
    end: string;
    start: string;
}

export interface GetServiceenginegroupKniAllowedServerPort {
    protocol: string;
    ranges: outputs.GetServiceenginegroupKniAllowedServerPortRange[];
}

export interface GetServiceenginegroupKniAllowedServerPortRange {
    end: string;
    start: string;
}

export interface GetServiceenginegroupLabel {
    key: string;
    value: string;
}

export interface GetServiceenginegroupMarker {
    key: string;
    values: string[];
}

export interface GetServiceenginegroupMgmtSubnet {
    ipAddrs: outputs.GetServiceenginegroupMgmtSubnetIpAddr[];
    mask: string;
}

export interface GetServiceenginegroupMgmtSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceenginegroupObjsyncConfig {
    objsyncCpuLimit: string;
    objsyncHubElectInterval: string;
    objsyncReconcileInterval: string;
}

export interface GetServiceenginegroupRealtimeSeMetric {
    duration: string;
    enabled: string;
}

export interface GetServiceenginegroupSeDosProfile {
    threshInfos: outputs.GetServiceenginegroupSeDosProfileThreshInfo[];
    threshPeriod: string;
}

export interface GetServiceenginegroupSeDosProfileThreshInfo {
    attack: string;
    maxValue: string;
    minValue: string;
}

export interface GetServiceenginegroupSeGroupAnalyticsPolicy {
    metricsEventThresholds: outputs.GetServiceenginegroupSeGroupAnalyticsPolicyMetricsEventThreshold[];
}

export interface GetServiceenginegroupSeGroupAnalyticsPolicyMetricsEventThreshold {
    metricsEventThresholdType: string;
    resetThreshold: string;
    watermarkThresholds: number[];
}

export interface GetServiceenginegroupSeRlProp {
    msfNumStages: string;
    msfStageSize: string;
}

export interface GetServiceenginegroupSeTimeTrackerProp {
    egressAuditMode: string;
    egressThreshold: string;
    eventGenWindow: string;
    ingressAuditMode: string;
    ingressThreshold: string;
}

export interface GetServiceenginegroupSeTracertPortRange {
    end: string;
    start: string;
}

export interface GetServiceenginegroupServiceIp6Subnet {
    ipAddrs: outputs.GetServiceenginegroupServiceIp6SubnetIpAddr[];
    mask: string;
}

export interface GetServiceenginegroupServiceIp6SubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceenginegroupServiceIpSubnet {
    ipAddrs: outputs.GetServiceenginegroupServiceIpSubnetIpAddr[];
    mask: string;
}

export interface GetServiceenginegroupServiceIpSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetServiceenginegroupUserAgentCacheConfig {
    batchSize: string;
    controllerCacheSize: string;
    maxAge: string;
    maxLastHitTime: string;
    maxUpstreamQueries: string;
    maxWaitTime: string;
    numEntriesUpstreamUpdate: string;
    percentReservedForBadBots: string;
    percentReservedForBrowsers: string;
    percentReservedForGoodBots: string;
    percentReservedForOutstanding: string;
    seCacheSize: string;
    upstreamUpdateInterval: string;
}

export interface GetServiceenginegroupVcenter {
    clusters: outputs.GetServiceenginegroupVcenterCluster[];
    nsxtClusters: outputs.GetServiceenginegroupVcenterNsxtCluster[];
    nsxtDatastores: outputs.GetServiceenginegroupVcenterNsxtDatastore[];
    nsxtHosts: outputs.GetServiceenginegroupVcenterNsxtHost[];
    vcenterFolder: string;
    vcenterRef: string;
}

export interface GetServiceenginegroupVcenterCluster {
    clusterId: string;
    overrideVsphereHa: string;
    vmgName: string;
}

export interface GetServiceenginegroupVcenterDatastore {
    datastoreName: string;
    managedObjectId: string;
}

export interface GetServiceenginegroupVcenterHost {
    hostRefs: string[];
    include: string;
}

export interface GetServiceenginegroupVcenterNsxtCluster {
    clusterIds: string[];
    include: string;
}

export interface GetServiceenginegroupVcenterNsxtDatastore {
    dsIds: string[];
    include: string;
}

export interface GetServiceenginegroupVcenterNsxtHost {
    hostIds: string[];
    include: string;
}

export interface GetServiceenginegroupVipAsg {
    configurations: outputs.GetServiceenginegroupVipAsgConfiguration[];
    policies: outputs.GetServiceenginegroupVipAsgPolicy[];
}

export interface GetServiceenginegroupVipAsgConfiguration {
    zones: outputs.GetServiceenginegroupVipAsgConfigurationZone[];
}

export interface GetServiceenginegroupVipAsgConfigurationZone {
    availabilityZone: string;
    fipCapable: string;
    subnetUuid: string;
}

export interface GetServiceenginegroupVipAsgPolicy {
    dnsCooldown: string;
    maxSize: string;
    minSize: string;
    suspend: string;
}

export interface GetServiceenginegroupVssPlacement {
    coreNonaffinity: string;
    numSubcores: string;
}

export interface GetSnmptrapprofileConfigpbAttribute {
    version: string;
}

export interface GetSnmptrapprofileTrapServer {
    community: string;
    ipAddrs: outputs.GetSnmptrapprofileTrapServerIpAddr[];
    port: string;
    users: outputs.GetSnmptrapprofileTrapServerUser[];
    version: string;
}

export interface GetSnmptrapprofileTrapServerIpAddr {
    addr: string;
    type: string;
}

export interface GetSnmptrapprofileTrapServerUser {
    authPassphrase: string;
    authType: string;
    privPassphrase: string;
    privType: string;
    username: string;
}

export interface GetSslkeyandcertificateCaCert {
    caRef: string;
    name: string;
}

export interface GetSslkeyandcertificateCertificate {
    certificate: string;
    certificateSigningRequest: string;
    chainVerified: string;
    daysUntilExpire: string;
    expiryStatus: string;
    fingerprint: string;
    issuers: outputs.GetSslkeyandcertificateCertificateIssuer[];
    keyParams: outputs.GetSslkeyandcertificateCertificateKeyParam[];
    notAfter: string;
    notBefore: string;
    publicKey: string;
    selfSigned: string;
    serialNumber: string;
    signature: string;
    signatureAlgorithm: string;
    subjectAltNames: string[];
    subjects: outputs.GetSslkeyandcertificateCertificateSubject[];
    text: string;
    version: string;
}

export interface GetSslkeyandcertificateCertificateIssuer {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface GetSslkeyandcertificateCertificateKeyParam {
    algorithm: string;
    ecParams: outputs.GetSslkeyandcertificateCertificateKeyParamEcParam[];
    rsaParams: outputs.GetSslkeyandcertificateCertificateKeyParamRsaParam[];
}

export interface GetSslkeyandcertificateCertificateKeyParamEcParam {
    curve: string;
}

export interface GetSslkeyandcertificateCertificateKeyParamRsaParam {
    exponent: string;
    keySize: string;
}

export interface GetSslkeyandcertificateCertificateSubject {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface GetSslkeyandcertificateConfigpbAttribute {
    version: string;
}

export interface GetSslkeyandcertificateDynamicParam {
    isDynamic: string;
    isSensitive: string;
    name: string;
    value: string;
}

export interface GetSslkeyandcertificateKeyParam {
    algorithm: string;
    ecParams: outputs.GetSslkeyandcertificateKeyParamEcParam[];
    rsaParams: outputs.GetSslkeyandcertificateKeyParamRsaParam[];
}

export interface GetSslkeyandcertificateKeyParamEcParam {
    curve: string;
}

export interface GetSslkeyandcertificateKeyParamRsaParam {
    exponent: string;
    keySize: string;
}

export interface GetSslkeyandcertificateMarker {
    key: string;
    values: string[];
}

export interface GetSslkeyandcertificateOcspConfig {
    failedOcspJobsRetryInterval: string;
    maxTries: string;
    ocspReqInterval: string;
    ocspRespTimeout: string;
    responderUrlLists: string[];
    urlAction: string;
}

export interface GetSslkeyandcertificateOcspResponseInfo {
    certStatus: string;
    nextUpdate: string;
    ocspRespFromResponderUrl: string;
    ocspResponse: string;
    revocationReason: string;
    revocationTime: string;
    thisUpdate: string;
}

export interface GetSslprofileAcceptedVersion {
    type: string;
}

export interface GetSslprofileConfigpbAttribute {
    version: string;
}

export interface GetSslprofileMarker {
    key: string;
    values: string[];
}

export interface GetSslprofileSslRating {
    compatibilityRating: string;
    performanceRating: string;
    securityScore: string;
}

export interface GetSslprofileTag {
    type: string;
    value: string;
}

export interface GetSsopolicyAuthenticationPolicy {
    authnRules: outputs.GetSsopolicyAuthenticationPolicyAuthnRule[];
    defaultAuthProfileRef: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRule {
    actions: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleAction[];
    enable: string;
    index: string;
    matches: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatch[];
    name: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleAction {
    type: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatch {
    clientIps: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIp[];
    hostHdrs: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchHostHdr[];
    paths: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchPath[];
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIp {
    addrs: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefix[];
    ranges: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRange[];
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRange {
    begins: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeBegin[];
    ends: outputs.GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeEnd[];
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetSsopolicyAuthenticationPolicyAuthnRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetSsopolicyAuthorizationPolicy {
    authzRules: outputs.GetSsopolicyAuthorizationPolicyAuthzRule[];
}

export interface GetSsopolicyAuthorizationPolicyAuthzRule {
    actions: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleAction[];
    enable: string;
    index: string;
    matches: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatch[];
    name: string;
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleAction {
    statusCode: string;
    type: string;
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatch {
    accessTokens: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchAccessToken[];
    attrMatches: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatch[];
    hostHdrs: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchHostHdr[];
    methods: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchMethod[];
    paths: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchPath[];
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchAccessToken {
    matches: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatch[];
    tokenName: string;
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatch {
    boolMatch: string;
    intMatch: string;
    isMandatory: string;
    name: string;
    stringMatches: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatchStringMatch[];
    type: string;
    validate: string;
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatchStringMatch {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatch {
    attributeName: string;
    attributeValueLists: outputs.GetSsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatchAttributeValueList[];
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatchAttributeValueList {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetSsopolicyAuthorizationPolicyAuthzRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetSsopolicyConfigpbAttribute {
    version: string;
}

export interface GetSsopolicyMarker {
    key: string;
    values: string[];
}

export interface GetStatediffoperationEvent {
    duration: string;
    endTime: string;
    message: string;
    startTime: string;
    status: string;
    taskName: string;
}

export interface GetStatediffsnapshotPostSnapshot {
    gssnapshots: outputs.GetStatediffsnapshotPostSnapshotGssnapshot[];
    poolsnapshots: outputs.GetStatediffsnapshotPostSnapshotPoolsnapshot[];
    sesnapshots: outputs.GetStatediffsnapshotPostSnapshotSesnapshot[];
    vssnapshots: outputs.GetStatediffsnapshotPostSnapshotVssnapshot[];
}

export interface GetStatediffsnapshotPostSnapshotGssnapshot {
    operStatuses: outputs.GetStatediffsnapshotPostSnapshotGssnapshotOperStatus[];
}

export interface GetStatediffsnapshotPostSnapshotGssnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPostSnapshotGssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPostSnapshotGssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStatediffsnapshotPostSnapshotPoolsnapshot {
    operStatuses: outputs.GetStatediffsnapshotPostSnapshotPoolsnapshotOperStatus[];
}

export interface GetStatediffsnapshotPostSnapshotPoolsnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPostSnapshotPoolsnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPostSnapshotPoolsnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStatediffsnapshotPostSnapshotSesnapshot {
    operStatuses: outputs.GetStatediffsnapshotPostSnapshotSesnapshotOperStatus[];
}

export interface GetStatediffsnapshotPostSnapshotSesnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPostSnapshotSesnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPostSnapshotSesnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStatediffsnapshotPostSnapshotVssnapshot {
    operStatuses: outputs.GetStatediffsnapshotPostSnapshotVssnapshotOperStatus[];
}

export interface GetStatediffsnapshotPostSnapshotVssnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPostSnapshotVssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPostSnapshotVssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStatediffsnapshotPreSnapshot {
    gssnapshots: outputs.GetStatediffsnapshotPreSnapshotGssnapshot[];
    poolsnapshots: outputs.GetStatediffsnapshotPreSnapshotPoolsnapshot[];
    sesnapshots: outputs.GetStatediffsnapshotPreSnapshotSesnapshot[];
    vssnapshots: outputs.GetStatediffsnapshotPreSnapshotVssnapshot[];
}

export interface GetStatediffsnapshotPreSnapshotGssnapshot {
    operStatuses: outputs.GetStatediffsnapshotPreSnapshotGssnapshotOperStatus[];
}

export interface GetStatediffsnapshotPreSnapshotGssnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPreSnapshotGssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPreSnapshotGssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStatediffsnapshotPreSnapshotPoolsnapshot {
    operStatuses: outputs.GetStatediffsnapshotPreSnapshotPoolsnapshotOperStatus[];
}

export interface GetStatediffsnapshotPreSnapshotPoolsnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPreSnapshotPoolsnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPreSnapshotPoolsnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStatediffsnapshotPreSnapshotSesnapshot {
    operStatuses: outputs.GetStatediffsnapshotPreSnapshotSesnapshotOperStatus[];
}

export interface GetStatediffsnapshotPreSnapshotSesnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPreSnapshotSesnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPreSnapshotSesnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStatediffsnapshotPreSnapshotVssnapshot {
    operStatuses: outputs.GetStatediffsnapshotPreSnapshotVssnapshotOperStatus[];
}

export interface GetStatediffsnapshotPreSnapshotVssnapshotOperStatus {
    lastChangedTimes: outputs.GetStatediffsnapshotPreSnapshotVssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons: string[];
    state: string;
}

export interface GetStatediffsnapshotPreSnapshotVssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetStringgroupConfigpbAttribute {
    version: string;
}

export interface GetStringgroupKv {
    key: string;
    value: string;
}

export interface GetStringgroupMarker {
    key: string;
    values: string[];
}

export interface GetSystemconfigurationAdminAuthConfiguration {
    allowLocalUserLogin: string;
    remoteAuthConfigurations: outputs.GetSystemconfigurationAdminAuthConfigurationRemoteAuthConfiguration[];
    serviceAuthConfigurations: outputs.GetSystemconfigurationAdminAuthConfigurationServiceAuthConfiguration[];
}

export interface GetSystemconfigurationAdminAuthConfigurationRemoteAuthConfiguration {
    authMappingProfileRef: string;
    authProfileRef: string;
    index: string;
}

export interface GetSystemconfigurationAdminAuthConfigurationServiceAuthConfiguration {
    index: string;
    serviceAuthMappingProfileRef: string;
    serviceAuthProfileRef: string;
}

export interface GetSystemconfigurationConfigpbAttribute {
    version: string;
}

export interface GetSystemconfigurationControllerAnalyticsPolicy {
    metricsEventThresholds: outputs.GetSystemconfigurationControllerAnalyticsPolicyMetricsEventThreshold[];
}

export interface GetSystemconfigurationControllerAnalyticsPolicyMetricsEventThreshold {
    metricsEventThresholdType: string;
    resetThreshold: string;
    watermarkThresholds: number[];
}

export interface GetSystemconfigurationDnsConfiguration {
    searchDomain: string;
    serverLists: outputs.GetSystemconfigurationDnsConfigurationServerList[];
}

export interface GetSystemconfigurationDnsConfigurationServerList {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationEmailConfiguration {
    authPassword: string;
    authUsername: string;
    disableTls: string;
    emailTimezone: string;
    fromEmail: string;
    fromName: string;
    mailServerName: string;
    mailServerPort: string;
    smtpType: string;
}

export interface GetSystemconfigurationGlobalTenantConfig {
    seInProviderContext: string;
    tenantAccessToProviderSe: string;
    tenantVrf: string;
}

export interface GetSystemconfigurationLinuxConfiguration {
    banner: string;
    cisMode: string;
    motd: string;
}

export interface GetSystemconfigurationMgmtIpAccessControl {
    apiAccesses: outputs.GetSystemconfigurationMgmtIpAccessControlApiAccess[];
    shellServerAccesses: outputs.GetSystemconfigurationMgmtIpAccessControlShellServerAccess[];
    snmpAccesses: outputs.GetSystemconfigurationMgmtIpAccessControlSnmpAccess[];
    sshAccesses: outputs.GetSystemconfigurationMgmtIpAccessControlSshAccess[];
    sysintAccesses: outputs.GetSystemconfigurationMgmtIpAccessControlSysintAccess[];
}

export interface GetSystemconfigurationMgmtIpAccessControlApiAccess {
    addrs: outputs.GetSystemconfigurationMgmtIpAccessControlApiAccessAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetSystemconfigurationMgmtIpAccessControlApiAccessPrefix[];
    ranges: outputs.GetSystemconfigurationMgmtIpAccessControlApiAccessRange[];
}

export interface GetSystemconfigurationMgmtIpAccessControlApiAccessAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlApiAccessPrefix {
    ipAddrs: outputs.GetSystemconfigurationMgmtIpAccessControlApiAccessPrefixIpAddr[];
    mask: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlApiAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlApiAccessRange {
    begins: outputs.GetSystemconfigurationMgmtIpAccessControlApiAccessRangeBegin[];
    ends: outputs.GetSystemconfigurationMgmtIpAccessControlApiAccessRangeEnd[];
}

export interface GetSystemconfigurationMgmtIpAccessControlApiAccessRangeBegin {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlApiAccessRangeEnd {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlShellServerAccess {
    addrs: outputs.GetSystemconfigurationMgmtIpAccessControlShellServerAccessAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetSystemconfigurationMgmtIpAccessControlShellServerAccessPrefix[];
    ranges: outputs.GetSystemconfigurationMgmtIpAccessControlShellServerAccessRange[];
}

export interface GetSystemconfigurationMgmtIpAccessControlShellServerAccessAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlShellServerAccessPrefix {
    ipAddrs: outputs.GetSystemconfigurationMgmtIpAccessControlShellServerAccessPrefixIpAddr[];
    mask: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlShellServerAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlShellServerAccessRange {
    begins: outputs.GetSystemconfigurationMgmtIpAccessControlShellServerAccessRangeBegin[];
    ends: outputs.GetSystemconfigurationMgmtIpAccessControlShellServerAccessRangeEnd[];
}

export interface GetSystemconfigurationMgmtIpAccessControlShellServerAccessRangeBegin {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlShellServerAccessRangeEnd {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSnmpAccess {
    addrs: outputs.GetSystemconfigurationMgmtIpAccessControlSnmpAccessAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetSystemconfigurationMgmtIpAccessControlSnmpAccessPrefix[];
    ranges: outputs.GetSystemconfigurationMgmtIpAccessControlSnmpAccessRange[];
}

export interface GetSystemconfigurationMgmtIpAccessControlSnmpAccessAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSnmpAccessPrefix {
    ipAddrs: outputs.GetSystemconfigurationMgmtIpAccessControlSnmpAccessPrefixIpAddr[];
    mask: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSnmpAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSnmpAccessRange {
    begins: outputs.GetSystemconfigurationMgmtIpAccessControlSnmpAccessRangeBegin[];
    ends: outputs.GetSystemconfigurationMgmtIpAccessControlSnmpAccessRangeEnd[];
}

export interface GetSystemconfigurationMgmtIpAccessControlSnmpAccessRangeBegin {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSnmpAccessRangeEnd {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSshAccess {
    addrs: outputs.GetSystemconfigurationMgmtIpAccessControlSshAccessAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetSystemconfigurationMgmtIpAccessControlSshAccessPrefix[];
    ranges: outputs.GetSystemconfigurationMgmtIpAccessControlSshAccessRange[];
}

export interface GetSystemconfigurationMgmtIpAccessControlSshAccessAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSshAccessPrefix {
    ipAddrs: outputs.GetSystemconfigurationMgmtIpAccessControlSshAccessPrefixIpAddr[];
    mask: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSshAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSshAccessRange {
    begins: outputs.GetSystemconfigurationMgmtIpAccessControlSshAccessRangeBegin[];
    ends: outputs.GetSystemconfigurationMgmtIpAccessControlSshAccessRangeEnd[];
}

export interface GetSystemconfigurationMgmtIpAccessControlSshAccessRangeBegin {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSshAccessRangeEnd {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSysintAccess {
    addrs: outputs.GetSystemconfigurationMgmtIpAccessControlSysintAccessAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetSystemconfigurationMgmtIpAccessControlSysintAccessPrefix[];
    ranges: outputs.GetSystemconfigurationMgmtIpAccessControlSysintAccessRange[];
}

export interface GetSystemconfigurationMgmtIpAccessControlSysintAccessAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSysintAccessPrefix {
    ipAddrs: outputs.GetSystemconfigurationMgmtIpAccessControlSysintAccessPrefixIpAddr[];
    mask: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSysintAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSysintAccessRange {
    begins: outputs.GetSystemconfigurationMgmtIpAccessControlSysintAccessRangeBegin[];
    ends: outputs.GetSystemconfigurationMgmtIpAccessControlSysintAccessRangeEnd[];
}

export interface GetSystemconfigurationMgmtIpAccessControlSysintAccessRangeBegin {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationMgmtIpAccessControlSysintAccessRangeEnd {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationNtpConfiguration {
    ntpAuthenticationKeys: outputs.GetSystemconfigurationNtpConfigurationNtpAuthenticationKey[];
    ntpServerLists: outputs.GetSystemconfigurationNtpConfigurationNtpServerList[];
    ntpServers: outputs.GetSystemconfigurationNtpConfigurationNtpServer[];
}

export interface GetSystemconfigurationNtpConfigurationNtpAuthenticationKey {
    algorithm: string;
    key: string;
    keyNumber: string;
}

export interface GetSystemconfigurationNtpConfigurationNtpServer {
    keyNumber: string;
    servers: outputs.GetSystemconfigurationNtpConfigurationNtpServerServer[];
}

export interface GetSystemconfigurationNtpConfigurationNtpServerList {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationNtpConfigurationNtpServerServer {
    addr: string;
    type: string;
}

export interface GetSystemconfigurationPortalConfiguration {
    allowBasicAuthentication: string;
    apiForceTimeout: string;
    disableRemoteCliShell: string;
    disableSwagger: string;
    enableClickjackingProtection: string;
    enableHttp: string;
    enableHttps: string;
    httpPort: string;
    httpsPort: string;
    minimumPasswordLength: string;
    passwordStrengthCheck: string;
    pkiprofileRef: string;
    redirectToHttps: string;
    sslkeyandcertificateRefs: string[];
    sslprofileRef: string;
    useUuidFromInput: string;
}

export interface GetSystemconfigurationProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface GetSystemconfigurationSecureChannelConfiguration {
    sslkeyandcertificateRefs: string[];
}

export interface GetSystemconfigurationSnmpConfiguration {
    community: string;
    largeTrapPayload: string;
    snmpV3Configs: outputs.GetSystemconfigurationSnmpConfigurationSnmpV3Config[];
    sysContact: string;
    sysLocation: string;
    version: string;
}

export interface GetSystemconfigurationSnmpConfigurationSnmpV3Config {
    engineId: string;
    users: outputs.GetSystemconfigurationSnmpConfigurationSnmpV3ConfigUser[];
}

export interface GetSystemconfigurationSnmpConfigurationSnmpV3ConfigUser {
    authPassphrase: string;
    authType: string;
    privPassphrase: string;
    privType: string;
    username: string;
}

export interface GetSystemlimitsConfigpbAttribute {
    version: string;
}

export interface GetSystemlimitsControllerLimit {
    botLimits: outputs.GetSystemlimitsControllerLimitBotLimit[];
    certificatesPerVirtualservice: string;
    controllerCloudLimits: outputs.GetSystemlimitsControllerLimitControllerCloudLimit[];
    controllerSizingLimits: outputs.GetSystemlimitsControllerLimitControllerSizingLimit[];
    defaultRoutesPerVrfcontext: string;
    gatewayMonPerVrf: string;
    ipaddressLimits: outputs.GetSystemlimitsControllerLimitIpaddressLimit[];
    ipsPerIpgroup: string;
    l7Limits: outputs.GetSystemlimitsControllerLimitL7Limit[];
    poolgroupsPerVirtualservice: string;
    poolsPerPoolgroup: string;
    poolsPerVirtualservice: string;
    routesPerVrfcontext: string;
    rulesPerNatPolicy: string;
    rulesPerNetworksecuritypolicy: string;
    serversPerPool: string;
    sniChildrenPerParent: string;
    stringsPerStringgroup: string;
    vsBgpScaleout: string;
    vsL2Scaleout: string;
    wafLimits: outputs.GetSystemlimitsControllerLimitWafLimit[];
}

export interface GetSystemlimitsControllerLimitBotLimit {
    allowRules: string;
    hdrs: string;
    mappingRules: string;
}

export interface GetSystemlimitsControllerLimitControllerCloudLimit {
    numClouds: string;
    t1LrsPerCloud: string;
    type: string;
}

export interface GetSystemlimitsControllerLimitControllerSizingLimit {
    controllerSizingCloudLimits: outputs.GetSystemlimitsControllerLimitControllerSizingLimitControllerSizingCloudLimit[];
    flavor: string;
    numClouds: string;
    numEastWestVirtualservices: string;
    numServers: string;
    numServiceengines: string;
    numTenants: string;
    numVirtualservices: string;
    numVirtualservicesRtMetrics: string;
    numVrfs: string;
    numWafVirtualservices: string;
}

export interface GetSystemlimitsControllerLimitControllerSizingLimitControllerSizingCloudLimit {
    numClouds: string;
    type: string;
}

export interface GetSystemlimitsControllerLimitIpaddressLimit {
    ipAddressGroupPerMatchCriteria: string;
    ipAddressPrefixPerMatchCriteria: string;
    ipAddressRangePerMatchCriteria: string;
    ipAddressesPerMatchCriteria: string;
}

export interface GetSystemlimitsControllerLimitL7Limit {
    httpPoliciesPerVs: string;
    numCompressionFilters: string;
    numCustomStr: string;
    numMatchesPerRule: string;
    numRulesPerEvhHost: string;
    numRulesPerHttpPolicy: string;
    numStrgroupsPerMatch: string;
    strCacheMime: string;
    strGroupsCacheMime: string;
    strGroupsNoCacheMime: string;
    strGroupsNoCacheUri: string;
    strNoCacheMime: string;
    strNoCacheUri: string;
}

export interface GetSystemlimitsControllerLimitWafLimit {
    numAllowedContentTypes: string;
    numAllowedRequestContentTypeCharsets: string;
    numAllowlistPolicyRules: string;
    numApplications: string;
    numContentTypeMappings: string;
    numDataFiles: string;
    numExcludeListPerRuleGroup: string;
    numPrePostCrsGroups: string;
    numPsmGroups: string;
    numPsmMatchElements: string;
    numPsmMatchRulesPerLoc: string;
    numPsmTotalLocations: string;
    numRestrictedExtensions: string;
    numRestrictedHeaders: string;
    numRuleTags: string;
    numRulesPerRulegroup: string;
    numStaticExtensions: string;
}

export interface GetSystemlimitsControllerSize {
    flavor: string;
    minCpus: string;
    minMemory: string;
}

export interface GetSystemlimitsServiceengineLimit {
    allVirtualservicesPerServiceengine: string;
    ewVirtualservicesPerServiceengine: string;
    nsVirtualservicesPerServiceengine: string;
    numLogicalIntfPerSe: string;
    numPhyIntfPerSe: string;
    numVirtualservicesRtMetrics: string;
    numVlanIntfPerPhyIntf: string;
    numVlanIntfPerSe: string;
    serviceengineCloudLimits: outputs.GetSystemlimitsServiceengineLimitServiceengineCloudLimit[];
}

export interface GetSystemlimitsServiceengineLimitServiceengineCloudLimit {
    type: string;
    vrfsPerServiceengine: string;
}

export interface GetSystemreportEvent {
    duration: string;
    endTime: string;
    eventName: string;
    messages: string[];
    startTime: string;
    status: string;
}

export interface GetSystemreportReadinessReport {
    name: string;
    nodeRef: string;
    nodeType: string;
    objCloudRef: string;
    systemReadinesses: outputs.GetSystemreportReadinessReportSystemReadiness[];
}

export interface GetSystemreportReadinessReportSystemReadiness {
    checks: outputs.GetSystemreportReadinessReportSystemReadinessCheck[];
    checksCompleted: string;
    duration: string;
    endTime: string;
    imageRef: string;
    patchImageRef: string;
    startTime: string;
    states: outputs.GetSystemreportReadinessReportSystemReadinessState[];
    totalChecks: string;
    upgradeOps: string;
}

export interface GetSystemreportReadinessReportSystemReadinessCheck {
    checkCode: string;
    description: string;
    details: string[];
    duration: string;
    endTime: string;
    errorDetails: string[];
    startTime: string;
    state: string;
}

export interface GetSystemreportReadinessReportSystemReadinessState {
    lastChangedTimes: outputs.GetSystemreportReadinessReportSystemReadinessStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface GetSystemreportReadinessReportSystemReadinessStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetSystemreportState {
    lastChangedTimes: outputs.GetSystemreportStateLastChangedTime[];
    reason: string;
    state: string;
}

export interface GetSystemreportStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetSystemreportSummary {
    description: string;
    previews: string[];
    title: string;
}

export interface GetSystemreportTask {
    name: string;
    reason: string;
    summaries: outputs.GetSystemreportTaskSummary[];
    taskJournalRef: string;
}

export interface GetSystemreportTaskSummary {
    description: string;
    duration: string;
    endTime: string;
    errorCount: string;
    reason: string;
    startTime: string;
    status: string;
    type: string;
}

export interface GetTaskjournalError {
    details: string[];
    name: string;
    object: string;
    tenant: string;
    uuid: string;
    version: string;
}

export interface GetTaskjournalInfo {
    actions: outputs.GetTaskjournalInfoAction[];
    totalObjects: string;
    versions: string[];
}

export interface GetTaskjournalInfoAction {
    objects: outputs.GetTaskjournalInfoActionObject[];
    version: string;
}

export interface GetTaskjournalInfoActionObject {
    failed: string;
    model: string;
    skipped: string;
    success: string;
}

export interface GetTaskjournalSummary {
    description: string;
    duration: string;
    endTime: string;
    errorCount: string;
    reason: string;
    startTime: string;
    status: string;
    type: string;
}

export interface GetTenantAttr {
    key: string;
    value: string;
}

export interface GetTenantConfigSetting {
    seInProviderContext: string;
    tenantAccessToProviderSe: string;
    tenantVrf: string;
}

export interface GetTenantConfigpbAttribute {
    version: string;
}

export interface GetTenantsystemconfigurationConfigpbAttribute {
    version: string;
}

export interface GetTestsedatastorelevel1ConfigpbAttribute {
    version: string;
}

export interface GetTestsedatastorelevel2ConfigpbAttribute {
    version: string;
}

export interface GetTestsedatastorelevel3ConfigpbAttribute {
    version: string;
}

export interface GetTrafficcloneprofileCloneServer {
    ipAddresses: outputs.GetTrafficcloneprofileCloneServerIpAddress[];
    mac: string;
    networkRef: string;
    subnets: outputs.GetTrafficcloneprofileCloneServerSubnet[];
}

export interface GetTrafficcloneprofileCloneServerIpAddress {
    addr: string;
    type: string;
}

export interface GetTrafficcloneprofileCloneServerSubnet {
    ipAddrs: outputs.GetTrafficcloneprofileCloneServerSubnetIpAddr[];
    mask: string;
}

export interface GetTrafficcloneprofileCloneServerSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetTrafficcloneprofileConfigpbAttribute {
    version: string;
}

export interface GetTrafficcloneprofileMarker {
    key: string;
    values: string[];
}

export interface GetUpgradestatusinfoHistory {
    duration: string;
    endTime: string;
    ops: string;
    patchVersion: string;
    seUpgradeEvents: outputs.GetUpgradestatusinfoHistorySeUpgradeEvent[];
    segStatuses: outputs.GetUpgradestatusinfoHistorySegStatus[];
    startTime: string;
    statediffRef: string;
    states: outputs.GetUpgradestatusinfoHistoryState[];
    upgradeEvents: outputs.GetUpgradestatusinfoHistoryUpgradeEvent[];
    version: string;
}

export interface GetUpgradestatusinfoHistorySeUpgradeEvent {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface GetUpgradestatusinfoHistorySegStatus {
    controllerVersion: string;
    disruptedVsReves: string[];
    duration: string;
    endTime: string;
    enqueueTime: string;
    haMode: string;
    inProgress: string;
    notes: string[];
    numSe: string;
    numSeWithNoVs: string;
    numSeWithVsNotScaledout: string;
    numSeWithVsScaledout: string;
    numVs: string;
    numVsDisrupted: string;
    progress: string;
    reasons: string[];
    requestTime: string;
    seAlreadyUpgradedAtStarts: string[];
    seDisconnectedAtStarts: string[];
    seGroupName: string;
    seGroupUuid: string;
    seIpMissingAtStarts: string[];
    sePoweredoffAtStarts: string[];
    seRebootInProgressRef: string;
    seUpgradeCompleteds: string[];
    seUpgradeErrors: outputs.GetUpgradestatusinfoHistorySegStatusSeUpgradeError[];
    seUpgradeFaileds: string[];
    seUpgradeInProgresses: string[];
    seUpgradeNotStarteds: string[];
    seUpgradeSkipSuspendeds: string[];
    seUpgradeSuspendeds: string[];
    seWithNoVs: string[];
    seWithVsNotScaledouts: string[];
    seWithVsScaledouts: string[];
    startTime: string;
    state: string;
    tenantRef: string;
    thread: string;
    trafficStatus: string;
    vsErrors: outputs.GetUpgradestatusinfoHistorySegStatusVsError[];
    vsMigrateInProgressReves: string[];
    vsScaleinInProgressReves: string[];
    vsScaleoutInProgressReves: string[];
    worker: string;
}

export interface GetUpgradestatusinfoHistorySegStatusSeUpgradeError {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface GetUpgradestatusinfoHistorySegStatusVsError {
    eventTimestamps: outputs.GetUpgradestatusinfoHistorySegStatusVsErrorEventTimestamp[];
    reasons: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    tenantRef: string;
    trafficStatus: string;
    vipId: string;
    vsRef: string;
}

export interface GetUpgradestatusinfoHistorySegStatusVsErrorEventTimestamp {
    secs: string;
    usecs: string;
}

export interface GetUpgradestatusinfoHistoryState {
    lastChangedTimes: outputs.GetUpgradestatusinfoHistoryStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface GetUpgradestatusinfoHistoryStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetUpgradestatusinfoHistoryUpgradeEvent {
    nodesEvents: outputs.GetUpgradestatusinfoHistoryUpgradeEventNodesEvent[];
    subEvents: outputs.GetUpgradestatusinfoHistoryUpgradeEventSubEvent[];
    task: string;
    taskName: string;
}

export interface GetUpgradestatusinfoHistoryUpgradeEventNodesEvent {
    duration: string;
    endTime: string;
    ips: outputs.GetUpgradestatusinfoHistoryUpgradeEventNodesEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks: string[];
}

export interface GetUpgradestatusinfoHistoryUpgradeEventNodesEventIp {
    addr: string;
    type: string;
}

export interface GetUpgradestatusinfoHistoryUpgradeEventSubEvent {
    duration: string;
    endTime: string;
    ips: outputs.GetUpgradestatusinfoHistoryUpgradeEventSubEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks: string[];
}

export interface GetUpgradestatusinfoHistoryUpgradeEventSubEventIp {
    addr: string;
    type: string;
}

export interface GetUpgradestatusinfoParam {
    imageRef: string;
    patchRef: string;
    seGroupOptions: outputs.GetUpgradestatusinfoParamSeGroupOption[];
    seGroupResumeOptions: outputs.GetUpgradestatusinfoParamSeGroupResumeOption[];
}

export interface GetUpgradestatusinfoParamSeGroupOption {
    actionOnError: string;
    disruptive: string;
}

export interface GetUpgradestatusinfoParamSeGroupResumeOption {
    actionOnError: string;
    disruptive: string;
    skipSuspended: string;
}

export interface GetUpgradestatusinfoPatchList {
    patchImagePath: string;
    patchImageRef: string;
    patchVersion: string;
}

export interface GetUpgradestatusinfoPreviousPatchList {
    patchImagePath: string;
    patchImageRef: string;
    patchVersion: string;
}

export interface GetUpgradestatusinfoSeUpgradeEvent {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface GetUpgradestatusinfoSegParam {
    imageRef: string;
    patchRef: string;
    seGroupOptions: outputs.GetUpgradestatusinfoSegParamSeGroupOption[];
    seGroupResumeOptions: outputs.GetUpgradestatusinfoSegParamSeGroupResumeOption[];
}

export interface GetUpgradestatusinfoSegParamSeGroupOption {
    actionOnError: string;
    disruptive: string;
}

export interface GetUpgradestatusinfoSegParamSeGroupResumeOption {
    actionOnError: string;
    disruptive: string;
    skipSuspended: string;
}

export interface GetUpgradestatusinfoSegStatus {
    controllerVersion: string;
    disruptedVsReves: string[];
    duration: string;
    endTime: string;
    enqueueTime: string;
    haMode: string;
    inProgress: string;
    notes: string[];
    numSe: string;
    numSeWithNoVs: string;
    numSeWithVsNotScaledout: string;
    numSeWithVsScaledout: string;
    numVs: string;
    numVsDisrupted: string;
    progress: string;
    reasons: string[];
    requestTime: string;
    seAlreadyUpgradedAtStarts: string[];
    seDisconnectedAtStarts: string[];
    seGroupName: string;
    seGroupUuid: string;
    seIpMissingAtStarts: string[];
    sePoweredoffAtStarts: string[];
    seRebootInProgressRef: string;
    seUpgradeCompleteds: string[];
    seUpgradeErrors: outputs.GetUpgradestatusinfoSegStatusSeUpgradeError[];
    seUpgradeFaileds: string[];
    seUpgradeInProgresses: string[];
    seUpgradeNotStarteds: string[];
    seUpgradeSkipSuspendeds: string[];
    seUpgradeSuspendeds: string[];
    seWithNoVs: string[];
    seWithVsNotScaledouts: string[];
    seWithVsScaledouts: string[];
    startTime: string;
    state: string;
    tenantRef: string;
    thread: string;
    trafficStatus: string;
    vsErrors: outputs.GetUpgradestatusinfoSegStatusVsError[];
    vsMigrateInProgressReves: string[];
    vsScaleinInProgressReves: string[];
    vsScaleoutInProgressReves: string[];
    worker: string;
}

export interface GetUpgradestatusinfoSegStatusSeUpgradeError {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface GetUpgradestatusinfoSegStatusVsError {
    eventTimestamps: outputs.GetUpgradestatusinfoSegStatusVsErrorEventTimestamp[];
    reasons: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    tenantRef: string;
    trafficStatus: string;
    vipId: string;
    vsRef: string;
}

export interface GetUpgradestatusinfoSegStatusVsErrorEventTimestamp {
    secs: string;
    usecs: string;
}

export interface GetUpgradestatusinfoState {
    lastChangedTimes: outputs.GetUpgradestatusinfoStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface GetUpgradestatusinfoStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetUpgradestatusinfoUpgradeEvent {
    nodesEvents: outputs.GetUpgradestatusinfoUpgradeEventNodesEvent[];
    subEvents: outputs.GetUpgradestatusinfoUpgradeEventSubEvent[];
    task: string;
    taskName: string;
}

export interface GetUpgradestatusinfoUpgradeEventNodesEvent {
    duration: string;
    endTime: string;
    ips: outputs.GetUpgradestatusinfoUpgradeEventNodesEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks: string[];
}

export interface GetUpgradestatusinfoUpgradeEventNodesEventIp {
    addr: string;
    type: string;
}

export interface GetUpgradestatusinfoUpgradeEventSubEvent {
    duration: string;
    endTime: string;
    ips: outputs.GetUpgradestatusinfoUpgradeEventSubEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks: string[];
}

export interface GetUpgradestatusinfoUpgradeEventSubEventIp {
    addr: string;
    type: string;
}

export interface GetUpgradestatusinfoUpgradeReadiness {
    checks: outputs.GetUpgradestatusinfoUpgradeReadinessCheck[];
    checksCompleted: string;
    duration: string;
    endTime: string;
    imageRef: string;
    patchImageRef: string;
    startTime: string;
    states: outputs.GetUpgradestatusinfoUpgradeReadinessState[];
    totalChecks: string;
    upgradeOps: string;
}

export interface GetUpgradestatusinfoUpgradeReadinessCheck {
    checkCode: string;
    description: string;
    details: string[];
    duration: string;
    endTime: string;
    errorDetails: string[];
    startTime: string;
    state: string;
}

export interface GetUpgradestatusinfoUpgradeReadinessState {
    lastChangedTimes: outputs.GetUpgradestatusinfoUpgradeReadinessStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface GetUpgradestatusinfoUpgradeReadinessStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetUpgradestatussummaryState {
    lastChangedTimes: outputs.GetUpgradestatussummaryStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface GetUpgradestatussummaryStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface GetUserAccess {
    allTenants: string;
    roleRef: string;
    tenantRef: string;
}

export interface GetUseraccountprofileConfigpbAttribute {
    version: string;
}

export interface GetVcenterserverConfigpbAttribute {
    version: string;
}

export interface GetVcenterserverContentLib {
    id: string;
    name: string;
}

export interface GetVirtualserviceAnalyticsPolicy {
    allHeaders: string;
    clientInsights: string;
    clientInsightsSamplings: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSampling[];
    clientLogFilters: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilter[];
    fullClientLogs: outputs.GetVirtualserviceAnalyticsPolicyFullClientLog[];
    learningLogPolicies: outputs.GetVirtualserviceAnalyticsPolicyLearningLogPolicy[];
    metricsRealtimeUpdates: outputs.GetVirtualserviceAnalyticsPolicyMetricsRealtimeUpdate[];
    significantLogThrottle: string;
    udfLogThrottle: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSampling {
    clientIps: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIp[];
    sampleUris: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingSampleUri[];
    skipUris: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingSkipUri[];
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIp {
    addrs: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefix[];
    ranges: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRange[];
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefix {
    ipAddrs: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRange {
    begins: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeBegin[];
    ends: outputs.GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeEnd[];
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingSampleUri {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetVirtualserviceAnalyticsPolicyClientInsightsSamplingSkipUri {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilter {
    allHeaders: string;
    clientIps: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterClientIp[];
    duration: string;
    enabled: string;
    index: string;
    name: string;
    uris: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterUri[];
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterClientIp {
    addrs: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefix[];
    ranges: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpRange[];
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefix {
    ipAddrs: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpRange {
    begins: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeBegin[];
    ends: outputs.GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeEnd[];
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetVirtualserviceAnalyticsPolicyClientLogFilterUri {
    matchCriteria: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetVirtualserviceAnalyticsPolicyFullClientLog {
    duration: string;
    enabled: string;
    throttle: string;
}

export interface GetVirtualserviceAnalyticsPolicyLearningLogPolicy {
    enabled: string;
    host: string;
    port: string;
}

export interface GetVirtualserviceAnalyticsPolicyMetricsRealtimeUpdate {
    duration: string;
    enabled: string;
}

export interface GetVirtualserviceConfigpbAttribute {
    version: string;
}

export interface GetVirtualserviceConnectionsRateLimit {
    actions: outputs.GetVirtualserviceConnectionsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetVirtualserviceConnectionsRateLimitRateLimiter[];
}

export interface GetVirtualserviceConnectionsRateLimitAction {
    files: outputs.GetVirtualserviceConnectionsRateLimitActionFile[];
    redirects: outputs.GetVirtualserviceConnectionsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetVirtualserviceConnectionsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetVirtualserviceConnectionsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetVirtualserviceConnectionsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetVirtualserviceConnectionsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetVirtualserviceConnectionsRateLimitActionRedirectHost {
    tokens: outputs.GetVirtualserviceConnectionsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetVirtualserviceConnectionsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetVirtualserviceConnectionsRateLimitActionRedirectPath {
    tokens: outputs.GetVirtualserviceConnectionsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetVirtualserviceConnectionsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetVirtualserviceConnectionsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetVirtualserviceContentRewrite {
    rewritableContentRef: string;
    rspRewriteRules: outputs.GetVirtualserviceContentRewriteRspRewriteRule[];
}

export interface GetVirtualserviceContentRewriteRspRewriteRule {
    enable: string;
    index: string;
    name: string;
    pairs: outputs.GetVirtualserviceContentRewriteRspRewriteRulePair[];
}

export interface GetVirtualserviceContentRewriteRspRewriteRulePair {
    replacementStrings: outputs.GetVirtualserviceContentRewriteRspRewriteRulePairReplacementString[];
    searchStrings: outputs.GetVirtualserviceContentRewriteRspRewriteRulePairSearchString[];
}

export interface GetVirtualserviceContentRewriteRspRewriteRulePairReplacementString {
    type: string;
    val: string;
}

export interface GetVirtualserviceContentRewriteRspRewriteRulePairSearchString {
    type: string;
    val: string;
}

export interface GetVirtualserviceDnsInfo {
    algorithm: string;
    cnames: outputs.GetVirtualserviceDnsInfoCname[];
    fqdn: string;
    metadata: string;
    numRecordsInResponse: string;
    ttl: string;
    type: string;
}

export interface GetVirtualserviceDnsInfoCname {
    cname: string;
}

export interface GetVirtualserviceDnsPolicy {
    dnsPolicyRef: string;
    index: string;
}

export interface GetVirtualserviceHttpPolicy {
    httpPolicySetRef: string;
    index: string;
}

export interface GetVirtualserviceJwtConfig {
    audience: string;
    jwtLocation: string;
    jwtName: string;
}

export interface GetVirtualserviceL4Policy {
    index: string;
    l4PolicySetRef: string;
}

export interface GetVirtualserviceLdapVsConfig {
    realm: string;
    seAuthLdapBindTimeout: string;
    seAuthLdapCacheSize: string;
    seAuthLdapConnectTimeout: string;
    seAuthLdapConnsPerServer: string;
    seAuthLdapReconnectTimeout: string;
    seAuthLdapRequestTimeout: string;
    seAuthLdapServersFailoverOnly: string;
}

export interface GetVirtualserviceMarker {
    key: string;
    values: string[];
}

export interface GetVirtualserviceOauthVsConfig {
    cookieName: string;
    cookieTimeout: string;
    keys: outputs.GetVirtualserviceOauthVsConfigKey[];
    logoutUri: string;
    oauthSettings: outputs.GetVirtualserviceOauthVsConfigOauthSetting[];
    postLogoutRedirectUri: string;
    redirectUri: string;
}

export interface GetVirtualserviceOauthVsConfigKey {
    aesKey: string;
    hmacKey: string;
    name: string;
}

export interface GetVirtualserviceOauthVsConfigOauthSetting {
    appSettings: outputs.GetVirtualserviceOauthVsConfigOauthSettingAppSetting[];
    authProfileRef: string;
    resourceServers: outputs.GetVirtualserviceOauthVsConfigOauthSettingResourceServer[];
}

export interface GetVirtualserviceOauthVsConfigOauthSettingAppSetting {
    clientId: string;
    clientSecret: string;
    oidcConfigs: outputs.GetVirtualserviceOauthVsConfigOauthSettingAppSettingOidcConfig[];
    scopes: string[];
}

export interface GetVirtualserviceOauthVsConfigOauthSettingAppSettingOidcConfig {
    oidcEnable: string;
    profile: string;
    userinfo: string;
}

export interface GetVirtualserviceOauthVsConfigOauthSettingResourceServer {
    accessType: string;
    introspectionDataTimeout: string;
    jwtParams: outputs.GetVirtualserviceOauthVsConfigOauthSettingResourceServerJwtParam[];
    opaqueTokenParams: outputs.GetVirtualserviceOauthVsConfigOauthSettingResourceServerOpaqueTokenParam[];
}

export interface GetVirtualserviceOauthVsConfigOauthSettingResourceServerJwtParam {
    audience: string;
}

export interface GetVirtualserviceOauthVsConfigOauthSettingResourceServerOpaqueTokenParam {
    serverId: string;
    serverSecret: string;
}

export interface GetVirtualservicePerformanceLimit {
    maxConcurrentConnections: string;
    maxThroughput: string;
}

export interface GetVirtualserviceRequestsRateLimit {
    actions: outputs.GetVirtualserviceRequestsRateLimitAction[];
    explicitTracking: string;
    fineGrain: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters: outputs.GetVirtualserviceRequestsRateLimitRateLimiter[];
}

export interface GetVirtualserviceRequestsRateLimitAction {
    files: outputs.GetVirtualserviceRequestsRateLimitActionFile[];
    redirects: outputs.GetVirtualserviceRequestsRateLimitActionRedirect[];
    statusCode: string;
    type: string;
}

export interface GetVirtualserviceRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface GetVirtualserviceRequestsRateLimitActionRedirect {
    addString: string;
    hosts: outputs.GetVirtualserviceRequestsRateLimitActionRedirectHost[];
    keepQuery: string;
    paths: outputs.GetVirtualserviceRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode: string;
}

export interface GetVirtualserviceRequestsRateLimitActionRedirectHost {
    tokens: outputs.GetVirtualserviceRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface GetVirtualserviceRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetVirtualserviceRequestsRateLimitActionRedirectPath {
    tokens: outputs.GetVirtualserviceRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface GetVirtualserviceRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface GetVirtualserviceRequestsRateLimitRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetVirtualserviceSamlSpConfig {
    acsIndex: string;
    authnReqAcsType: string;
    cookieName: string;
    cookieTimeout: string;
    entityId: string;
    keys: outputs.GetVirtualserviceSamlSpConfigKey[];
    signingSslKeyAndCertificateRef: string;
    singleSignonUrl: string;
    spMetadata: string;
    useIdpSessionTimeout: string;
}

export interface GetVirtualserviceSamlSpConfigKey {
    aesKey: string;
    hmacKey: string;
    name: string;
}

export interface GetVirtualserviceService {
    enableHttp2: string;
    enableSsl: string;
    horizonInternalPorts: string;
    isActiveFtpDataPort: string;
    overrideApplicationProfileRef: string;
    overrideNetworkProfileRef: string;
    port: string;
    portRangeEnd: string;
}

export interface GetVirtualserviceServicePoolSelect {
    servicePoolGroupRef: string;
    servicePoolRef: string;
    servicePort: string;
    servicePortRangeEnd: string;
    serviceProtocol: string;
}

export interface GetVirtualserviceSidebandProfile {
    ips: outputs.GetVirtualserviceSidebandProfileIp[];
    sidebandMaxRequestBodySize: string;
}

export interface GetVirtualserviceSidebandProfileIp {
    addr: string;
    type: string;
}

export interface GetVirtualserviceSnatIp {
    addr: string;
    type: string;
}

export interface GetVirtualserviceSnatIp6Address {
    addr: string;
    type: string;
}

export interface GetVirtualserviceSslProfileSelector {
    clientIpLists: outputs.GetVirtualserviceSslProfileSelectorClientIpList[];
    sslProfileRef: string;
}

export interface GetVirtualserviceSslProfileSelectorClientIpList {
    addrs: outputs.GetVirtualserviceSslProfileSelectorClientIpListAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetVirtualserviceSslProfileSelectorClientIpListPrefix[];
    ranges: outputs.GetVirtualserviceSslProfileSelectorClientIpListRange[];
}

export interface GetVirtualserviceSslProfileSelectorClientIpListAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceSslProfileSelectorClientIpListPrefix {
    ipAddrs: outputs.GetVirtualserviceSslProfileSelectorClientIpListPrefixIpAddr[];
    mask: string;
}

export interface GetVirtualserviceSslProfileSelectorClientIpListPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceSslProfileSelectorClientIpListRange {
    begins: outputs.GetVirtualserviceSslProfileSelectorClientIpListRangeBegin[];
    ends: outputs.GetVirtualserviceSslProfileSelectorClientIpListRangeEnd[];
}

export interface GetVirtualserviceSslProfileSelectorClientIpListRangeBegin {
    addr: string;
    type: string;
}

export interface GetVirtualserviceSslProfileSelectorClientIpListRangeEnd {
    addr: string;
    type: string;
}

export interface GetVirtualserviceStaticDnsRecord {
    algorithm: string;
    cnames: outputs.GetVirtualserviceStaticDnsRecordCname[];
    delegated: string;
    description: string;
    fqdns: string[];
    ip6Addresses: outputs.GetVirtualserviceStaticDnsRecordIp6Address[];
    ipAddresses: outputs.GetVirtualserviceStaticDnsRecordIpAddress[];
    metadata: string;
    mxRecords: outputs.GetVirtualserviceStaticDnsRecordMxRecord[];
    ns: outputs.GetVirtualserviceStaticDnsRecordN[];
    numRecordsInResponse: string;
    serviceLocators: outputs.GetVirtualserviceStaticDnsRecordServiceLocator[];
    ttl: string;
    txtRecords: outputs.GetVirtualserviceStaticDnsRecordTxtRecord[];
    type: string;
    wildcardMatch: string;
}

export interface GetVirtualserviceStaticDnsRecordCname {
    cname: string;
}

export interface GetVirtualserviceStaticDnsRecordIp6Address {
    ip6Addresses: outputs.GetVirtualserviceStaticDnsRecordIp6AddressIp6Address[];
}

export interface GetVirtualserviceStaticDnsRecordIp6AddressIp6Address {
    addr: string;
    type: string;
}

export interface GetVirtualserviceStaticDnsRecordIpAddress {
    ipAddresses: outputs.GetVirtualserviceStaticDnsRecordIpAddressIpAddress[];
}

export interface GetVirtualserviceStaticDnsRecordIpAddressIpAddress {
    addr: string;
    type: string;
}

export interface GetVirtualserviceStaticDnsRecordMxRecord {
    host: string;
    priority: string;
}

export interface GetVirtualserviceStaticDnsRecordN {
    ip6Addresses: outputs.GetVirtualserviceStaticDnsRecordNIp6Address[];
    ipAddresses: outputs.GetVirtualserviceStaticDnsRecordNIpAddress[];
    nsname: string;
}

export interface GetVirtualserviceStaticDnsRecordNIp6Address {
    addr: string;
    type: string;
}

export interface GetVirtualserviceStaticDnsRecordNIpAddress {
    addr: string;
    type: string;
}

export interface GetVirtualserviceStaticDnsRecordServiceLocator {
    port: string;
    priority: string;
    target: string;
    weight: string;
}

export interface GetVirtualserviceStaticDnsRecordTxtRecord {
    textStr: string;
}

export interface GetVirtualserviceTopologyPolicy {
    dnsPolicyRef: string;
    index: string;
}

export interface GetVirtualserviceVhMatch {
    host: string;
    rules: outputs.GetVirtualserviceVhMatchRule[];
}

export interface GetVirtualserviceVhMatchRule {
    matches: outputs.GetVirtualserviceVhMatchRuleMatch[];
    name: string;
}

export interface GetVirtualserviceVhMatchRuleMatch {
    botDetectionResults: outputs.GetVirtualserviceVhMatchRuleMatchBotDetectionResult[];
    clientIps: outputs.GetVirtualserviceVhMatchRuleMatchClientIp[];
    cookies: outputs.GetVirtualserviceVhMatchRuleMatchCookie[];
    geoMatches: outputs.GetVirtualserviceVhMatchRuleMatchGeoMatch[];
    hdrs: outputs.GetVirtualserviceVhMatchRuleMatchHdr[];
    hostHdrs: outputs.GetVirtualserviceVhMatchRuleMatchHostHdr[];
    ipReputationTypes: outputs.GetVirtualserviceVhMatchRuleMatchIpReputationType[];
    methods: outputs.GetVirtualserviceVhMatchRuleMatchMethod[];
    paths: outputs.GetVirtualserviceVhMatchRuleMatchPath[];
    protocols: outputs.GetVirtualserviceVhMatchRuleMatchProtocol[];
    queries: outputs.GetVirtualserviceVhMatchRuleMatchQuery[];
    sourceIps: outputs.GetVirtualserviceVhMatchRuleMatchSourceIp[];
    tlsFingerprintMatches: outputs.GetVirtualserviceVhMatchRuleMatchTlsFingerprintMatch[];
    versions: outputs.GetVirtualserviceVhMatchRuleMatchVersion[];
    vsPorts: outputs.GetVirtualserviceVhMatchRuleMatchVsPort[];
}

export interface GetVirtualserviceVhMatchRuleMatchBotDetectionResult {
    classifications: outputs.GetVirtualserviceVhMatchRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface GetVirtualserviceVhMatchRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface GetVirtualserviceVhMatchRuleMatchClientIp {
    addrs: outputs.GetVirtualserviceVhMatchRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetVirtualserviceVhMatchRuleMatchClientIpPrefix[];
    ranges: outputs.GetVirtualserviceVhMatchRuleMatchClientIpRange[];
}

export interface GetVirtualserviceVhMatchRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetVirtualserviceVhMatchRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetVirtualserviceVhMatchRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchClientIpRange {
    begins: outputs.GetVirtualserviceVhMatchRuleMatchClientIpRangeBegin[];
    ends: outputs.GetVirtualserviceVhMatchRuleMatchClientIpRangeEnd[];
}

export interface GetVirtualserviceVhMatchRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchCookie {
    matchCase: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface GetVirtualserviceVhMatchRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface GetVirtualserviceVhMatchRuleMatchQuery {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchSourceIp {
    addrs: outputs.GetVirtualserviceVhMatchRuleMatchSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetVirtualserviceVhMatchRuleMatchSourceIpPrefix[];
    ranges: outputs.GetVirtualserviceVhMatchRuleMatchSourceIpRange[];
}

export interface GetVirtualserviceVhMatchRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchSourceIpPrefix {
    ipAddrs: outputs.GetVirtualserviceVhMatchRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetVirtualserviceVhMatchRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchSourceIpRange {
    begins: outputs.GetVirtualserviceVhMatchRuleMatchSourceIpRangeBegin[];
    ends: outputs.GetVirtualserviceVhMatchRuleMatchSourceIpRangeEnd[];
}

export interface GetVirtualserviceVhMatchRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVhMatchRuleMatchTlsFingerprintMatch {
    fingerprints: string[];
    matchOperation: string;
    stringGroupRefs: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface GetVirtualserviceVhMatchRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetVirtualserviceVip {
    autoAllocateFloatingIp: string;
    autoAllocateIp: string;
    autoAllocateIpType: string;
    availabilityZone: string;
    aviAllocatedFip: string;
    aviAllocatedVip: string;
    discoveredNetworks: outputs.GetVirtualserviceVipDiscoveredNetwork[];
    enabled: string;
    floatingIp6s: outputs.GetVirtualserviceVipFloatingIp6[];
    floatingIps: outputs.GetVirtualserviceVipFloatingIp[];
    floatingSubnet6Uuid: string;
    floatingSubnetUuid: string;
    ip6Addresses: outputs.GetVirtualserviceVipIp6Address[];
    ipAddresses: outputs.GetVirtualserviceVipIpAddress[];
    ipamNetworkSubnets: outputs.GetVirtualserviceVipIpamNetworkSubnet[];
    networkRef: string;
    placementNetworks: outputs.GetVirtualserviceVipPlacementNetwork[];
    portUuid: string;
    prefixLength: string;
    subnet6Uuid: string;
    subnet6s: outputs.GetVirtualserviceVipSubnet6[];
    subnetUuid: string;
    subnets: outputs.GetVirtualserviceVipSubnet[];
    vipId: string;
}

export interface GetVirtualserviceVipDiscoveredNetwork {
    networkRef: string;
    subnet6s: outputs.GetVirtualserviceVipDiscoveredNetworkSubnet6[];
    subnets: outputs.GetVirtualserviceVipDiscoveredNetworkSubnet[];
}

export interface GetVirtualserviceVipDiscoveredNetworkSubnet {
    ipAddrs: outputs.GetVirtualserviceVipDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.GetVirtualserviceVipDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipFloatingIp {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipFloatingIp6 {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipIp6Address {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipIpAddress {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipIpamNetworkSubnet {
    networkRef: string;
    subnet6Uuid: string;
    subnet6s: outputs.GetVirtualserviceVipIpamNetworkSubnetSubnet6[];
    subnetUuid: string;
    subnets: outputs.GetVirtualserviceVipIpamNetworkSubnetSubnet[];
}

export interface GetVirtualserviceVipIpamNetworkSubnetSubnet {
    ipAddrs: outputs.GetVirtualserviceVipIpamNetworkSubnetSubnetIpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipIpamNetworkSubnetSubnet6 {
    ipAddrs: outputs.GetVirtualserviceVipIpamNetworkSubnetSubnet6IpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipIpamNetworkSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipIpamNetworkSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipPlacementNetwork {
    networkRef: string;
    subnet6s: outputs.GetVirtualserviceVipPlacementNetworkSubnet6[];
    subnets: outputs.GetVirtualserviceVipPlacementNetworkSubnet[];
}

export interface GetVirtualserviceVipPlacementNetworkSubnet {
    ipAddrs: outputs.GetVirtualserviceVipPlacementNetworkSubnetIpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipPlacementNetworkSubnet6 {
    ipAddrs: outputs.GetVirtualserviceVipPlacementNetworkSubnet6IpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipPlacementNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipPlacementNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipSubnet {
    ipAddrs: outputs.GetVirtualserviceVipSubnetIpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipSubnet6 {
    ipAddrs: outputs.GetVirtualserviceVipSubnet6IpAddr[];
    mask: string;
}

export interface GetVirtualserviceVipSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVipSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVirtualserviceVsDatascript {
    index: string;
    vsDatascriptSetRef: string;
}

export interface GetVrfcontextAttr {
    key: string;
    value: string;
}

export interface GetVrfcontextBfdProfile {
    minrx: string;
    mintx: string;
    multi: string;
}

export interface GetVrfcontextBgpProfile {
    communities: string[];
    holdTime: string;
    ibgp: string;
    ipCommunities: outputs.GetVrfcontextBgpProfileIpCommunity[];
    keepaliveInterval: string;
    localAs: string;
    localPreference: string;
    numAsPathPrepend: string;
    peers: outputs.GetVrfcontextBgpProfilePeer[];
    routingOptions: outputs.GetVrfcontextBgpProfileRoutingOption[];
    sendCommunity: string;
    shutdown: string;
}

export interface GetVrfcontextBgpProfileIpCommunity {
    communities: string[];
    ipBegins: outputs.GetVrfcontextBgpProfileIpCommunityIpBegin[];
    ipEnds: outputs.GetVrfcontextBgpProfileIpCommunityIpEnd[];
}

export interface GetVrfcontextBgpProfileIpCommunityIpBegin {
    addr: string;
    type: string;
}

export interface GetVrfcontextBgpProfileIpCommunityIpEnd {
    addr: string;
    type: string;
}

export interface GetVrfcontextBgpProfilePeer {
    advertiseSnatIp: string;
    advertiseVip: string;
    advertisementInterval: string;
    bfd: string;
    connectTimer: string;
    ebgpMultihop: string;
    holdTime: string;
    ibgpLocalAsOverride: string;
    keepaliveInterval: string;
    label: string;
    localAs: string;
    md5Secret: string;
    networkRef: string;
    peerIp6s: outputs.GetVrfcontextBgpProfilePeerPeerIp6[];
    peerIps: outputs.GetVrfcontextBgpProfilePeerPeerIp[];
    remoteAs: string;
    shutdown: string;
    subnet6s: outputs.GetVrfcontextBgpProfilePeerSubnet6[];
    subnets: outputs.GetVrfcontextBgpProfilePeerSubnet[];
}

export interface GetVrfcontextBgpProfilePeerPeerIp {
    addr: string;
    type: string;
}

export interface GetVrfcontextBgpProfilePeerPeerIp6 {
    addr: string;
    type: string;
}

export interface GetVrfcontextBgpProfilePeerSubnet {
    ipAddrs: outputs.GetVrfcontextBgpProfilePeerSubnetIpAddr[];
    mask: string;
}

export interface GetVrfcontextBgpProfilePeerSubnet6 {
    ipAddrs: outputs.GetVrfcontextBgpProfilePeerSubnet6IpAddr[];
    mask: string;
}

export interface GetVrfcontextBgpProfilePeerSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVrfcontextBgpProfilePeerSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVrfcontextBgpProfileRoutingOption {
    advertiseDefaultRoute: string;
    advertiseLearnedRoutes: string;
    label: string;
    learnOnlyDefaultRoute: string;
    learnRoutes: string;
    maxLearnLimit: string;
}

export interface GetVrfcontextConfigpbAttribute {
    version: string;
}

export interface GetVrfcontextDebugvrfcontext {
    commandBufferInterval: string;
    commandBufferSize: string;
    flags: outputs.GetVrfcontextDebugvrfcontextFlag[];
}

export interface GetVrfcontextDebugvrfcontextFlag {
    flag: string;
}

export interface GetVrfcontextGatewayMon {
    gatewayIps: outputs.GetVrfcontextGatewayMonGatewayIp[];
    gatewayMonitorFailThreshold: string;
    gatewayMonitorInterval: string;
    gatewayMonitorSuccessThreshold: string;
    subnets: outputs.GetVrfcontextGatewayMonSubnet[];
}

export interface GetVrfcontextGatewayMonGatewayIp {
    addr: string;
    type: string;
}

export interface GetVrfcontextGatewayMonSubnet {
    ipAddrs: outputs.GetVrfcontextGatewayMonSubnetIpAddr[];
    mask: string;
}

export interface GetVrfcontextGatewayMonSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVrfcontextInternalGatewayMonitor {
    disableGatewayMonitor: string;
    gatewayMonitorFailureThreshold: string;
    gatewayMonitorInterval: string;
    gatewayMonitorSuccessThreshold: string;
}

export interface GetVrfcontextMarker {
    key: string;
    values: string[];
}

export interface GetVrfcontextStaticRoute {
    disableGatewayMonitor: string;
    ifName: string;
    labels: outputs.GetVrfcontextStaticRouteLabel[];
    nextHops: outputs.GetVrfcontextStaticRouteNextHop[];
    prefixes: outputs.GetVrfcontextStaticRoutePrefix[];
    routeId: string;
}

export interface GetVrfcontextStaticRouteLabel {
    key: string;
    value: string;
}

export interface GetVrfcontextStaticRouteNextHop {
    addr: string;
    type: string;
}

export interface GetVrfcontextStaticRoutePrefix {
    ipAddrs: outputs.GetVrfcontextStaticRoutePrefixIpAddr[];
    mask: string;
}

export interface GetVrfcontextStaticRoutePrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetVsdatascriptsetConfigpbAttribute {
    version: string;
}

export interface GetVsdatascriptsetDatascript {
    evt: string;
    script: string;
}

export interface GetVsdatascriptsetMarker {
    key: string;
    values: string[];
}

export interface GetVsdatascriptsetRateLimiter {
    burstSz: string;
    count: string;
    name: string;
    period: string;
}

export interface GetVsgsConfigpbAttribute {
    version: string;
}

export interface GetVsvipConfigpbAttribute {
    version: string;
}

export interface GetVsvipDnsInfo {
    algorithm: string;
    cnames: outputs.GetVsvipDnsInfoCname[];
    fqdn: string;
    metadata: string;
    numRecordsInResponse: string;
    ttl: string;
    type: string;
}

export interface GetVsvipDnsInfoCname {
    cname: string;
}

export interface GetVsvipIpamSelector {
    labels: outputs.GetVsvipIpamSelectorLabel[];
    type: string;
}

export interface GetVsvipIpamSelectorLabel {
    key: string;
    value: string;
}

export interface GetVsvipMarker {
    key: string;
    values: string[];
}

export interface GetVsvipVip {
    autoAllocateFloatingIp: string;
    autoAllocateIp: string;
    autoAllocateIpType: string;
    availabilityZone: string;
    aviAllocatedFip: string;
    aviAllocatedVip: string;
    discoveredNetworks: outputs.GetVsvipVipDiscoveredNetwork[];
    enabled: string;
    floatingIp6s: outputs.GetVsvipVipFloatingIp6[];
    floatingIps: outputs.GetVsvipVipFloatingIp[];
    floatingSubnet6Uuid: string;
    floatingSubnetUuid: string;
    ip6Addresses: outputs.GetVsvipVipIp6Address[];
    ipAddresses: outputs.GetVsvipVipIpAddress[];
    ipamNetworkSubnets: outputs.GetVsvipVipIpamNetworkSubnet[];
    networkRef: string;
    placementNetworks: outputs.GetVsvipVipPlacementNetwork[];
    portUuid: string;
    prefixLength: string;
    subnet6Uuid: string;
    subnet6s: outputs.GetVsvipVipSubnet6[];
    subnetUuid: string;
    subnets: outputs.GetVsvipVipSubnet[];
    vipId: string;
}

export interface GetVsvipVipDiscoveredNetwork {
    networkRef: string;
    subnet6s: outputs.GetVsvipVipDiscoveredNetworkSubnet6[];
    subnets: outputs.GetVsvipVipDiscoveredNetworkSubnet[];
}

export interface GetVsvipVipDiscoveredNetworkSubnet {
    ipAddrs: outputs.GetVsvipVipDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface GetVsvipVipDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.GetVsvipVipDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface GetVsvipVipDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVsvipVipDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVsvipVipFloatingIp {
    addr: string;
    type: string;
}

export interface GetVsvipVipFloatingIp6 {
    addr: string;
    type: string;
}

export interface GetVsvipVipIp6Address {
    addr: string;
    type: string;
}

export interface GetVsvipVipIpAddress {
    addr: string;
    type: string;
}

export interface GetVsvipVipIpamNetworkSubnet {
    networkRef: string;
    subnet6Uuid: string;
    subnet6s: outputs.GetVsvipVipIpamNetworkSubnetSubnet6[];
    subnetUuid: string;
    subnets: outputs.GetVsvipVipIpamNetworkSubnetSubnet[];
}

export interface GetVsvipVipIpamNetworkSubnetSubnet {
    ipAddrs: outputs.GetVsvipVipIpamNetworkSubnetSubnetIpAddr[];
    mask: string;
}

export interface GetVsvipVipIpamNetworkSubnetSubnet6 {
    ipAddrs: outputs.GetVsvipVipIpamNetworkSubnetSubnet6IpAddr[];
    mask: string;
}

export interface GetVsvipVipIpamNetworkSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVsvipVipIpamNetworkSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVsvipVipPlacementNetwork {
    networkRef: string;
    subnet6s: outputs.GetVsvipVipPlacementNetworkSubnet6[];
    subnets: outputs.GetVsvipVipPlacementNetworkSubnet[];
}

export interface GetVsvipVipPlacementNetworkSubnet {
    ipAddrs: outputs.GetVsvipVipPlacementNetworkSubnetIpAddr[];
    mask: string;
}

export interface GetVsvipVipPlacementNetworkSubnet6 {
    ipAddrs: outputs.GetVsvipVipPlacementNetworkSubnet6IpAddr[];
    mask: string;
}

export interface GetVsvipVipPlacementNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVsvipVipPlacementNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetVsvipVipSubnet {
    ipAddrs: outputs.GetVsvipVipSubnetIpAddr[];
    mask: string;
}

export interface GetVsvipVipSubnet6 {
    ipAddrs: outputs.GetVsvipVipSubnet6IpAddr[];
    mask: string;
}

export interface GetVsvipVipSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface GetVsvipVipSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafapplicationsignatureproviderAvailableApplication {
    application: string;
    lastChangedRulesetVersion: string;
    numberOfRules: string;
}

export interface GetWafapplicationsignatureproviderConfigpbAttribute {
    version: string;
}

export interface GetWafapplicationsignatureproviderServiceStatus {
    error: string;
    lastSuccessfulUpdateChecks: outputs.GetWafapplicationsignatureproviderServiceStatusLastSuccessfulUpdateCheck[];
    upstreamSyncTimestamps: outputs.GetWafapplicationsignatureproviderServiceStatusUpstreamSyncTimestamp[];
}

export interface GetWafapplicationsignatureproviderServiceStatusLastSuccessfulUpdateCheck {
    secs: string;
    usecs: string;
}

export interface GetWafapplicationsignatureproviderServiceStatusUpstreamSyncTimestamp {
    secs: string;
    usecs: string;
}

export interface GetWafapplicationsignatureproviderSignature {
    enable: string;
    excludeLists: outputs.GetWafapplicationsignatureproviderSignatureExcludeList[];
    index: string;
    isSensitive: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags: string[];
}

export interface GetWafapplicationsignatureproviderSignatureExcludeList {
    clientSubnets: outputs.GetWafapplicationsignatureproviderSignatureExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafapplicationsignatureproviderSignatureExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafapplicationsignatureproviderSignatureExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafapplicationsignatureproviderSignatureExcludeListClientSubnet {
    ipAddrs: outputs.GetWafapplicationsignatureproviderSignatureExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafapplicationsignatureproviderSignatureExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafapplicationsignatureproviderSignatureExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafapplicationsignatureproviderSignatureExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafcrsConfigpbAttribute {
    version: string;
}

export interface GetWafcrsFile {
    data: string;
    name: string;
    type: string;
}

export interface GetWafcrsGroup {
    enable: string;
    excludeLists: outputs.GetWafcrsGroupExcludeList[];
    index: string;
    name: string;
    rules: outputs.GetWafcrsGroupRule[];
}

export interface GetWafcrsGroupExcludeList {
    clientSubnets: outputs.GetWafcrsGroupExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafcrsGroupExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafcrsGroupExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafcrsGroupExcludeListClientSubnet {
    ipAddrs: outputs.GetWafcrsGroupExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafcrsGroupExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafcrsGroupExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafcrsGroupExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafcrsGroupRule {
    enable: string;
    excludeLists: outputs.GetWafcrsGroupRuleExcludeList[];
    index: string;
    isSensitive: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags: string[];
}

export interface GetWafcrsGroupRuleExcludeList {
    clientSubnets: outputs.GetWafcrsGroupRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafcrsGroupRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafcrsGroupRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafcrsGroupRuleExcludeListClientSubnet {
    ipAddrs: outputs.GetWafcrsGroupRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafcrsGroupRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafcrsGroupRuleExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafcrsGroupRuleExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafcrsMarker {
    key: string;
    values: string[];
}

export interface GetWafpolicyAllowlist {
    rules: outputs.GetWafpolicyAllowlistRule[];
}

export interface GetWafpolicyAllowlistRule {
    actions: string[];
    description: string;
    enable: string;
    index: string;
    matches: outputs.GetWafpolicyAllowlistRuleMatch[];
    name: string;
    samplingPercent: string;
}

export interface GetWafpolicyAllowlistRuleMatch {
    botDetectionResults: outputs.GetWafpolicyAllowlistRuleMatchBotDetectionResult[];
    clientIps: outputs.GetWafpolicyAllowlistRuleMatchClientIp[];
    cookies: outputs.GetWafpolicyAllowlistRuleMatchCookie[];
    geoMatches: outputs.GetWafpolicyAllowlistRuleMatchGeoMatch[];
    hdrs: outputs.GetWafpolicyAllowlistRuleMatchHdr[];
    hostHdrs: outputs.GetWafpolicyAllowlistRuleMatchHostHdr[];
    ipReputationTypes: outputs.GetWafpolicyAllowlistRuleMatchIpReputationType[];
    methods: outputs.GetWafpolicyAllowlistRuleMatchMethod[];
    paths: outputs.GetWafpolicyAllowlistRuleMatchPath[];
    protocols: outputs.GetWafpolicyAllowlistRuleMatchProtocol[];
    queries: outputs.GetWafpolicyAllowlistRuleMatchQuery[];
    sourceIps: outputs.GetWafpolicyAllowlistRuleMatchSourceIp[];
    tlsFingerprintMatches: outputs.GetWafpolicyAllowlistRuleMatchTlsFingerprintMatch[];
    versions: outputs.GetWafpolicyAllowlistRuleMatchVersion[];
    vsPorts: outputs.GetWafpolicyAllowlistRuleMatchVsPort[];
}

export interface GetWafpolicyAllowlistRuleMatchBotDetectionResult {
    classifications: outputs.GetWafpolicyAllowlistRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface GetWafpolicyAllowlistRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface GetWafpolicyAllowlistRuleMatchClientIp {
    addrs: outputs.GetWafpolicyAllowlistRuleMatchClientIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetWafpolicyAllowlistRuleMatchClientIpPrefix[];
    ranges: outputs.GetWafpolicyAllowlistRuleMatchClientIpRange[];
}

export interface GetWafpolicyAllowlistRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchClientIpPrefix {
    ipAddrs: outputs.GetWafpolicyAllowlistRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface GetWafpolicyAllowlistRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchClientIpRange {
    begins: outputs.GetWafpolicyAllowlistRuleMatchClientIpRangeBegin[];
    ends: outputs.GetWafpolicyAllowlistRuleMatchClientIpRangeEnd[];
}

export interface GetWafpolicyAllowlistRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchCookie {
    matchCase: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface GetWafpolicyAllowlistRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface GetWafpolicyAllowlistRuleMatchHdr {
    hdr: string;
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetWafpolicyAllowlistRuleMatchHostHdr {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetWafpolicyAllowlistRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface GetWafpolicyAllowlistRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetWafpolicyAllowlistRuleMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetWafpolicyAllowlistRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface GetWafpolicyAllowlistRuleMatchQuery {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetWafpolicyAllowlistRuleMatchSourceIp {
    addrs: outputs.GetWafpolicyAllowlistRuleMatchSourceIpAddr[];
    groupRefs: string[];
    matchCriteria: string;
    prefixes: outputs.GetWafpolicyAllowlistRuleMatchSourceIpPrefix[];
    ranges: outputs.GetWafpolicyAllowlistRuleMatchSourceIpRange[];
}

export interface GetWafpolicyAllowlistRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchSourceIpPrefix {
    ipAddrs: outputs.GetWafpolicyAllowlistRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface GetWafpolicyAllowlistRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchSourceIpRange {
    begins: outputs.GetWafpolicyAllowlistRuleMatchSourceIpRangeBegin[];
    ends: outputs.GetWafpolicyAllowlistRuleMatchSourceIpRangeEnd[];
}

export interface GetWafpolicyAllowlistRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface GetWafpolicyAllowlistRuleMatchTlsFingerprintMatch {
    fingerprints: string[];
    matchOperation: string;
    stringGroupRefs: string[];
}

export interface GetWafpolicyAllowlistRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface GetWafpolicyAllowlistRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface GetWafpolicyApplicationSignature {
    providerRef: string;
    resolvedRules: outputs.GetWafpolicyApplicationSignatureResolvedRule[];
    ruleOverrides: outputs.GetWafpolicyApplicationSignatureRuleOverride[];
    rulesetVersion: string;
    selectedApplications: string[];
}

export interface GetWafpolicyApplicationSignatureResolvedRule {
    enable: string;
    excludeLists: outputs.GetWafpolicyApplicationSignatureResolvedRuleExcludeList[];
    index: string;
    isSensitive: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags: string[];
}

export interface GetWafpolicyApplicationSignatureResolvedRuleExcludeList {
    clientSubnets: outputs.GetWafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyApplicationSignatureResolvedRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyApplicationSignatureResolvedRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyApplicationSignatureResolvedRuleExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyApplicationSignatureResolvedRuleExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyApplicationSignatureRuleOverride {
    enable: string;
    excludeLists: outputs.GetWafpolicyApplicationSignatureRuleOverrideExcludeList[];
    mode: string;
    ruleId: string;
}

export interface GetWafpolicyApplicationSignatureRuleOverrideExcludeList {
    clientSubnets: outputs.GetWafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyApplicationSignatureRuleOverrideExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyApplicationSignatureRuleOverrideExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyApplicationSignatureRuleOverrideExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyApplicationSignatureRuleOverrideExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyConfidenceOverride {
    confidHighValue: string;
    confidLowValue: string;
    confidProbableValue: string;
    confidVeryHighValue: string;
}

export interface GetWafpolicyConfigpbAttribute {
    version: string;
}

export interface GetWafpolicyCrsOverride {
    enable: string;
    excludeLists: outputs.GetWafpolicyCrsOverrideExcludeList[];
    mode: string;
    name: string;
    ruleOverrides: outputs.GetWafpolicyCrsOverrideRuleOverride[];
}

export interface GetWafpolicyCrsOverrideExcludeList {
    clientSubnets: outputs.GetWafpolicyCrsOverrideExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyCrsOverrideExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyCrsOverrideExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyCrsOverrideExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyCrsOverrideExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyCrsOverrideExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyCrsOverrideExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyCrsOverrideExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyCrsOverrideRuleOverride {
    enable: string;
    excludeLists: outputs.GetWafpolicyCrsOverrideRuleOverrideExcludeList[];
    mode: string;
    ruleId: string;
}

export interface GetWafpolicyCrsOverrideRuleOverrideExcludeList {
    clientSubnets: outputs.GetWafpolicyCrsOverrideRuleOverrideExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyCrsOverrideRuleOverrideExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyCrsOverrideRuleOverrideExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyCrsOverrideRuleOverrideExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyCrsOverrideRuleOverrideExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyCrsOverrideRuleOverrideExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyCrsOverrideRuleOverrideExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyCrsOverrideRuleOverrideExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyLearningParam {
    enableLearnFromBots: string;
    enablePerUriLearning: string;
    learnFromAuthenticatedClientsOnly: string;
    learnFromBots: outputs.GetWafpolicyLearningParamLearnFromBot[];
    maxParams: string;
    maxUris: string;
    minHitsToLearn: string;
    samplingPercent: string;
    trustedIpgroupRef: string;
    updateInterval: string;
}

export interface GetWafpolicyLearningParamLearnFromBot {
    classifications: outputs.GetWafpolicyLearningParamLearnFromBotClassification[];
    matchOperation: string;
}

export interface GetWafpolicyLearningParamLearnFromBotClassification {
    type: string;
    userDefinedType: string;
}

export interface GetWafpolicyMarker {
    key: string;
    values: string[];
}

export interface GetWafpolicyPositiveSecurityModel {
    groupRefs: string[];
}

export interface GetWafpolicyPostCrsGroup {
    enable: string;
    excludeLists: outputs.GetWafpolicyPostCrsGroupExcludeList[];
    index: string;
    name: string;
    rules: outputs.GetWafpolicyPostCrsGroupRule[];
}

export interface GetWafpolicyPostCrsGroupExcludeList {
    clientSubnets: outputs.GetWafpolicyPostCrsGroupExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyPostCrsGroupExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyPostCrsGroupExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyPostCrsGroupExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyPostCrsGroupExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyPostCrsGroupExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyPostCrsGroupExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyPostCrsGroupExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyPostCrsGroupRule {
    enable: string;
    excludeLists: outputs.GetWafpolicyPostCrsGroupRuleExcludeList[];
    index: string;
    isSensitive: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags: string[];
}

export interface GetWafpolicyPostCrsGroupRuleExcludeList {
    clientSubnets: outputs.GetWafpolicyPostCrsGroupRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyPostCrsGroupRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyPostCrsGroupRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyPostCrsGroupRuleExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyPostCrsGroupRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyPostCrsGroupRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyPostCrsGroupRuleExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyPostCrsGroupRuleExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyPreCrsGroup {
    enable: string;
    excludeLists: outputs.GetWafpolicyPreCrsGroupExcludeList[];
    index: string;
    name: string;
    rules: outputs.GetWafpolicyPreCrsGroupRule[];
}

export interface GetWafpolicyPreCrsGroupExcludeList {
    clientSubnets: outputs.GetWafpolicyPreCrsGroupExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyPreCrsGroupExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyPreCrsGroupExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyPreCrsGroupExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyPreCrsGroupExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyPreCrsGroupExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyPreCrsGroupExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyPreCrsGroupExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyPreCrsGroupRule {
    enable: string;
    excludeLists: outputs.GetWafpolicyPreCrsGroupRuleExcludeList[];
    index: string;
    isSensitive: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags: string[];
}

export interface GetWafpolicyPreCrsGroupRuleExcludeList {
    clientSubnets: outputs.GetWafpolicyPreCrsGroupRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias: outputs.GetWafpolicyPreCrsGroupRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias: outputs.GetWafpolicyPreCrsGroupRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface GetWafpolicyPreCrsGroupRuleExcludeListClientSubnet {
    ipAddrs: outputs.GetWafpolicyPreCrsGroupRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface GetWafpolicyPreCrsGroupRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface GetWafpolicyPreCrsGroupRuleExcludeListMatchElementCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyPreCrsGroupRuleExcludeListUriMatchCriteria {
    matchCase: string;
    matchOp: string;
}

export interface GetWafpolicyRequiredDataFile {
    name: string;
    type: string;
}

export interface GetWafpolicypsmgroupConfigpbAttribute {
    version: string;
}

export interface GetWafpolicypsmgroupLocation {
    description: string;
    index: string;
    matches: outputs.GetWafpolicypsmgroupLocationMatch[];
    name: string;
    rules: outputs.GetWafpolicypsmgroupLocationRule[];
}

export interface GetWafpolicypsmgroupLocationMatch {
    hosts: outputs.GetWafpolicypsmgroupLocationMatchHost[];
    methods: outputs.GetWafpolicypsmgroupLocationMatchMethod[];
    paths: outputs.GetWafpolicypsmgroupLocationMatchPath[];
}

export interface GetWafpolicypsmgroupLocationMatchHost {
    matchCase: string;
    matchCriteria: string;
    values: string[];
}

export interface GetWafpolicypsmgroupLocationMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface GetWafpolicypsmgroupLocationMatchPath {
    matchCase: string;
    matchCriteria: string;
    matchDecodedString: string;
    matchStrs: string[];
    stringGroupRefs: string[];
}

export interface GetWafpolicypsmgroupLocationRule {
    description: string;
    enable: string;
    index: string;
    matchCase: string;
    matchElements: outputs.GetWafpolicypsmgroupLocationRuleMatchElement[];
    matchValueMaxLength: string;
    matchValuePattern: string;
    matchValueStringGroupKey: string;
    matchValueStringGroupRef: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    ruleId: string;
}

export interface GetWafpolicypsmgroupLocationRuleMatchElement {
    excluded: string;
    index: string;
    matchCase: string;
    matchOp: string;
    name: string;
    subElement: string;
}

export interface GetWafpolicypsmgroupMarker {
    key: string;
    values: string[];
}

export interface GetWafprofileConfig {
    allowedHttpVersions: string[];
    allowedMethods: string[];
    allowedRequestContentTypeCharsets: string[];
    argumentSeparator: string;
    clientRequestMaxBodySize: string;
    contentTypeMappings: outputs.GetWafprofileConfigContentTypeMapping[];
    cookieFormatVersion: string;
    ignoreIncompleteRequestBodyError: string;
    maxExecutionTime: string;
    regexMatchLimit: string;
    regexRecursionLimit: string;
    requestBodyDefaultAction: string;
    requestHdrDefaultAction: string;
    responseBodyDefaultAction: string;
    responseHdrDefaultAction: string;
    restrictedExtensions: string[];
    restrictedHeaders: string[];
    sendStatusHeader: string;
    serverResponseMaxBodySize: string;
    staticExtensions: string[];
    statusCodeForRejectedRequests: string;
    statusHeaderName: string;
    xmlXxeProtection: string;
}

export interface GetWafprofileConfigContentTypeMapping {
    contentType: string;
    matchOp: string;
    requestBodyParser: string;
}

export interface GetWafprofileConfigpbAttribute {
    version: string;
}

export interface GetWafprofileFile {
    data: string;
    name: string;
    type: string;
}

export interface GetWafprofileMarker {
    key: string;
    values: string[];
}

export interface GetWebapputConfigpbAttribute {
    version: string;
}

export interface GetWebapputMandatoryTest {
    mandatoryMessage: outputs.GetWebapputMandatoryTestMandatoryMessage[];
    mandatoryMessages: outputs.GetWebapputMandatoryTestMandatoryMessage[];
    mandatoryString: string;
    mandatoryStrings: string[];
}

export interface GetWebapputMandatoryTestMandatoryMessage {
    mandatoryMessage: outputs.GetWebapputMandatoryTestMandatoryMessageMandatoryMessage[];
    mandatoryMessages: outputs.GetWebapputMandatoryTestMandatoryMessageMandatoryMessage[];
    mandatoryString: string;
    mandatoryStrings: string[];
}

export interface GetWebapputMandatoryTestMandatoryMessageMandatoryMessage {
    optionalString: string;
}

export interface GetWebapputSensitiveTest {
    sensitiveMessage: outputs.GetWebapputSensitiveTestSensitiveMessage[];
    sensitiveMessages: outputs.GetWebapputSensitiveTestSensitiveMessage[];
    sensitiveString: string;
}

export interface GetWebapputSensitiveTestSensitiveMessage {
    sensitiveMessage: outputs.GetWebapputSensitiveTestSensitiveMessageSensitiveMessage[];
    sensitiveMessages: outputs.GetWebapputSensitiveTestSensitiveMessageSensitiveMessage[];
    sensitiveString: string;
}

export interface GetWebapputSensitiveTestSensitiveMessageSensitiveMessage {
    optionalSensitiveString: string;
}

export interface GetWebapputStringLengthTest {
    stringLengthMessage: outputs.GetWebapputStringLengthTestStringLengthMessage[];
    stringLengthMessages: outputs.GetWebapputStringLengthTestStringLengthMessage[];
    testString: string;
    testStrings: string[];
}

export interface GetWebapputStringLengthTestStringLengthMessage {
    stringLengthMessage: outputs.GetWebapputStringLengthTestStringLengthMessageStringLengthMessage[];
    stringLengthMessages: outputs.GetWebapputStringLengthTestStringLengthMessageStringLengthMessage[];
    testString: string;
    testStrings: string[];
}

export interface GetWebapputStringLengthTestStringLengthMessageStringLengthMessage {
    testString: string;
}

export interface GetWebhookConfigpbAttribute {
    version: string;
}

export interface GetWebhookMarker {
    key: string;
    values: string[];
}

export interface GslbClientIpAddrGroup {
    addrs?: outputs.GslbClientIpAddrGroupAddr[];
    prefixes?: outputs.GslbClientIpAddrGroupPrefix[];
    ranges?: outputs.GslbClientIpAddrGroupRange[];
    type?: string;
}

export interface GslbClientIpAddrGroupAddr {
    addr: string;
    type: string;
}

export interface GslbClientIpAddrGroupPrefix {
    ipAddrs: outputs.GslbClientIpAddrGroupPrefixIpAddr[];
    mask: string;
}

export interface GslbClientIpAddrGroupPrefixIpAddr {
    addr: string;
    type: string;
}

export interface GslbClientIpAddrGroupRange {
    begins: outputs.GslbClientIpAddrGroupRangeBegin[];
    ends: outputs.GslbClientIpAddrGroupRangeEnd[];
}

export interface GslbClientIpAddrGroupRangeBegin {
    addr: string;
    type: string;
}

export interface GslbClientIpAddrGroupRangeEnd {
    addr: string;
    type: string;
}

export interface GslbConfigpbAttribute {
    version: string;
}

export interface GslbDnsConfig {
    domainName: string;
}

export interface GslbReplicationPolicy {
    checkpointRef: string;
    replicationMode?: string;
}

export interface GslbSite {
    address: string;
    clusterUuid: string;
    dnsVses?: outputs.GslbSiteDnsVse[];
    enabled?: string;
    hmProxies?: outputs.GslbSiteHmProxy[];
    hmShardEnabled?: string;
    ipAddresses?: outputs.GslbSiteIpAddress[];
    locations?: outputs.GslbSiteLocation[];
    memberType?: string;
    name: string;
    password: string;
    port?: string;
    ratio: string;
    suspendMode?: string;
    username: string;
    uuid: string;
}

export interface GslbSiteDnsVse {
    dnsVsUuid: string;
    domainNames?: string[];
}

export interface GslbSiteHmProxy {
    proxyType?: string;
    siteUuid: string;
}

export interface GslbSiteIpAddress {
    addr: string;
    type: string;
}

export interface GslbSiteLocation {
    locations?: outputs.GslbSiteLocationLocation[];
    source: string;
}

export interface GslbSiteLocationLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GslbThirdPartySite {
    clusterUuid: string;
    enabled?: string;
    hmProxies?: outputs.GslbThirdPartySiteHmProxy[];
    locations?: outputs.GslbThirdPartySiteLocation[];
    name: string;
    ratio: string;
    uuid: string;
}

export interface GslbThirdPartySiteHmProxy {
    proxyType?: string;
    siteUuid: string;
}

export interface GslbThirdPartySiteLocation {
    locations?: outputs.GslbThirdPartySiteLocationLocation[];
    source: string;
}

export interface GslbThirdPartySiteLocationLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GslbgeodbprofileConfigpbAttribute {
    version: string;
}

export interface GslbgeodbprofileEntry {
    files: outputs.GslbgeodbprofileEntryFile[];
    priority?: string;
}

export interface GslbgeodbprofileEntryFile {
    checksum: string;
    fileId: string;
    fileIdChecksum: string;
    filename: string;
    format?: string;
    timestamp: string;
}

export interface GslbgeodbprofileMarker {
    key: string;
    values?: string[];
}

export interface GslbserviceConfigpbAttribute {
    version: string;
}

export interface GslbserviceDownResponse {
    fallbackCname: string;
    fallbackIp6s?: outputs.GslbserviceDownResponseFallbackIp6[];
    fallbackIps?: outputs.GslbserviceDownResponseFallbackIp[];
    type?: string;
}

export interface GslbserviceDownResponseFallbackIp {
    addr: string;
    type: string;
}

export interface GslbserviceDownResponseFallbackIp6 {
    addr: string;
    type: string;
}

export interface GslbserviceGroup {
    algorithm?: string;
    consistentHashMask: string;
    consistentHashMask6: string;
    description: string;
    enabled?: string;
    fallbackAlgorithm: string;
    manualResume?: string;
    members: outputs.GslbserviceGroupMember[];
    minHealthMonitorsUp: string;
    name: string;
    priority?: string;
}

export interface GslbserviceGroupMember {
    cloudUuid: string;
    clusterUuid: string;
    description: string;
    enabled?: string;
    fqdn: string;
    hostname: string;
    ips?: outputs.GslbserviceGroupMemberIp[];
    locations?: outputs.GslbserviceGroupMemberLocation[];
    preferenceOrder?: string;
    publicIps?: outputs.GslbserviceGroupMemberPublicIp[];
    ratio?: string;
    resolveFqdnToV6?: string;
    vsUuid: string;
}

export interface GslbserviceGroupMemberIp {
    addr: string;
    type: string;
}

export interface GslbserviceGroupMemberLocation {
    locations?: outputs.GslbserviceGroupMemberLocationLocation[];
    source: string;
}

export interface GslbserviceGroupMemberLocationLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface GslbserviceGroupMemberPublicIp {
    ips?: outputs.GslbserviceGroupMemberPublicIpIp[];
}

export interface GslbserviceGroupMemberPublicIpIp {
    addr: string;
    type: string;
}

export interface GslbserviceMarker {
    key: string;
    values?: string[];
}

export interface HardwaresecuritymodulegroupConfigpbAttribute {
    version: string;
}

export interface HardwaresecuritymodulegroupHsm {
    cloudhsms?: outputs.HardwaresecuritymodulegroupHsmCloudhsm[];
    nethsms?: outputs.HardwaresecuritymodulegroupHsmNethsm[];
    rfs?: outputs.HardwaresecuritymodulegroupHsmRf[];
    slunas?: outputs.HardwaresecuritymodulegroupHsmSluna[];
    type: string;
}

export interface HardwaresecuritymodulegroupHsmCloudhsm {
    clientConfig: string;
    clusterCert: string;
    cryptoUserName: string;
    cryptoUserPassword: string;
    hsmIps?: string[];
    mgmtConfig: string;
}

export interface HardwaresecuritymodulegroupHsmNethsm {
    esn: string;
    keyhash: string;
    moduleId?: string;
    priority: string;
    remoteIps: outputs.HardwaresecuritymodulegroupHsmNethsmRemoteIp[];
    remotePort?: string;
}

export interface HardwaresecuritymodulegroupHsmNethsmRemoteIp {
    addr: string;
    type: string;
}

export interface HardwaresecuritymodulegroupHsmRf {
    ips: outputs.HardwaresecuritymodulegroupHsmRfIp[];
    port?: string;
}

export interface HardwaresecuritymodulegroupHsmRfIp {
    addr: string;
    type: string;
}

export interface HardwaresecuritymodulegroupHsmSluna {
    haGroupNum: string;
    isHa: string;
    nodeInfos?: outputs.HardwaresecuritymodulegroupHsmSlunaNodeInfo[];
    serverPem: string;
    servers?: outputs.HardwaresecuritymodulegroupHsmSlunaServer[];
    useDedicatedNetwork?: string;
}

export interface HardwaresecuritymodulegroupHsmSlunaNodeInfo {
    chrystokiConf: string;
    clientCert: string;
    clientIp: string;
    clientPrivKey: string;
    sessionMajorNumber: string;
    sessionMinorNumber: string;
}

export interface HardwaresecuritymodulegroupHsmSlunaServer {
    index: string;
    partitionPasswd: string;
    partitionSerialNumber: string;
    remoteIp: string;
    serverCert: string;
}

export interface HardwaresecuritymodulegroupMarker {
    key: string;
    values?: string[];
}

export interface HealthmonitorAuthentication {
    password: string;
    username: string;
}

export interface HealthmonitorConfigpbAttribute {
    version: string;
}

export interface HealthmonitorDnsMonitor {
    qtype?: string;
    queryName: string;
    rcode?: string;
    recordType?: string;
    responseString: string;
}

export interface HealthmonitorExternalMonitor {
    commandCode: string;
    commandParameters: string;
    commandPath: string;
    commandVariables: string;
}

export interface HealthmonitorFtpMonitor {
    filename: string;
    mode?: string;
    sslAttributes?: outputs.HealthmonitorFtpMonitorSslAttribute[];
}

export interface HealthmonitorFtpMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorFtpsMonitor {
    filename: string;
    mode?: string;
    sslAttributes?: outputs.HealthmonitorFtpsMonitorSslAttribute[];
}

export interface HealthmonitorFtpsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorHttpMonitor {
    authType: string;
    exactHttpRequest?: string;
    httpRequest?: string;
    httpRequestBody: string;
    httpResponse: string;
    httpResponseCodes: string[];
    maintenanceCodes?: number[];
    maintenanceResponse: string;
    responseSize: string;
    sslAttributes?: outputs.HealthmonitorHttpMonitorSslAttribute[];
}

export interface HealthmonitorHttpMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorHttpsMonitor {
    authType: string;
    exactHttpRequest?: string;
    httpRequest?: string;
    httpRequestBody: string;
    httpResponse: string;
    httpResponseCodes: string[];
    maintenanceCodes?: number[];
    maintenanceResponse: string;
    responseSize: string;
    sslAttributes?: outputs.HealthmonitorHttpsMonitorSslAttribute[];
}

export interface HealthmonitorHttpsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorImapMonitor {
    folder: string;
    sslAttributes?: outputs.HealthmonitorImapMonitorSslAttribute[];
}

export interface HealthmonitorImapMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorImapsMonitor {
    folder: string;
    sslAttributes?: outputs.HealthmonitorImapsMonitorSslAttribute[];
}

export interface HealthmonitorImapsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorLdapMonitor {
    attributes: string;
    baseDn: string;
    filter: string;
    scope: string;
    sslAttributes?: outputs.HealthmonitorLdapMonitorSslAttribute[];
}

export interface HealthmonitorLdapMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorLdapsMonitor {
    attributes: string;
    baseDn: string;
    filter: string;
    scope: string;
    sslAttributes?: outputs.HealthmonitorLdapsMonitorSslAttribute[];
}

export interface HealthmonitorLdapsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorMarker {
    key: string;
    values?: string[];
}

export interface HealthmonitorPop3Monitor {
    sslAttributes?: outputs.HealthmonitorPop3MonitorSslAttribute[];
}

export interface HealthmonitorPop3MonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorPop3sMonitor {
    sslAttributes?: outputs.HealthmonitorPop3sMonitorSslAttribute[];
}

export interface HealthmonitorPop3sMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorRadiusMonitor {
    password: string;
    sharedSecret: string;
    username: string;
}

export interface HealthmonitorSctpMonitor {
    sctpRequest: string;
    sctpResponse: string;
}

export interface HealthmonitorSipMonitor {
    sipMonitorTransport?: string;
    sipRequestCode?: string;
    sipResponse?: string;
}

export interface HealthmonitorSmtpMonitor {
    domainname: string;
    mailData: string;
    recipientsIds?: string[];
    senderId: string;
    sslAttributes?: outputs.HealthmonitorSmtpMonitorSslAttribute[];
}

export interface HealthmonitorSmtpMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorSmtpsMonitor {
    domainname: string;
    mailData: string;
    recipientsIds?: string[];
    senderId: string;
    sslAttributes?: outputs.HealthmonitorSmtpsMonitorSslAttribute[];
}

export interface HealthmonitorSmtpsMonitorSslAttribute {
    pkiProfileRef: string;
    serverName: string;
    sslKeyAndCertificateRef: string;
    sslProfileRef: string;
}

export interface HealthmonitorTcpMonitor {
    maintenanceResponse: string;
    tcpHalfOpen?: string;
    tcpRequest: string;
    tcpResponse: string;
}

export interface HealthmonitorUdpMonitor {
    maintenanceResponse: string;
    udpRequest: string;
    udpResponse: string;
}

export interface HttppolicysetConfigpbAttribute {
    version: string;
}

export interface HttppolicysetHttpRequestPolicy {
    rules?: outputs.HttppolicysetHttpRequestPolicyRule[];
}

export interface HttppolicysetHttpRequestPolicyRule {
    allHeaders: string;
    enable: string;
    hdrActions?: outputs.HttppolicysetHttpRequestPolicyRuleHdrAction[];
    index: string;
    log: string;
    matches?: outputs.HttppolicysetHttpRequestPolicyRuleMatch[];
    name: string;
    redirectActions?: outputs.HttppolicysetHttpRequestPolicyRuleRedirectAction[];
    rewriteUrlActions?: outputs.HttppolicysetHttpRequestPolicyRuleRewriteUrlAction[];
    switchingActions?: outputs.HttppolicysetHttpRequestPolicyRuleSwitchingAction[];
}

export interface HttppolicysetHttpRequestPolicyRuleHdrAction {
    action: string;
    cookies?: outputs.HttppolicysetHttpRequestPolicyRuleHdrActionCookie[];
    hdrIndex: string;
    hdrs?: outputs.HttppolicysetHttpRequestPolicyRuleHdrActionHdr[];
}

export interface HttppolicysetHttpRequestPolicyRuleHdrActionCookie {
    name: string;
    value: string;
}

export interface HttppolicysetHttpRequestPolicyRuleHdrActionHdr {
    name: string;
    values?: outputs.HttppolicysetHttpRequestPolicyRuleHdrActionHdrValue[];
}

export interface HttppolicysetHttpRequestPolicyRuleHdrActionHdrValue {
    isSensitive?: string;
    val: string;
    var: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatch {
    botDetectionResults?: outputs.HttppolicysetHttpRequestPolicyRuleMatchBotDetectionResult[];
    clientIps?: outputs.HttppolicysetHttpRequestPolicyRuleMatchClientIp[];
    cookies?: outputs.HttppolicysetHttpRequestPolicyRuleMatchCookie[];
    geoMatches?: outputs.HttppolicysetHttpRequestPolicyRuleMatchGeoMatch[];
    hdrs?: outputs.HttppolicysetHttpRequestPolicyRuleMatchHdr[];
    hostHdrs?: outputs.HttppolicysetHttpRequestPolicyRuleMatchHostHdr[];
    ipReputationTypes?: outputs.HttppolicysetHttpRequestPolicyRuleMatchIpReputationType[];
    methods?: outputs.HttppolicysetHttpRequestPolicyRuleMatchMethod[];
    paths?: outputs.HttppolicysetHttpRequestPolicyRuleMatchPath[];
    protocols?: outputs.HttppolicysetHttpRequestPolicyRuleMatchProtocol[];
    queries?: outputs.HttppolicysetHttpRequestPolicyRuleMatchQuery[];
    sourceIps?: outputs.HttppolicysetHttpRequestPolicyRuleMatchSourceIp[];
    tlsFingerprintMatches?: outputs.HttppolicysetHttpRequestPolicyRuleMatchTlsFingerprintMatch[];
    versions?: outputs.HttppolicysetHttpRequestPolicyRuleMatchVersion[];
    vsPorts?: outputs.HttppolicysetHttpRequestPolicyRuleMatchVsPort[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchBotDetectionResult {
    classifications?: outputs.HttppolicysetHttpRequestPolicyRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchClientIp {
    addrs?: outputs.HttppolicysetHttpRequestPolicyRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.HttppolicysetHttpRequestPolicyRuleMatchClientIpPrefix[];
    ranges?: outputs.HttppolicysetHttpRequestPolicyRuleMatchClientIpRange[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.HttppolicysetHttpRequestPolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchClientIpRange {
    begins: outputs.HttppolicysetHttpRequestPolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.HttppolicysetHttpRequestPolicyRuleMatchClientIpRangeEnd[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchCookie {
    matchCase?: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchQuery {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchSourceIp {
    addrs?: outputs.HttppolicysetHttpRequestPolicyRuleMatchSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.HttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefix[];
    ranges?: outputs.HttppolicysetHttpRequestPolicyRuleMatchSourceIpRange[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.HttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchSourceIpRange {
    begins: outputs.HttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.HttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeEnd[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleMatchTlsFingerprintMatch {
    fingerprints?: string[];
    matchOperation: string;
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface HttppolicysetHttpRequestPolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface HttppolicysetHttpRequestPolicyRuleRedirectAction {
    addString: string;
    hosts?: outputs.HttppolicysetHttpRequestPolicyRuleRedirectActionHost[];
    keepQuery?: string;
    paths?: outputs.HttppolicysetHttpRequestPolicyRuleRedirectActionPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRedirectActionHost {
    tokens: outputs.HttppolicysetHttpRequestPolicyRuleRedirectActionHostToken[];
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRedirectActionHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRedirectActionPath {
    tokens: outputs.HttppolicysetHttpRequestPolicyRuleRedirectActionPathToken[];
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRedirectActionPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRewriteUrlAction {
    hostHdrs?: outputs.HttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdr[];
    paths?: outputs.HttppolicysetHttpRequestPolicyRuleRewriteUrlActionPath[];
    queries?: outputs.HttppolicysetHttpRequestPolicyRuleRewriteUrlActionQuery[];
}

export interface HttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdr {
    tokens: outputs.HttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdrToken[];
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRewriteUrlActionHostHdrToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRewriteUrlActionPath {
    tokens: outputs.HttppolicysetHttpRequestPolicyRuleRewriteUrlActionPathToken[];
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRewriteUrlActionPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpRequestPolicyRuleRewriteUrlActionQuery {
    addString: string;
    keepQuery?: string;
}

export interface HttppolicysetHttpRequestPolicyRuleSwitchingAction {
    action: string;
    files?: outputs.HttppolicysetHttpRequestPolicyRuleSwitchingActionFile[];
    otherStatusCode: string;
    poolGroupRef: string;
    poolRef: string;
    servers?: outputs.HttppolicysetHttpRequestPolicyRuleSwitchingActionServer[];
    statusCode: string;
}

export interface HttppolicysetHttpRequestPolicyRuleSwitchingActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface HttppolicysetHttpRequestPolicyRuleSwitchingActionServer {
    hostname: string;
    ips: outputs.HttppolicysetHttpRequestPolicyRuleSwitchingActionServerIp[];
    port: string;
}

export interface HttppolicysetHttpRequestPolicyRuleSwitchingActionServerIp {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicy {
    rules?: outputs.HttppolicysetHttpResponsePolicyRule[];
}

export interface HttppolicysetHttpResponsePolicyRule {
    allHeaders: string;
    enable: string;
    hdrActions?: outputs.HttppolicysetHttpResponsePolicyRuleHdrAction[];
    index: string;
    locHdrActions?: outputs.HttppolicysetHttpResponsePolicyRuleLocHdrAction[];
    log: string;
    matches?: outputs.HttppolicysetHttpResponsePolicyRuleMatch[];
    name: string;
}

export interface HttppolicysetHttpResponsePolicyRuleHdrAction {
    action: string;
    cookies?: outputs.HttppolicysetHttpResponsePolicyRuleHdrActionCookie[];
    hdrIndex: string;
    hdrs?: outputs.HttppolicysetHttpResponsePolicyRuleHdrActionHdr[];
}

export interface HttppolicysetHttpResponsePolicyRuleHdrActionCookie {
    name: string;
    value: string;
}

export interface HttppolicysetHttpResponsePolicyRuleHdrActionHdr {
    name: string;
    values?: outputs.HttppolicysetHttpResponsePolicyRuleHdrActionHdrValue[];
}

export interface HttppolicysetHttpResponsePolicyRuleHdrActionHdrValue {
    isSensitive?: string;
    val: string;
    var: string;
}

export interface HttppolicysetHttpResponsePolicyRuleLocHdrAction {
    hosts?: outputs.HttppolicysetHttpResponsePolicyRuleLocHdrActionHost[];
    keepQuery?: string;
    paths?: outputs.HttppolicysetHttpResponsePolicyRuleLocHdrActionPath[];
    port: string;
    protocol: string;
}

export interface HttppolicysetHttpResponsePolicyRuleLocHdrActionHost {
    tokens: outputs.HttppolicysetHttpResponsePolicyRuleLocHdrActionHostToken[];
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleLocHdrActionHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleLocHdrActionPath {
    tokens: outputs.HttppolicysetHttpResponsePolicyRuleLocHdrActionPathToken[];
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleLocHdrActionPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatch {
    clientIps?: outputs.HttppolicysetHttpResponsePolicyRuleMatchClientIp[];
    cookies?: outputs.HttppolicysetHttpResponsePolicyRuleMatchCookie[];
    hdrs?: outputs.HttppolicysetHttpResponsePolicyRuleMatchHdr[];
    hostHdrs?: outputs.HttppolicysetHttpResponsePolicyRuleMatchHostHdr[];
    locHdrs?: outputs.HttppolicysetHttpResponsePolicyRuleMatchLocHdr[];
    methods?: outputs.HttppolicysetHttpResponsePolicyRuleMatchMethod[];
    paths?: outputs.HttppolicysetHttpResponsePolicyRuleMatchPath[];
    protocols?: outputs.HttppolicysetHttpResponsePolicyRuleMatchProtocol[];
    queries?: outputs.HttppolicysetHttpResponsePolicyRuleMatchQuery[];
    rspHdrs?: outputs.HttppolicysetHttpResponsePolicyRuleMatchRspHdr[];
    sourceIps?: outputs.HttppolicysetHttpResponsePolicyRuleMatchSourceIp[];
    statuses?: outputs.HttppolicysetHttpResponsePolicyRuleMatchStatus[];
    versions?: outputs.HttppolicysetHttpResponsePolicyRuleMatchVersion[];
    vsPorts?: outputs.HttppolicysetHttpResponsePolicyRuleMatchVsPort[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchClientIp {
    addrs?: outputs.HttppolicysetHttpResponsePolicyRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.HttppolicysetHttpResponsePolicyRuleMatchClientIpPrefix[];
    ranges?: outputs.HttppolicysetHttpResponsePolicyRuleMatchClientIpRange[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.HttppolicysetHttpResponsePolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchClientIpRange {
    begins: outputs.HttppolicysetHttpResponsePolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.HttppolicysetHttpResponsePolicyRuleMatchClientIpRangeEnd[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchCookie {
    matchCase?: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchLocHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchQuery {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchRspHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchSourceIp {
    addrs?: outputs.HttppolicysetHttpResponsePolicyRuleMatchSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.HttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefix[];
    ranges?: outputs.HttppolicysetHttpResponsePolicyRuleMatchSourceIpRange[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.HttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchSourceIpRange {
    begins: outputs.HttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.HttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeEnd[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchStatus {
    matchCriteria: string;
    ranges?: outputs.HttppolicysetHttpResponsePolicyRuleMatchStatusRange[];
    statusCodes?: number[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchStatusRange {
    begin: string;
    end: string;
}

export interface HttppolicysetHttpResponsePolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface HttppolicysetHttpResponsePolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface HttppolicysetHttpSecurityPolicy {
    rules?: outputs.HttppolicysetHttpSecurityPolicyRule[];
}

export interface HttppolicysetHttpSecurityPolicyRule {
    actions?: outputs.HttppolicysetHttpSecurityPolicyRuleAction[];
    enable: string;
    index: string;
    log: string;
    matches?: outputs.HttppolicysetHttpSecurityPolicyRuleMatch[];
    name: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleAction {
    action: string;
    files?: outputs.HttppolicysetHttpSecurityPolicyRuleActionFile[];
    httpsPort: string;
    rateProfiles?: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfile[];
    statusCode: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfile {
    actions: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileAction[];
    perClientIp: string;
    perUriPath: string;
    rateLimiters: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileRateLimiter[];
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileAction {
    files?: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionFile[];
    redirects?: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirect {
    addString: string;
    hosts?: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHost {
    tokens: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHostToken[];
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPath {
    tokens: outputs.HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPathToken[];
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleActionRateProfileRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatch {
    botDetectionResults?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResult[];
    clientIps?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchClientIp[];
    cookies?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchCookie[];
    geoMatches?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchGeoMatch[];
    hdrs?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchHdr[];
    hostHdrs?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchHostHdr[];
    ipReputationTypes?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchIpReputationType[];
    methods?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchMethod[];
    paths?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchPath[];
    protocols?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchProtocol[];
    queries?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchQuery[];
    sourceIps?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchSourceIp[];
    tlsFingerprintMatches?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchTlsFingerprintMatch[];
    versions?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchVersion[];
    vsPorts?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchVsPort[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResult {
    classifications?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchClientIp {
    addrs?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefix[];
    ranges?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchClientIpRange[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.HttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchClientIpRange {
    begins: outputs.HttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.HttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeEnd[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchCookie {
    matchCase?: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchQuery {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchSourceIp {
    addrs?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefix[];
    ranges?: outputs.HttppolicysetHttpSecurityPolicyRuleMatchSourceIpRange[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.HttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchSourceIpRange {
    begins: outputs.HttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.HttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeEnd[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchTlsFingerprintMatch {
    fingerprints?: string[];
    matchOperation: string;
    stringGroupRefs?: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface HttppolicysetHttpSecurityPolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface HttppolicysetMarker {
    key: string;
    values?: string[];
}

export interface IcapprofileConfigpbAttribute {
    version: string;
}

export interface IcapprofileNsxDefenderConfig {
    statusUrl?: string;
}

export interface ImageCloudInfoValue {
    cloudDataValues?: outputs.ImageCloudInfoValueCloudDataValue[];
    cloudName: string;
}

export interface ImageCloudInfoValueCloudDataValue {
    key: string;
    values?: string[];
}

export interface ImageControllerInfo {
    builds?: outputs.ImageControllerInfoBuild[];
    hash: string;
    patches?: outputs.ImageControllerInfoPatch[];
    path: string;
}

export interface ImageControllerInfoBuild {
    buildNo: string;
    date: string;
    minVersion: string;
    patchVersion: string;
    product: string;
    productName: string;
    remoteImageRef: string;
    tag: string;
    version: string;
}

export interface ImageControllerInfoPatch {
    patchType: string;
    reboot: string;
    rebootLists?: outputs.ImageControllerInfoPatchRebootList[];
}

export interface ImageControllerInfoPatchRebootList {
    patchVersion: string;
    reboot: string;
}

export interface ImageEvent {
    nodesEvents?: outputs.ImageEventNodesEvent[];
    subEvents?: outputs.ImageEventSubEvent[];
    taskName: string;
}

export interface ImageEventNodesEvent {
    duration: string;
    endTime: string;
    ips?: outputs.ImageEventNodesEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks?: string[];
}

export interface ImageEventNodesEventIp {
    addr: string;
    type: string;
}

export interface ImageEventSubEvent {
    duration: string;
    endTime: string;
    ips?: outputs.ImageEventSubEventIp[];
    message: string;
    startTime: string;
    status: string;
    subTasks?: string[];
}

export interface ImageEventSubEventIp {
    addr: string;
    type: string;
}

export interface ImageImgState {
    lastChangedTimes?: outputs.ImageImgStateLastChangedTime[];
    reason: string;
    state: string;
}

export interface ImageImgStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface ImageMigration {
    apiVersion: string;
    controllerHostMinFreeDiskSize?: string;
    controllerMinCores?: string;
    controllerMinDockerVersion?: string;
    controllerMinFreeDiskSize?: string;
    controllerMinMemory?: string;
    controllerMinTotalDisk?: string;
    maxActiveVersions?: string;
    minSupportedApiVersion: string;
    podmanControllerHostMinFreeDiskSize?: string;
    podmanSeHostMinFreeDiskSize?: string;
    rollbackControllerDiskSpace?: string;
    rollbackSeDiskSpace?: string;
    seHostMinFreeDiskSize?: string;
    seMinCores?: string;
    seMinFreeDiskSize?: string;
    seMinMemory?: string;
    seMinTotalDisk?: string;
    versions?: string[];
}

export interface ImageSeInfo {
    builds?: outputs.ImageSeInfoBuild[];
    hash: string;
    patches?: outputs.ImageSeInfoPatch[];
    path: string;
}

export interface ImageSeInfoBuild {
    buildNo: string;
    date: string;
    minVersion: string;
    patchVersion: string;
    product: string;
    productName: string;
    remoteImageRef: string;
    tag: string;
    version: string;
}

export interface ImageSeInfoPatch {
    patchType: string;
    reboot: string;
    rebootLists?: outputs.ImageSeInfoPatchRebootList[];
}

export interface ImageSeInfoPatchRebootList {
    patchVersion: string;
    reboot: string;
}

export interface InventoryfaultconfigConfigpbAttribute {
    version: string;
}

export interface InventoryfaultconfigControllerFault {
    backupSchedulerFaults?: string;
    clusterFaults?: string;
    deprecatedApiVersionFaults?: string;
    licenseFaults?: string;
    migrationFaults?: string;
    sslprofileFaults?: string;
}

export interface InventoryfaultconfigServiceengineFault {
    debugFaults?: string;
}

export interface InventoryfaultconfigVirtualserviceFault {
    debugFaults?: string;
    poolServerFaults?: string;
    scaleoutFaults?: string;
    sharedVipFaults?: string;
    sslCertExpiryFaults?: string;
    sslCertStatusFaults?: string;
}

export interface IpaddrgroupAddr {
    addr: string;
    type: string;
}

export interface IpaddrgroupConfigpbAttribute {
    version: string;
}

export interface IpaddrgroupIpPort {
    hostname: string;
    ips?: outputs.IpaddrgroupIpPortIp[];
    name: string;
    port: string;
}

export interface IpaddrgroupIpPortIp {
    addr: string;
    type: string;
}

export interface IpaddrgroupMarker {
    key: string;
    values?: string[];
}

export interface IpaddrgroupPrefix {
    ipAddrs: outputs.IpaddrgroupPrefixIpAddr[];
    mask: string;
}

export interface IpaddrgroupPrefixIpAddr {
    addr: string;
    type: string;
}

export interface IpaddrgroupRange {
    begins: outputs.IpaddrgroupRangeBegin[];
    ends: outputs.IpaddrgroupRangeEnd[];
}

export interface IpaddrgroupRangeBegin {
    addr: string;
    type: string;
}

export interface IpaddrgroupRangeEnd {
    addr: string;
    type: string;
}

export interface IpamdnsproviderprofileAwsProfile {
    accessKeyId: string;
    egressServiceSubnets?: string[];
    iamAssumeRole: string;
    publishVipToPublicZone?: string;
    region: string;
    secretAccessKey: string;
    ttl?: string;
    usableDomains?: string[];
    usableNetworkUuids?: string[];
    useIamRoles?: string;
    vpc: string;
    vpcId: string;
    zones?: outputs.IpamdnsproviderprofileAwsProfileZone[];
}

export interface IpamdnsproviderprofileAwsProfileZone {
    availabilityZone: string;
    usableNetworkUuids?: string[];
}

export interface IpamdnsproviderprofileAzureProfile {
    azureServiceprincipals?: outputs.IpamdnsproviderprofileAzureProfileAzureServiceprincipal[];
    azureUserpasses?: outputs.IpamdnsproviderprofileAzureProfileAzureUserpass[];
    egressServiceSubnets?: string[];
    resourceGroup: string;
    subscriptionId: string;
    usableDomains?: string[];
    usableNetworkUuids?: string[];
    useEnhancedHa?: string;
    useStandardAlb?: string;
    virtualNetworkIds?: string[];
}

export interface IpamdnsproviderprofileAzureProfileAzureServiceprincipal {
    applicationId: string;
    authenticationToken: string;
    tenantId: string;
}

export interface IpamdnsproviderprofileAzureProfileAzureUserpass {
    password: string;
    tenantName: string;
    username: string;
}

export interface IpamdnsproviderprofileConfigpbAttribute {
    version: string;
}

export interface IpamdnsproviderprofileCustomProfile {
    customIpamDnsProfileRef: string;
    dynamicParams?: outputs.IpamdnsproviderprofileCustomProfileDynamicParam[];
    usableAllocSubnets?: outputs.IpamdnsproviderprofileCustomProfileUsableAllocSubnet[];
    usableDomains?: string[];
}

export interface IpamdnsproviderprofileCustomProfileDynamicParam {
    isDynamic?: string;
    isSensitive?: string;
    name: string;
    value: string;
}

export interface IpamdnsproviderprofileCustomProfileUsableAllocSubnet {
    networkId: string;
    subnet6s?: outputs.IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6[];
    subnets?: outputs.IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet[];
}

export interface IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet {
    ipAddrs: outputs.IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnetIpAddr[];
    mask: string;
}

export interface IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6 {
    ipAddrs: outputs.IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6IpAddr[];
    mask: string;
}

export interface IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface IpamdnsproviderprofileCustomProfileUsableAllocSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface IpamdnsproviderprofileGcpProfile {
    matchSeGroupSubnet?: string;
    networkHostProjectId: string;
    regionName: string;
    seProjectId: string;
    usableNetworkRefs?: string[];
    useGcpNetwork?: string;
    vpcNetworkName: string;
}

export interface IpamdnsproviderprofileInfobloxProfile {
    dnsView: string;
    extensibleAttributes?: outputs.IpamdnsproviderprofileInfobloxProfileExtensibleAttribute[];
    ip6Addresses?: outputs.IpamdnsproviderprofileInfobloxProfileIp6Address[];
    ipAddresses?: outputs.IpamdnsproviderprofileInfobloxProfileIpAddress[];
    networkView: string;
    password: string;
    profileUrl: string;
    usableAllocSubnets?: outputs.IpamdnsproviderprofileInfobloxProfileUsableAllocSubnet[];
    usableDomains?: string[];
    username: string;
    wapiVersion?: string;
}

export interface IpamdnsproviderprofileInfobloxProfileExtensibleAttribute {
    isDynamic?: string;
    isSensitive?: string;
    name: string;
    value: string;
}

export interface IpamdnsproviderprofileInfobloxProfileIp6Address {
    addr: string;
    type: string;
}

export interface IpamdnsproviderprofileInfobloxProfileIpAddress {
    addr: string;
    type: string;
}

export interface IpamdnsproviderprofileInfobloxProfileUsableAllocSubnet {
    subnet6s?: outputs.IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6[];
    subnets?: outputs.IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet[];
}

export interface IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet {
    ipAddrs: outputs.IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnetIpAddr[];
    mask: string;
}

export interface IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6 {
    ipAddrs: outputs.IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6IpAddr[];
    mask: string;
}

export interface IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface IpamdnsproviderprofileInfobloxProfileUsableAllocSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface IpamdnsproviderprofileInternalProfile {
    dnsServiceDomains?: outputs.IpamdnsproviderprofileInternalProfileDnsServiceDomain[];
    dnsVirtualserviceRef: string;
    ttl?: string;
    usableNetworks?: outputs.IpamdnsproviderprofileInternalProfileUsableNetwork[];
}

export interface IpamdnsproviderprofileInternalProfileDnsServiceDomain {
    domainName: string;
    passThrough?: string;
    recordTtl: string;
}

export interface IpamdnsproviderprofileInternalProfileUsableNetwork {
    labels?: outputs.IpamdnsproviderprofileInternalProfileUsableNetworkLabel[];
    nwRef: string;
}

export interface IpamdnsproviderprofileInternalProfileUsableNetworkLabel {
    key: string;
    value: string;
}

export interface IpamdnsproviderprofileMarker {
    key: string;
    values?: string[];
}

export interface IpamdnsproviderprofileOciProfile {
    cloudCredentialsRef: string;
    region: string;
    tenancy: string;
    vcnCompartmentId: string;
    vcnId: string;
}

export interface IpamdnsproviderprofileOpenstackProfile {
    keystoneHost: string;
    password: string;
    region: string;
    tenant: string;
    username: string;
    vipNetworkName: string;
}

export interface IpamdnsproviderprofileProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface IpamdnsproviderprofileTencentProfile {
    cloudCredentialsRef: string;
    region: string;
    usableSubnetIds?: string[];
    vpcId: string;
    zones?: outputs.IpamdnsproviderprofileTencentProfileZone[];
}

export interface IpamdnsproviderprofileTencentProfileZone {
    availabilityZone: string;
    usableSubnetId: string;
}

export interface IpreputationdbConfigpbAttribute {
    version: string;
}

export interface IpreputationdbMarker {
    key: string;
    values?: string[];
}

export interface IpreputationdbServiceStatus {
    error: string;
    lastSuccessfulUpdateChecks?: outputs.IpreputationdbServiceStatusLastSuccessfulUpdateCheck[];
}

export interface IpreputationdbServiceStatusLastSuccessfulUpdateCheck {
    secs: string;
    usecs: string;
}

export interface JwtserverprofileConfigpbAttribute {
    version: string;
}

export interface JwtserverprofileControllerInternalAuth {
    symmetricJwksKeys: outputs.JwtserverprofileControllerInternalAuthSymmetricJwksKey[];
}

export interface JwtserverprofileControllerInternalAuthSymmetricJwksKey {
    alg?: string;
    key: string;
    kid: string;
    kty?: string;
}

export interface L4policysetConfigpbAttribute {
    version: string;
}

export interface L4policysetL4ConnectionPolicy {
    rules?: outputs.L4policysetL4ConnectionPolicyRule[];
}

export interface L4policysetL4ConnectionPolicyRule {
    actions?: outputs.L4policysetL4ConnectionPolicyRuleAction[];
    enable?: string;
    index: string;
    matches?: outputs.L4policysetL4ConnectionPolicyRuleMatch[];
    name: string;
}

export interface L4policysetL4ConnectionPolicyRuleAction {
    selectPools?: outputs.L4policysetL4ConnectionPolicyRuleActionSelectPool[];
}

export interface L4policysetL4ConnectionPolicyRuleActionSelectPool {
    actionType: string;
    poolGroupRef: string;
    poolRef: string;
}

export interface L4policysetL4ConnectionPolicyRuleMatch {
    clientIps?: outputs.L4policysetL4ConnectionPolicyRuleMatchClientIp[];
    ports?: outputs.L4policysetL4ConnectionPolicyRuleMatchPort[];
    protocols?: outputs.L4policysetL4ConnectionPolicyRuleMatchProtocol[];
}

export interface L4policysetL4ConnectionPolicyRuleMatchClientIp {
    addrs?: outputs.L4policysetL4ConnectionPolicyRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.L4policysetL4ConnectionPolicyRuleMatchClientIpPrefix[];
    ranges?: outputs.L4policysetL4ConnectionPolicyRuleMatchClientIpRange[];
}

export interface L4policysetL4ConnectionPolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface L4policysetL4ConnectionPolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.L4policysetL4ConnectionPolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface L4policysetL4ConnectionPolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface L4policysetL4ConnectionPolicyRuleMatchClientIpRange {
    begins: outputs.L4policysetL4ConnectionPolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.L4policysetL4ConnectionPolicyRuleMatchClientIpRangeEnd[];
}

export interface L4policysetL4ConnectionPolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface L4policysetL4ConnectionPolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface L4policysetL4ConnectionPolicyRuleMatchPort {
    matchCriteria: string;
    portRanges?: outputs.L4policysetL4ConnectionPolicyRuleMatchPortPortRange[];
    ports?: number[];
}

export interface L4policysetL4ConnectionPolicyRuleMatchPortPortRange {
    end: string;
    start: string;
}

export interface L4policysetL4ConnectionPolicyRuleMatchProtocol {
    matchCriteria: string;
    protocol: string;
}

export interface L4policysetMarker {
    key: string;
    values?: string[];
}

export interface LabelgroupConfigpbAttribute {
    version: string;
}

export interface LabelgroupLabel {
    matchLabels: outputs.LabelgroupLabelMatchLabel[];
    matchOperation?: string;
}

export interface LabelgroupLabelMatchLabel {
    key: string;
    values?: string[];
}

export interface LicenseledgerdetailsEscrowInfo {
    lastUpdated: string;
    serviceCores: string;
    tenantUuid: string;
    tier: string;
    uuid: string;
}

export interface LicenseledgerdetailsSeInfo {
    lastUpdated: string;
    serviceCores: string;
    tenantUuid: string;
    tier: string;
    uuid: string;
}

export interface LicenseledgerdetailsTierUsage {
    tier: string;
    usages?: outputs.LicenseledgerdetailsTierUsageUsage[];
}

export interface LicenseledgerdetailsTierUsageUsage {
    available?: string;
    consumed?: string;
    escrow?: string;
    remaining?: string;
}

export interface LicensestatusConfigpbAttribute {
    version: string;
}

export interface LicensestatusSaasStatus {
    connected: string;
    enabled: string;
    expired: string;
    message: string;
    name: string;
    publicKey: string;
    reserveServiceUnits: string;
}

export interface LicensestatusServiceUpdate {
    name: string;
    serviceUnits?: outputs.LicensestatusServiceUpdateServiceUnit[];
}

export interface LicensestatusServiceUpdateServiceUnit {
    availableServiceUnits: string;
    orgId: string;
    usedServiceUnits: string;
}

export interface MemorybalancerrequestConfigpbAttribute {
    version: string;
}

export interface MemorybalancerrequestControllerInfo {
    currentControllerMemUsage: string;
}

export interface MemorybalancerrequestProcessInfo {
    currentProcessId: string;
    currentProcessMemUsage: string;
    intimationCount: string;
    memoryLimit: string;
    memoryTrendUsage: string;
    processMode: string;
    thresholdPercent: string;
}

export interface MicroservicegroupConfigpbAttribute {
    version: string;
}

export interface NatpolicyConfigpbAttribute {
    version: string;
}

export interface NatpolicyMarker {
    key: string;
    values?: string[];
}

export interface NatpolicyRule {
    actions: outputs.NatpolicyRuleAction[];
    createdBy: string;
    enable: string;
    index: string;
    matches: outputs.NatpolicyRuleMatch[];
    name: string;
}

export interface NatpolicyRuleAction {
    natInfos?: outputs.NatpolicyRuleActionNatInfo[];
    type: string;
}

export interface NatpolicyRuleActionNatInfo {
    natIpRanges?: outputs.NatpolicyRuleActionNatInfoNatIpRange[];
    natIps?: outputs.NatpolicyRuleActionNatInfoNatIp[];
}

export interface NatpolicyRuleActionNatInfoNatIp {
    addr: string;
    type: string;
}

export interface NatpolicyRuleActionNatInfoNatIpRange {
    begins: outputs.NatpolicyRuleActionNatInfoNatIpRangeBegin[];
    ends: outputs.NatpolicyRuleActionNatInfoNatIpRangeEnd[];
}

export interface NatpolicyRuleActionNatInfoNatIpRangeBegin {
    addr: string;
    type: string;
}

export interface NatpolicyRuleActionNatInfoNatIpRangeEnd {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatch {
    destinationIps?: outputs.NatpolicyRuleMatchDestinationIp[];
    services?: outputs.NatpolicyRuleMatchService[];
    sourceIps?: outputs.NatpolicyRuleMatchSourceIp[];
}

export interface NatpolicyRuleMatchDestinationIp {
    addrs?: outputs.NatpolicyRuleMatchDestinationIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.NatpolicyRuleMatchDestinationIpPrefix[];
    ranges?: outputs.NatpolicyRuleMatchDestinationIpRange[];
}

export interface NatpolicyRuleMatchDestinationIpAddr {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatchDestinationIpPrefix {
    ipAddrs: outputs.NatpolicyRuleMatchDestinationIpPrefixIpAddr[];
    mask: string;
}

export interface NatpolicyRuleMatchDestinationIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatchDestinationIpRange {
    begins: outputs.NatpolicyRuleMatchDestinationIpRangeBegin[];
    ends: outputs.NatpolicyRuleMatchDestinationIpRangeEnd[];
}

export interface NatpolicyRuleMatchDestinationIpRangeBegin {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatchDestinationIpRangeEnd {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatchService {
    destinationPorts?: outputs.NatpolicyRuleMatchServiceDestinationPort[];
    protocols?: outputs.NatpolicyRuleMatchServiceProtocol[];
    sourcePorts?: outputs.NatpolicyRuleMatchServiceSourcePort[];
}

export interface NatpolicyRuleMatchServiceDestinationPort {
    matchCriteria: string;
    ports: number[];
}

export interface NatpolicyRuleMatchServiceProtocol {
    matchCriteria: string;
    protocol: string;
}

export interface NatpolicyRuleMatchServiceSourcePort {
    matchCriteria: string;
    ports: number[];
}

export interface NatpolicyRuleMatchSourceIp {
    addrs?: outputs.NatpolicyRuleMatchSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.NatpolicyRuleMatchSourceIpPrefix[];
    ranges?: outputs.NatpolicyRuleMatchSourceIpRange[];
}

export interface NatpolicyRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatchSourceIpPrefix {
    ipAddrs: outputs.NatpolicyRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface NatpolicyRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatchSourceIpRange {
    begins: outputs.NatpolicyRuleMatchSourceIpRangeBegin[];
    ends: outputs.NatpolicyRuleMatchSourceIpRangeEnd[];
}

export interface NatpolicyRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface NatpolicyRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface NetworkAttr {
    key: string;
    value: string;
}

export interface NetworkConfigpbAttribute {
    version: string;
}

export interface NetworkConfiguredSubnet {
    prefixes: outputs.NetworkConfiguredSubnetPrefix[];
    staticIpRanges?: outputs.NetworkConfiguredSubnetStaticIpRange[];
}

export interface NetworkConfiguredSubnetPrefix {
    ipAddrs: outputs.NetworkConfiguredSubnetPrefixIpAddr[];
    mask: string;
}

export interface NetworkConfiguredSubnetPrefixIpAddr {
    addr: string;
    type: string;
}

export interface NetworkConfiguredSubnetStaticIpRange {
    ranges: outputs.NetworkConfiguredSubnetStaticIpRangeRange[];
    type?: string;
}

export interface NetworkConfiguredSubnetStaticIpRangeRange {
    begins: outputs.NetworkConfiguredSubnetStaticIpRangeRangeBegin[];
    ends: outputs.NetworkConfiguredSubnetStaticIpRangeRangeEnd[];
}

export interface NetworkConfiguredSubnetStaticIpRangeRangeBegin {
    addr: string;
    type: string;
}

export interface NetworkConfiguredSubnetStaticIpRangeRangeEnd {
    addr: string;
    type: string;
}

export interface NetworkMarker {
    key: string;
    values?: string[];
}

export interface NetworkprofileConfigpbAttribute {
    version: string;
}

export interface NetworkprofileMarker {
    key: string;
    values?: string[];
}

export interface NetworkprofileProfile {
    sctpFastPathProfiles?: outputs.NetworkprofileProfileSctpFastPathProfile[];
    sctpProxyProfiles?: outputs.NetworkprofileProfileSctpProxyProfile[];
    tcpFastPathProfiles?: outputs.NetworkprofileProfileTcpFastPathProfile[];
    tcpProxyProfiles?: outputs.NetworkprofileProfileTcpProxyProfile[];
    type: string;
    udpFastPathProfiles?: outputs.NetworkprofileProfileUdpFastPathProfile[];
    udpProxyProfiles?: outputs.NetworkprofileProfileUdpProxyProfile[];
}

export interface NetworkprofileProfileSctpFastPathProfile {
    enableInitChunkProtection?: string;
    idleTimeout?: string;
}

export interface NetworkprofileProfileSctpProxyProfile {
    cookieExpirationTimeout?: string;
    heartbeatInterval?: string;
    idleTimeout?: string;
    maxRetransmissionsAssociation?: string;
    maxRetransmissionsInitChunks?: string;
    numberOfStreams?: string;
    receiveWindow?: string;
    resetTimeout?: string;
}

export interface NetworkprofileProfileTcpFastPathProfile {
    dsrProfiles?: outputs.NetworkprofileProfileTcpFastPathProfileDsrProfile[];
    enableSynProtection?: string;
    sessionIdleTimeout?: string;
}

export interface NetworkprofileProfileTcpFastPathProfileDsrProfile {
    dsrEncapType?: string;
    dsrType?: string;
}

export interface NetworkprofileProfileTcpProxyProfile {
    aggressiveCongestionAvoidance?: string;
    autoWindowGrowth?: string;
    automatic?: string;
    ccAlgo?: string;
    congestionRecoveryScalingFactor?: string;
    idleConnectionTimeout?: string;
    idleConnectionType?: string;
    ignoreTimeWait?: string;
    ipDscp?: string;
    keepaliveInHalfcloseState?: string;
    maxRetransmissions?: string;
    maxSegmentSize: string;
    maxSynRetransmissions?: string;
    minRexmtTimeout: string;
    naglesAlgorithm?: string;
    reassemblyQueueSize?: string;
    receiveWindow?: string;
    reorderThreshold: string;
    slowStartScalingFactor?: string;
    timeWaitDelay?: string;
    useInterfaceMtu?: string;
}

export interface NetworkprofileProfileUdpFastPathProfile {
    dsrProfiles?: outputs.NetworkprofileProfileUdpFastPathProfileDsrProfile[];
    perPktLoadbalance?: string;
    sessionIdleTimeout?: string;
    snat?: string;
}

export interface NetworkprofileProfileUdpFastPathProfileDsrProfile {
    dsrEncapType?: string;
    dsrType?: string;
}

export interface NetworkprofileProfileUdpProxyProfile {
    sessionIdleTimeout?: string;
}

export interface NetworksecuritypolicyConfigpbAttribute {
    version: string;
}

export interface NetworksecuritypolicyMarker {
    key: string;
    values?: string[];
}

export interface NetworksecuritypolicyRule {
    action: string;
    age?: string;
    createdBy: string;
    enable: string;
    index: string;
    log?: string;
    matches: outputs.NetworksecuritypolicyRuleMatch[];
    name: string;
    rlParams?: outputs.NetworksecuritypolicyRuleRlParam[];
}

export interface NetworksecuritypolicyRuleMatch {
    clientIps?: outputs.NetworksecuritypolicyRuleMatchClientIp[];
    clientPorts?: outputs.NetworksecuritypolicyRuleMatchClientPort[];
    geoMatches?: outputs.NetworksecuritypolicyRuleMatchGeoMatch[];
    ipReputationTypes?: outputs.NetworksecuritypolicyRuleMatchIpReputationType[];
    microservices?: outputs.NetworksecuritypolicyRuleMatchMicroservice[];
    vsPorts?: outputs.NetworksecuritypolicyRuleMatchVsPort[];
}

export interface NetworksecuritypolicyRuleMatchClientIp {
    addrs?: outputs.NetworksecuritypolicyRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.NetworksecuritypolicyRuleMatchClientIpPrefix[];
    ranges?: outputs.NetworksecuritypolicyRuleMatchClientIpRange[];
}

export interface NetworksecuritypolicyRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface NetworksecuritypolicyRuleMatchClientIpPrefix {
    ipAddrs: outputs.NetworksecuritypolicyRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface NetworksecuritypolicyRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface NetworksecuritypolicyRuleMatchClientIpRange {
    begins: outputs.NetworksecuritypolicyRuleMatchClientIpRangeBegin[];
    ends: outputs.NetworksecuritypolicyRuleMatchClientIpRangeEnd[];
}

export interface NetworksecuritypolicyRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface NetworksecuritypolicyRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface NetworksecuritypolicyRuleMatchClientPort {
    matchCriteria: string;
    ports?: number[];
    ranges?: outputs.NetworksecuritypolicyRuleMatchClientPortRange[];
}

export interface NetworksecuritypolicyRuleMatchClientPortRange {
    end: string;
    start: string;
}

export interface NetworksecuritypolicyRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface NetworksecuritypolicyRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface NetworksecuritypolicyRuleMatchMicroservice {
    groupRef: string;
    matchCriteria: string;
}

export interface NetworksecuritypolicyRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface NetworksecuritypolicyRuleRlParam {
    burstSize: string;
    maxRate: string;
}

export interface NetworkserviceConfigpbAttribute {
    version: string;
}

export interface NetworkserviceMarker {
    key: string;
    values?: string[];
}

export interface NetworkserviceRoutingService {
    advertiseBackendNetworks?: string;
    enableAutoGateway?: string;
    enableRouting?: string;
    enableVipOnAllInterfaces?: string;
    enableVmac?: string;
    floatingIntfIp6Addresses?: outputs.NetworkserviceRoutingServiceFloatingIntfIp6Address[];
    floatingIntfIp6Se2Addresses?: outputs.NetworkserviceRoutingServiceFloatingIntfIp6Se2Address[];
    floatingIntfIpSe2s?: outputs.NetworkserviceRoutingServiceFloatingIntfIpSe2[];
    floatingIntfIps?: outputs.NetworkserviceRoutingServiceFloatingIntfIp[];
    flowtableProfiles?: outputs.NetworkserviceRoutingServiceFlowtableProfile[];
    gracefulRestart?: string;
    natPolicyRef: string;
    routingByLinuxIpstack?: string;
}

export interface NetworkserviceRoutingServiceFloatingIntfIp {
    addr: string;
    type: string;
}

export interface NetworkserviceRoutingServiceFloatingIntfIp6Address {
    addr: string;
    type: string;
}

export interface NetworkserviceRoutingServiceFloatingIntfIp6Se2Address {
    addr: string;
    type: string;
}

export interface NetworkserviceRoutingServiceFloatingIntfIpSe2 {
    addr: string;
    type: string;
}

export interface NetworkserviceRoutingServiceFlowtableProfile {
    icmpIdleTimeout?: string;
    tcpClosedTimeout?: string;
    tcpConnectionSetupTimeout?: string;
    tcpHalfClosedTimeout?: string;
    tcpIdleTimeout?: string;
    tcpResetTimeout?: string;
    udpIdleTimeout?: string;
}

export interface PkiprofileCaCert {
    certificate: string;
    certificateSigningRequest: string;
    chainVerified: string;
    daysUntilExpire?: string;
    expiryStatus?: string;
    fingerprint: string;
    issuers?: outputs.PkiprofileCaCertIssuer[];
    keyParams?: outputs.PkiprofileCaCertKeyParam[];
    notAfter: string;
    notBefore: string;
    publicKey: string;
    selfSigned: string;
    serialNumber: string;
    signature: string;
    signatureAlgorithm: string;
    subjectAltNames?: string[];
    subjects?: outputs.PkiprofileCaCertSubject[];
    text: string;
    version: string;
}

export interface PkiprofileCaCertIssuer {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface PkiprofileCaCertKeyParam {
    algorithm: string;
    ecParams?: outputs.PkiprofileCaCertKeyParamEcParam[];
    rsaParams?: outputs.PkiprofileCaCertKeyParamRsaParam[];
}

export interface PkiprofileCaCertKeyParamEcParam {
    curve?: string;
}

export interface PkiprofileCaCertKeyParamRsaParam {
    exponent?: string;
    keySize?: string;
}

export interface PkiprofileCaCertSubject {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface PkiprofileConfigpbAttribute {
    version: string;
}

export interface PkiprofileMarker {
    key: string;
    values?: string[];
}

export interface PoolAnalyticsPolicy {
    enableRealtimeMetrics?: string;
}

export interface PoolConfigpbAttribute {
    version: string;
}

export interface PoolConnPoolProperty {
    upstreamConnpoolConnIdleTmo?: string;
    upstreamConnpoolConnLifeTmo?: string;
    upstreamConnpoolConnMaxReuse?: string;
    upstreamConnpoolServerMaxCache?: string;
}

export interface PoolFailAction {
    localRsps?: outputs.PoolFailActionLocalRsp[];
    redirects?: outputs.PoolFailActionRedirect[];
    type: string;
}

export interface PoolFailActionLocalRsp {
    files?: outputs.PoolFailActionLocalRspFile[];
    statusCode?: string;
}

export interface PoolFailActionLocalRspFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface PoolFailActionRedirect {
    host: string;
    path: string;
    protocol?: string;
    query: string;
    statusCode?: string;
}

export interface PoolHorizonProfile {
    blastPort?: string;
    pcoipPort?: string;
}

export interface PoolHttp2Property {
    maxHttp2ControlFramesPerConnection?: string;
    maxHttp2HeaderFieldSize?: string;
}

export interface PoolMarker {
    key: string;
    values?: string[];
}

export interface PoolMaxConnRatePerServer {
    actions: outputs.PoolMaxConnRatePerServerAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.PoolMaxConnRatePerServerRateLimiter[];
}

export interface PoolMaxConnRatePerServerAction {
    files?: outputs.PoolMaxConnRatePerServerActionFile[];
    redirects?: outputs.PoolMaxConnRatePerServerActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface PoolMaxConnRatePerServerActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface PoolMaxConnRatePerServerActionRedirect {
    addString: string;
    hosts?: outputs.PoolMaxConnRatePerServerActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.PoolMaxConnRatePerServerActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface PoolMaxConnRatePerServerActionRedirectHost {
    tokens: outputs.PoolMaxConnRatePerServerActionRedirectHostToken[];
    type: string;
}

export interface PoolMaxConnRatePerServerActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface PoolMaxConnRatePerServerActionRedirectPath {
    tokens: outputs.PoolMaxConnRatePerServerActionRedirectPathToken[];
    type: string;
}

export interface PoolMaxConnRatePerServerActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface PoolMaxConnRatePerServerRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface PoolNetwork {
    networkRef: string;
    serverFilter: string;
}

export interface PoolPlacementNetwork {
    networkRef: string;
    subnets: outputs.PoolPlacementNetworkSubnet[];
}

export interface PoolPlacementNetworkSubnet {
    ipAddrs: outputs.PoolPlacementNetworkSubnetIpAddr[];
    mask: string;
}

export interface PoolPlacementNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface PoolServer {
    autoscalingGroupName: string;
    availabilityZone: string;
    description: string;
    discoveredNetworks?: outputs.PoolServerDiscoveredNetwork[];
    enabled?: string;
    externalOrchestrationId: string;
    externalUuid: string;
    hostname: string;
    ips: outputs.PoolServerIp[];
    locations?: outputs.PoolServerLocation[];
    macAddress: string;
    nwRef: string;
    port: string;
    preferenceOrder: string;
    prstHdrVal: string;
    ratio?: string;
    resolveServerByDns?: string;
    rewriteHostHeader?: string;
    serverNode: string;
    static?: string;
    verifyNetwork?: string;
    vmRef: string;
}

export interface PoolServerDiscoveredNetwork {
    networkRef: string;
    subnet6s?: outputs.PoolServerDiscoveredNetworkSubnet6[];
    subnets?: outputs.PoolServerDiscoveredNetworkSubnet[];
}

export interface PoolServerDiscoveredNetworkSubnet {
    ipAddrs: outputs.PoolServerDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface PoolServerDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.PoolServerDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface PoolServerDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface PoolServerDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface PoolServerIp {
    addr: string;
    type: string;
}

export interface PoolServerLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface PoolServerReselect {
    enabled: string;
    numRetries?: string;
    retryNonidempotent?: string;
    retryTimeout?: string;
    svrRespCodes?: outputs.PoolServerReselectSvrRespCode[];
}

export interface PoolServerReselectSvrRespCode {
    codes?: number[];
    ranges?: outputs.PoolServerReselectSvrRespCodeRange[];
    respCodeBlocks?: string[];
}

export interface PoolServerReselectSvrRespCodeRange {
    begin: string;
    end: string;
}

export interface PoolSpGsInfo {
    fqdns?: string[];
    gsRef: string;
}

export interface PoolgroupConfigpbAttribute {
    version: string;
}

export interface PoolgroupFailAction {
    localRsps?: outputs.PoolgroupFailActionLocalRsp[];
    redirects?: outputs.PoolgroupFailActionRedirect[];
    type: string;
}

export interface PoolgroupFailActionLocalRsp {
    files?: outputs.PoolgroupFailActionLocalRspFile[];
    statusCode?: string;
}

export interface PoolgroupFailActionLocalRspFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface PoolgroupFailActionRedirect {
    host: string;
    path: string;
    protocol?: string;
    query: string;
    statusCode?: string;
}

export interface PoolgroupMarker {
    key: string;
    values?: string[];
}

export interface PoolgroupMember {
    deploymentState: string;
    poolRef: string;
    priorityLabel: string;
    ratio?: string;
}

export interface PoolgroupdeploymentpolicyConfigpbAttribute {
    version: string;
}

export interface PoolgroupdeploymentpolicyMarker {
    key: string;
    values?: string[];
}

export interface PoolgroupdeploymentpolicyRule {
    metricId?: string;
    operator?: string;
    threshold: string;
}

export interface PrioritylabelsConfigpbAttribute {
    version: string;
}

export interface PrioritylabelsEquivalentLabel {
    labels?: string[];
}

export interface PrioritylabelsMarker {
    key: string;
    values?: string[];
}

export interface ProtocolparserConfigpbAttribute {
    version: string;
}

export interface ProtocolparserMarker {
    key: string;
    values?: string[];
}

export interface RoleConfigpbAttribute {
    version: string;
}

export interface RoleFilter {
    enabled?: string;
    matchLabels: outputs.RoleFilterMatchLabel[];
    matchOperation?: string;
    name: string;
}

export interface RoleFilterMatchLabel {
    key: string;
    values?: string[];
}

export interface RolePrivilege {
    resource: string;
    subresources?: outputs.RolePrivilegeSubresource[];
    type: string;
}

export interface RolePrivilegeSubresource {
    excludeSubresources?: string;
    subresources: string[];
}

export interface SchedulerConfigpbAttribute {
    version: string;
}

export interface SecuritymanagerdataAppLearningInfo {
    appId: string;
    uriInfos?: outputs.SecuritymanagerdataAppLearningInfoUriInfo[];
    vsUuid: string;
}

export interface SecuritymanagerdataAppLearningInfoUriInfo {
    paramInfos?: outputs.SecuritymanagerdataAppLearningInfoUriInfoParamInfo[];
    uriHits: string;
    uriKey: string;
}

export interface SecuritymanagerdataAppLearningInfoUriInfoParamInfo {
    paramHits: string;
    paramKey: string;
    paramSizeClasses?: outputs.SecuritymanagerdataAppLearningInfoUriInfoParamInfoParamSizeClass[];
    paramTypeClasses?: outputs.SecuritymanagerdataAppLearningInfoUriInfoParamInfoParamTypeClass[];
}

export interface SecuritymanagerdataAppLearningInfoUriInfoParamInfoParamSizeClass {
    hits: string;
    len: string;
}

export interface SecuritymanagerdataAppLearningInfoUriInfoParamInfoParamTypeClass {
    hits: string;
    type: string;
}

export interface SecuritypolicyConfigpbAttribute {
    version: string;
}

export interface SecuritypolicyDnsAmplificationDenyport {
    matchCriteria: string;
    ports?: number[];
    ranges?: outputs.SecuritypolicyDnsAmplificationDenyportRange[];
}

export interface SecuritypolicyDnsAmplificationDenyportRange {
    end: string;
    start: string;
}

export interface SecuritypolicyDnsAttack {
    attacks?: outputs.SecuritypolicyDnsAttackAttack[];
    operMode: string;
}

export interface SecuritypolicyDnsAttackAttack {
    attackVector: string;
    enabled?: string;
    maxMitigationAge?: string;
    mitigationActions?: outputs.SecuritypolicyDnsAttackAttackMitigationAction[];
    threshold: string;
}

export interface SecuritypolicyDnsAttackAttackMitigationAction {
    deny?: string;
}

export interface SecuritypolicyMarker {
    key: string;
    values?: string[];
}

export interface SecuritypolicyTcpAttack {
}

export interface SecuritypolicyUdpAttack {
}

export interface SepropertiesConfigpbAttribute {
    version: string;
}

export interface SepropertiesSeAgentProperty {
    controllerEchoMissAggressiveLimit?: string;
    controllerEchoMissLimit?: string;
    controllerEchoRpcAggressiveTimeout?: string;
    controllerEchoRpcTimeout?: string;
    controllerHeartbeatMissLimit?: string;
    controllerHeartbeatTimeoutSec?: string;
    controllerRegistrationTimeoutSec?: string;
    controllerRpcTimeout?: string;
    cpustatsInterval?: string;
    ctrlRegPendingMaxWaitTime?: string;
    debugMode?: string;
    dpAggressiveDeqIntervalMsec?: string;
    dpAggressiveEnqIntervalMsec?: string;
    dpBatchSize?: string;
    dpDeqIntervalMsec?: string;
    dpEnqIntervalMsec?: string;
    dpMaxWaitRspTimeSec?: string;
    dpRegPendingMaxWaitTime?: string;
    headlessTimeoutSec?: string;
    ignoreDockerMacChange?: string;
    nsHelperDeqIntervalMsec?: string;
    sdbFlushInterval?: string;
    sdbPipelineSize?: string;
    sdbScanCount?: string;
    seGrpChangeDisruptive?: string;
    seagentStatecacheProperties?: outputs.SepropertiesSeAgentPropertySeagentStatecacheProperty[];
    sendSeReadyTimeout?: string;
    statesFlushInterval?: string;
    vnicDhcpIpCheckInterval?: string;
    vnicDhcpIpMaxRetries?: string;
    vnicIpDeleteInterval?: string;
    vnicProbeInterval?: string;
    vnicRpcRetryInterval?: string;
    vnicdbCmdHistorySize?: string;
}

export interface SepropertiesSeAgentPropertySeagentStatecacheProperty {
    scBatchBufferFlushLimit?: string;
    scCfgQBatchDequeueLimit?: string;
    scCfgQMaxSize?: string;
    scDnsQBatchDequeueLimit?: string;
    scDnsQMaxSize?: string;
    scShardCleanupMaxTime?: string;
    scStateRingBatchDequeueLimit?: string;
    scStatesFlushInterval?: string;
    scStreamCheckInterval?: string;
    scThreadQBatchDequeueLimit?: string;
    scThreadQMaxSize?: string;
    scThreadSleepInterval?: string;
}

export interface SepropertiesSeBootupProperty {
    dockerBackendPortend?: string;
    dockerBackendPortstart?: string;
    fairQueueingEnabled?: string;
    geoDbGranularity?: string;
    l7ConnsPerCore?: string;
    l7ResvdListenConnsPerCore?: string;
    logAgentDebugEnabled?: string;
    logAgentTraceEnabled?: string;
    seDpCompressions?: outputs.SepropertiesSeBootupPropertySeDpCompression[];
    seEmulatedCores?: string;
    seIpEncapIpc?: string;
    seL3EncapIpc?: string;
    seLogBufferAppBlockingDequeue?: string;
    seLogBufferApplogSize?: string;
    seLogBufferChunkCount?: string;
    seLogBufferConnBlockingDequeue?: string;
    seLogBufferConnlogSize?: string;
    seLogBufferEventsBlockingDequeue?: string;
    seLogBufferEventsSize?: string;
    sslSessCachePerVs?: string;
    tcpSyncacheHashsize?: string;
}

export interface SepropertiesSeBootupPropertySeDpCompression {
    bufNum?: string;
    bufSize?: string;
    hashSize?: string;
    levelAggressive?: string;
    levelNormal?: string;
    windowSize?: string;
}

export interface SepropertiesSeRuntimeProperty {
    adminSshEnabled?: string;
    appHeaders?: outputs.SepropertiesSeRuntimePropertyAppHeader[];
    baremetalDispatcherHandlesFlows?: string;
    connectionsLossyLogRateLimiterThreshold?: string;
    connectionsUdfnfLogRateLimiterThreshold?: string;
    disableFlowProbes?: string;
    dosProfiles?: outputs.SepropertiesSeRuntimePropertyDosProfile[];
    downstreamSendTimeout?: string;
    dpAggressiveHbFrequency?: string;
    dpAggressiveHbTimeoutCount?: string;
    dpHbFrequency?: string;
    dpHbTimeoutCount?: string;
    dupipFrequency?: string;
    dupipTimeoutCount?: string;
    enableHsmLog?: string;
    feproxyVipsEnableProxyArp?: string;
    flowTableBatchPushFrequency?: string;
    globalMtu?: string;
    httpRumConsoleLog?: string;
    httpRumMinContentLength?: string;
    lbactionNumRequestsToDispatch?: string;
    lbactionRqPerRequestMaxRetries?: string;
    logAgentCompressLogs?: string;
    logAgentFileSzAppl?: string;
    logAgentFileSzConn?: string;
    logAgentFileSzDebug?: string;
    logAgentFileSzEvent?: string;
    logAgentLogStorageMinSz?: string;
    logAgentMaxConcurrentRsync?: string;
    logAgentMaxStorageExcessPercent?: string;
    logAgentMaxStorageIgnorePercent?: string;
    logAgentMinStoragePerVs?: string;
    logAgentSleepInterval?: string;
    logAgentUnknownVsTimer?: string;
    logMessageMaxFileListSize?: string;
    ngxFreeConnectionStack?: string;
    persistenceMemMax?: string;
    scaleoutUdpPerPkt?: string;
    seAuthLdapBindTimeout?: string;
    seAuthLdapCacheSize?: string;
    seAuthLdapConnectTimeout?: string;
    seAuthLdapConnsPerServer?: string;
    seAuthLdapReconnectTimeout?: string;
    seAuthLdapRequestTimeout?: string;
    seAuthLdapServersFailoverOnly?: string;
    seDpCompressions?: outputs.SepropertiesSeRuntimePropertySeDpCompression[];
    seDpHmDrops?: string;
    seDpIfStatePollInterval?: string;
    seDpLogNfEnqueuePercent?: string;
    seDpLogUdfEnqueuePercent?: string;
    seDumpCoreOnAssert?: string;
    seHandleInterfaceRoutes?: string;
    seHbPersistFudgeBits?: string;
    seMacErrorThresholdToDisablePromiscious?: string;
    seMemoryPoison?: string;
    seMetricsInterval?: string;
    seMetricsRtEnabled?: string;
    seMetricsRtInterval?: string;
    sePacketBufferMax?: string;
    seRandomTcpDrops?: string;
    seRateLimiters?: outputs.SepropertiesSeRuntimePropertySeRateLimiter[];
    serviceIpSubnets?: outputs.SepropertiesSeRuntimePropertyServiceIpSubnet[];
    servicePortRanges?: outputs.SepropertiesSeRuntimePropertyServicePortRange[];
    servicesAccessibleAllInterfaces?: string;
    tcpSyncacheMaxRetransmitDefault?: string;
    upstreamConnectTimeout?: string;
    upstreamConnpoolCacheThresh?: string;
    upstreamConnpoolConnIdleThreshTmo?: string;
    upstreamConnpoolCoreMaxCache?: string;
    upstreamConnpoolEnable?: string;
    upstreamKeepalive?: string;
    upstreamReadTimeout?: string;
    upstreamSendTimeout?: string;
    userDefinedMetricAge?: string;
}

export interface SepropertiesSeRuntimePropertyAppHeader {
    hdrMatchCase: string;
    hdrName: string;
    hdrStringOp: string;
}

export interface SepropertiesSeRuntimePropertyDosProfile {
    threshInfos?: outputs.SepropertiesSeRuntimePropertyDosProfileThreshInfo[];
    threshPeriod: string;
}

export interface SepropertiesSeRuntimePropertyDosProfileThreshInfo {
    attack: string;
    maxValue: string;
    minValue: string;
}

export interface SepropertiesSeRuntimePropertySeDpCompression {
    maxLowRtt?: string;
    minHighRtt?: string;
    minLength?: string;
    mobileStrs?: string[];
}

export interface SepropertiesSeRuntimePropertySeRateLimiter {
    arpRl?: string;
    defaultRl?: string;
    flowProbeRl?: string;
    icmpRl?: string;
    icmpRspRl?: string;
    rstRl?: string;
}

export interface SepropertiesSeRuntimePropertyServiceIpSubnet {
    ipAddrs: outputs.SepropertiesSeRuntimePropertyServiceIpSubnetIpAddr[];
    mask: string;
}

export interface SepropertiesSeRuntimePropertyServiceIpSubnetIpAddr {
    addr: string;
    type: string;
}

export interface SepropertiesSeRuntimePropertyServicePortRange {
    end: string;
    start: string;
}

export interface ServerDiscoveredNetwork {
    networkRef: string;
    subnet6s?: outputs.ServerDiscoveredNetworkSubnet6[];
    subnets?: outputs.ServerDiscoveredNetworkSubnet[];
}

export interface ServerDiscoveredNetworkSubnet {
    ipAddrs: outputs.ServerDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface ServerDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.ServerDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface ServerDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface ServerDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface ServerLocation {
    latitude: string;
    longitude: string;
    name: string;
    tag: string;
}

export interface ServerautoscalepolicyConfigpbAttribute {
    version: string;
}

export interface ServerautoscalepolicyMarker {
    key: string;
    values?: string[];
}

export interface ServerautoscalepolicyScheduledScaling {
    autoscalingDuration?: string;
    cronExpression: string;
    desiredCapacity: string;
    enable?: string;
    endDate: string;
    scheduleMaxStep?: string;
    startDate: string;
}

export interface ServiceauthprofileConfigpbAttribute {
    version: string;
}

export interface ServiceauthprofileServiceOauthProfile {
    authorizationEndpoint: string;
    clientId: string;
    orgId: string;
    serviceId: string;
    serviceName: string;
}

export interface ServiceengineDataVnic {
    adapter: string;
    aggregatorChgd?: string;
    canSeDpTakeover?: string;
    connected: string;
    delPending?: string;
    deleteVnic?: string;
    dhcpEnabled?: string;
    dpDeletionDone?: string;
    enabled?: string;
    ifName: string;
    ip6AutocfgEnabled?: string;
    isAsm?: string;
    isAviInternalNetwork?: string;
    isHsm?: string;
    isMgmt?: string;
    isPortchannel?: string;
    linkUp?: string;
    linuxName: string;
    macAddress: string;
    members?: outputs.ServiceengineDataVnicMember[];
    mtu?: string;
    networkName: string;
    networkRef: string;
    numRxDescriptors: string;
    numTxDescriptors: string;
    pciId: string;
    portUuid: string;
    vlanId?: string;
    vlanInterfaces?: outputs.ServiceengineDataVnicVlanInterface[];
    vnicNetworks?: outputs.ServiceengineDataVnicVnicNetwork[];
    vrfId?: string;
    vrfRef: string;
}

export interface ServiceengineDataVnicMember {
    active?: string;
    ifName: string;
    macAddress: string;
}

export interface ServiceengineDataVnicVlanInterface {
    dhcpEnabled: string;
    enabled?: string;
    ifName: string;
    ip6AutocfgEnabled: string;
    isMgmt?: string;
    vlanId?: string;
    vnicNetworks?: outputs.ServiceengineDataVnicVlanInterfaceVnicNetwork[];
    vrfRef: string;
}

export interface ServiceengineDataVnicVlanInterfaceVnicNetwork {
    ctlrAlloc?: string;
    ips: outputs.ServiceengineDataVnicVlanInterfaceVnicNetworkIp[];
    mode: string;
}

export interface ServiceengineDataVnicVlanInterfaceVnicNetworkIp {
    ipAddrs: outputs.ServiceengineDataVnicVlanInterfaceVnicNetworkIpIpAddr[];
    mask: string;
}

export interface ServiceengineDataVnicVlanInterfaceVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface ServiceengineDataVnicVnicNetwork {
    ctlrAlloc?: string;
    ips: outputs.ServiceengineDataVnicVnicNetworkIp[];
    mode: string;
}

export interface ServiceengineDataVnicVnicNetworkIp {
    ipAddrs: outputs.ServiceengineDataVnicVnicNetworkIpIpAddr[];
    mask: string;
}

export interface ServiceengineDataVnicVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface ServiceengineMgmtVnic {
    adapter: string;
    aggregatorChgd?: string;
    canSeDpTakeover?: string;
    connected: string;
    delPending?: string;
    deleteVnic?: string;
    dhcpEnabled?: string;
    dpDeletionDone?: string;
    enabled?: string;
    ifName: string;
    ip6AutocfgEnabled?: string;
    isAsm?: string;
    isAviInternalNetwork?: string;
    isHsm?: string;
    isMgmt?: string;
    isPortchannel?: string;
    linkUp?: string;
    linuxName: string;
    macAddress: string;
    members?: outputs.ServiceengineMgmtVnicMember[];
    mtu?: string;
    networkName: string;
    networkRef: string;
    numRxDescriptors: string;
    numTxDescriptors: string;
    pciId: string;
    portUuid: string;
    vlanId?: string;
    vlanInterfaces?: outputs.ServiceengineMgmtVnicVlanInterface[];
    vnicNetworks?: outputs.ServiceengineMgmtVnicVnicNetwork[];
    vrfId?: string;
    vrfRef: string;
}

export interface ServiceengineMgmtVnicMember {
    active?: string;
    ifName: string;
    macAddress: string;
}

export interface ServiceengineMgmtVnicVlanInterface {
    dhcpEnabled: string;
    enabled?: string;
    ifName: string;
    ip6AutocfgEnabled: string;
    isMgmt?: string;
    vlanId?: string;
    vnicNetworks?: outputs.ServiceengineMgmtVnicVlanInterfaceVnicNetwork[];
    vrfRef: string;
}

export interface ServiceengineMgmtVnicVlanInterfaceVnicNetwork {
    ctlrAlloc?: string;
    ips: outputs.ServiceengineMgmtVnicVlanInterfaceVnicNetworkIp[];
    mode: string;
}

export interface ServiceengineMgmtVnicVlanInterfaceVnicNetworkIp {
    ipAddrs: outputs.ServiceengineMgmtVnicVlanInterfaceVnicNetworkIpIpAddr[];
    mask: string;
}

export interface ServiceengineMgmtVnicVlanInterfaceVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface ServiceengineMgmtVnicVnicNetwork {
    ctlrAlloc?: string;
    ips: outputs.ServiceengineMgmtVnicVnicNetworkIp[];
    mode: string;
}

export interface ServiceengineMgmtVnicVnicNetworkIp {
    ipAddrs: outputs.ServiceengineMgmtVnicVnicNetworkIpIpAddr[];
    mask: string;
}

export interface ServiceengineMgmtVnicVnicNetworkIpIpAddr {
    addr: string;
    type: string;
}

export interface ServiceengineResource {
    coresPerSocket: string;
    disk: string;
    hyperThreading: string;
    hypervisorMode: string;
    memory: string;
    numDatapathProcesses: string;
    numVcpus: string;
    sockets: string;
}

export interface ServiceenginegroupConfigpbAttribute {
    version: string;
}

export interface ServiceenginegroupCustomTag {
    tagKey: string;
    tagVal: string;
}

export interface ServiceenginegroupGcpConfig {
    backendDataVpcNetworkName: string;
    backendDataVpcProjectId: string;
    backendDataVpcSubnetName: string;
}

export interface ServiceenginegroupInstanceFlavorInfo {
    cost: string;
    diskGb: string;
    enhancedNw: string;
    id: string;
    isRecommended: string;
    maxIp6sPerNic: string;
    maxIpsPerNic: string;
    maxNics: string;
    metas?: outputs.ServiceenginegroupInstanceFlavorInfoMeta[];
    name: string;
    public?: string;
    ramMb: string;
    vcpus: string;
}

export interface ServiceenginegroupInstanceFlavorInfoMeta {
    key: string;
    value: string;
}

export interface ServiceenginegroupIptable {
    chain: string;
    rules?: outputs.ServiceenginegroupIptableRule[];
    table: string;
}

export interface ServiceenginegroupIptableRule {
    action: string;
    dnatIps?: outputs.ServiceenginegroupIptableRuleDnatIp[];
    dstIps?: outputs.ServiceenginegroupIptableRuleDstIp[];
    dstPorts?: outputs.ServiceenginegroupIptableRuleDstPort[];
    inputInterface: string;
    outputInterface: string;
    proto: string;
    srcIps?: outputs.ServiceenginegroupIptableRuleSrcIp[];
    srcPorts?: outputs.ServiceenginegroupIptableRuleSrcPort[];
    tag: string;
}

export interface ServiceenginegroupIptableRuleDnatIp {
    addr: string;
    type: string;
}

export interface ServiceenginegroupIptableRuleDstIp {
    ipAddrs: outputs.ServiceenginegroupIptableRuleDstIpIpAddr[];
    mask: string;
}

export interface ServiceenginegroupIptableRuleDstIpIpAddr {
    addr: string;
    type: string;
}

export interface ServiceenginegroupIptableRuleDstPort {
    end: string;
    start: string;
}

export interface ServiceenginegroupIptableRuleSrcIp {
    ipAddrs: outputs.ServiceenginegroupIptableRuleSrcIpIpAddr[];
    mask: string;
}

export interface ServiceenginegroupIptableRuleSrcIpIpAddr {
    addr: string;
    type: string;
}

export interface ServiceenginegroupIptableRuleSrcPort {
    end: string;
    start: string;
}

export interface ServiceenginegroupKniAllowedServerPort {
    protocol: string;
    ranges: outputs.ServiceenginegroupKniAllowedServerPortRange[];
}

export interface ServiceenginegroupKniAllowedServerPortRange {
    end: string;
    start: string;
}

export interface ServiceenginegroupLabel {
    key: string;
    value: string;
}

export interface ServiceenginegroupMarker {
    key: string;
    values?: string[];
}

export interface ServiceenginegroupMgmtSubnet {
    ipAddrs: outputs.ServiceenginegroupMgmtSubnetIpAddr[];
    mask: string;
}

export interface ServiceenginegroupMgmtSubnetIpAddr {
    addr: string;
    type: string;
}

export interface ServiceenginegroupObjsyncConfig {
    objsyncCpuLimit?: string;
    objsyncHubElectInterval?: string;
    objsyncReconcileInterval?: string;
}

export interface ServiceenginegroupRealtimeSeMetric {
    duration?: string;
    enabled: string;
}

export interface ServiceenginegroupSeDosProfile {
    threshInfos?: outputs.ServiceenginegroupSeDosProfileThreshInfo[];
    threshPeriod: string;
}

export interface ServiceenginegroupSeDosProfileThreshInfo {
    attack: string;
    maxValue: string;
    minValue: string;
}

export interface ServiceenginegroupSeGroupAnalyticsPolicy {
    metricsEventThresholds?: outputs.ServiceenginegroupSeGroupAnalyticsPolicyMetricsEventThreshold[];
}

export interface ServiceenginegroupSeGroupAnalyticsPolicyMetricsEventThreshold {
    metricsEventThresholdType: string;
    resetThreshold: string;
    watermarkThresholds?: number[];
}

export interface ServiceenginegroupSeRlProp {
    msfNumStages?: string;
    msfStageSize?: string;
}

export interface ServiceenginegroupSeTimeTrackerProp {
    egressAuditMode?: string;
    egressThreshold?: string;
    eventGenWindow?: string;
    ingressAuditMode?: string;
    ingressThreshold?: string;
}

export interface ServiceenginegroupSeTracertPortRange {
    end: string;
    start: string;
}

export interface ServiceenginegroupServiceIp6Subnet {
    ipAddrs: outputs.ServiceenginegroupServiceIp6SubnetIpAddr[];
    mask: string;
}

export interface ServiceenginegroupServiceIp6SubnetIpAddr {
    addr: string;
    type: string;
}

export interface ServiceenginegroupServiceIpSubnet {
    ipAddrs: outputs.ServiceenginegroupServiceIpSubnetIpAddr[];
    mask: string;
}

export interface ServiceenginegroupServiceIpSubnetIpAddr {
    addr: string;
    type: string;
}

export interface ServiceenginegroupUserAgentCacheConfig {
    batchSize?: string;
    controllerCacheSize?: string;
    maxAge?: string;
    maxLastHitTime?: string;
    maxUpstreamQueries?: string;
    maxWaitTime?: string;
    numEntriesUpstreamUpdate?: string;
    percentReservedForBadBots?: string;
    percentReservedForBrowsers?: string;
    percentReservedForGoodBots?: string;
    percentReservedForOutstanding?: string;
    seCacheSize?: string;
    upstreamUpdateInterval?: string;
}

export interface ServiceenginegroupVcenter {
    clusters?: outputs.ServiceenginegroupVcenterCluster[];
    nsxtClusters?: outputs.ServiceenginegroupVcenterNsxtCluster[];
    nsxtDatastores?: outputs.ServiceenginegroupVcenterNsxtDatastore[];
    nsxtHosts?: outputs.ServiceenginegroupVcenterNsxtHost[];
    vcenterFolder: string;
    vcenterRef: string;
}

export interface ServiceenginegroupVcenterCluster {
    clusterId: string;
    overrideVsphereHa?: string;
    vmgName: string;
}

export interface ServiceenginegroupVcenterDatastore {
    datastoreName: string;
    managedObjectId: string;
}

export interface ServiceenginegroupVcenterHost {
    hostRefs?: string[];
    include?: string;
}

export interface ServiceenginegroupVcenterNsxtCluster {
    clusterIds?: string[];
    include?: string;
}

export interface ServiceenginegroupVcenterNsxtDatastore {
    dsIds?: string[];
    include?: string;
}

export interface ServiceenginegroupVcenterNsxtHost {
    hostIds?: string[];
    include?: string;
}

export interface ServiceenginegroupVipAsg {
    configurations?: outputs.ServiceenginegroupVipAsgConfiguration[];
    policies?: outputs.ServiceenginegroupVipAsgPolicy[];
}

export interface ServiceenginegroupVipAsgConfiguration {
    zones?: outputs.ServiceenginegroupVipAsgConfigurationZone[];
}

export interface ServiceenginegroupVipAsgConfigurationZone {
    availabilityZone: string;
    fipCapable: string;
    subnetUuid: string;
}

export interface ServiceenginegroupVipAsgPolicy {
    dnsCooldown?: string;
    maxSize?: string;
    minSize?: string;
    suspend?: string;
}

export interface ServiceenginegroupVssPlacement {
    coreNonaffinity?: string;
    numSubcores?: string;
}

export interface SnmptrapprofileConfigpbAttribute {
    version: string;
}

export interface SnmptrapprofileTrapServer {
    community: string;
    ipAddrs: outputs.SnmptrapprofileTrapServerIpAddr[];
    port?: string;
    users?: outputs.SnmptrapprofileTrapServerUser[];
    version?: string;
}

export interface SnmptrapprofileTrapServerIpAddr {
    addr: string;
    type: string;
}

export interface SnmptrapprofileTrapServerUser {
    authPassphrase?: string;
    authType?: string;
    privPassphrase?: string;
    privType?: string;
    username: string;
}

export interface SslkeyandcertificateCaCert {
    caRef: string;
    name: string;
}

export interface SslkeyandcertificateCertificate {
    certificate: string;
    certificateSigningRequest: string;
    chainVerified: string;
    daysUntilExpire?: string;
    expiryStatus?: string;
    fingerprint: string;
    issuers?: outputs.SslkeyandcertificateCertificateIssuer[];
    keyParams?: outputs.SslkeyandcertificateCertificateKeyParam[];
    notAfter: string;
    notBefore: string;
    publicKey: string;
    selfSigned: string;
    serialNumber: string;
    signature: string;
    signatureAlgorithm: string;
    subjectAltNames?: string[];
    subjects?: outputs.SslkeyandcertificateCertificateSubject[];
    text: string;
    version: string;
}

export interface SslkeyandcertificateCertificateIssuer {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface SslkeyandcertificateCertificateKeyParam {
    algorithm: string;
    ecParams?: outputs.SslkeyandcertificateCertificateKeyParamEcParam[];
    rsaParams?: outputs.SslkeyandcertificateCertificateKeyParamRsaParam[];
}

export interface SslkeyandcertificateCertificateKeyParamEcParam {
    curve?: string;
}

export interface SslkeyandcertificateCertificateKeyParamRsaParam {
    exponent?: string;
    keySize?: string;
}

export interface SslkeyandcertificateCertificateSubject {
    commonName: string;
    country: string;
    distinguishedName: string;
    emailAddress: string;
    locality: string;
    organization: string;
    organizationUnit: string;
    state: string;
}

export interface SslkeyandcertificateConfigpbAttribute {
    version: string;
}

export interface SslkeyandcertificateDynamicParam {
    isDynamic?: string;
    isSensitive?: string;
    name: string;
    value: string;
}

export interface SslkeyandcertificateKeyParam {
    algorithm: string;
    ecParams?: outputs.SslkeyandcertificateKeyParamEcParam[];
    rsaParams?: outputs.SslkeyandcertificateKeyParamRsaParam[];
}

export interface SslkeyandcertificateKeyParamEcParam {
    curve?: string;
}

export interface SslkeyandcertificateKeyParamRsaParam {
    exponent?: string;
    keySize?: string;
}

export interface SslkeyandcertificateMarker {
    key: string;
    values?: string[];
}

export interface SslkeyandcertificateOcspConfig {
    failedOcspJobsRetryInterval?: string;
    maxTries?: string;
    ocspReqInterval?: string;
    ocspRespTimeout: string;
    responderUrlLists?: string[];
    urlAction?: string;
}

export interface SslkeyandcertificateOcspResponseInfo {
    certStatus: string;
    nextUpdate: string;
    ocspRespFromResponderUrl: string;
    ocspResponse: string;
    revocationReason: string;
    revocationTime: string;
    thisUpdate: string;
}

export interface SslprofileAcceptedVersion {
    type: string;
}

export interface SslprofileConfigpbAttribute {
    version: string;
}

export interface SslprofileMarker {
    key: string;
    values?: string[];
}

export interface SslprofileSslRating {
    compatibilityRating: string;
    performanceRating: string;
    securityScore: string;
}

export interface SslprofileTag {
    type?: string;
    value: string;
}

export interface SsopolicyAuthenticationPolicy {
    authnRules?: outputs.SsopolicyAuthenticationPolicyAuthnRule[];
    defaultAuthProfileRef: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRule {
    actions?: outputs.SsopolicyAuthenticationPolicyAuthnRuleAction[];
    enable?: string;
    index: string;
    matches?: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatch[];
    name: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRuleAction {
    type?: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatch {
    clientIps?: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchClientIp[];
    hostHdrs?: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchHostHdr[];
    paths?: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchPath[];
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchClientIp {
    addrs?: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefix[];
    ranges?: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRange[];
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefix {
    ipAddrs: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRange {
    begins: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeBegin[];
    ends: outputs.SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeEnd[];
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface SsopolicyAuthenticationPolicyAuthnRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface SsopolicyAuthorizationPolicy {
    authzRules?: outputs.SsopolicyAuthorizationPolicyAuthzRule[];
}

export interface SsopolicyAuthorizationPolicyAuthzRule {
    actions: outputs.SsopolicyAuthorizationPolicyAuthzRuleAction[];
    enable?: string;
    index: string;
    matches: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatch[];
    name: string;
}

export interface SsopolicyAuthorizationPolicyAuthzRuleAction {
    statusCode: string;
    type?: string;
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatch {
    accessTokens?: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchAccessToken[];
    attrMatches?: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatch[];
    hostHdrs?: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchHostHdr[];
    methods?: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchMethod[];
    paths?: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchPath[];
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchAccessToken {
    matches?: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatch[];
    tokenName: string;
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatch {
    boolMatch: string;
    intMatch: string;
    isMandatory: string;
    name: string;
    stringMatches?: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatchStringMatch[];
    type: string;
    validate: string;
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchAccessTokenMatchStringMatch {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatch {
    attributeName: string;
    attributeValueLists: outputs.SsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatchAttributeValueList[];
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchAttrMatchAttributeValueList {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface SsopolicyAuthorizationPolicyAuthzRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface SsopolicyConfigpbAttribute {
    version: string;
}

export interface SsopolicyMarker {
    key: string;
    values?: string[];
}

export interface StatediffoperationEvent {
    duration: string;
    endTime: string;
    message: string;
    startTime: string;
    status?: string;
    taskName: string;
}

export interface StatediffsnapshotPostSnapshot {
    gssnapshots?: outputs.StatediffsnapshotPostSnapshotGssnapshot[];
    poolsnapshots?: outputs.StatediffsnapshotPostSnapshotPoolsnapshot[];
    sesnapshots?: outputs.StatediffsnapshotPostSnapshotSesnapshot[];
    vssnapshots?: outputs.StatediffsnapshotPostSnapshotVssnapshot[];
}

export interface StatediffsnapshotPostSnapshotGssnapshot {
    operStatuses?: outputs.StatediffsnapshotPostSnapshotGssnapshotOperStatus[];
}

export interface StatediffsnapshotPostSnapshotGssnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPostSnapshotGssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPostSnapshotGssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StatediffsnapshotPostSnapshotPoolsnapshot {
    operStatuses?: outputs.StatediffsnapshotPostSnapshotPoolsnapshotOperStatus[];
}

export interface StatediffsnapshotPostSnapshotPoolsnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPostSnapshotPoolsnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPostSnapshotPoolsnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StatediffsnapshotPostSnapshotSesnapshot {
    operStatuses?: outputs.StatediffsnapshotPostSnapshotSesnapshotOperStatus[];
}

export interface StatediffsnapshotPostSnapshotSesnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPostSnapshotSesnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPostSnapshotSesnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StatediffsnapshotPostSnapshotVssnapshot {
    operStatuses?: outputs.StatediffsnapshotPostSnapshotVssnapshotOperStatus[];
}

export interface StatediffsnapshotPostSnapshotVssnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPostSnapshotVssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPostSnapshotVssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StatediffsnapshotPreSnapshot {
    gssnapshots?: outputs.StatediffsnapshotPreSnapshotGssnapshot[];
    poolsnapshots?: outputs.StatediffsnapshotPreSnapshotPoolsnapshot[];
    sesnapshots?: outputs.StatediffsnapshotPreSnapshotSesnapshot[];
    vssnapshots?: outputs.StatediffsnapshotPreSnapshotVssnapshot[];
}

export interface StatediffsnapshotPreSnapshotGssnapshot {
    operStatuses?: outputs.StatediffsnapshotPreSnapshotGssnapshotOperStatus[];
}

export interface StatediffsnapshotPreSnapshotGssnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPreSnapshotGssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPreSnapshotGssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StatediffsnapshotPreSnapshotPoolsnapshot {
    operStatuses?: outputs.StatediffsnapshotPreSnapshotPoolsnapshotOperStatus[];
}

export interface StatediffsnapshotPreSnapshotPoolsnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPreSnapshotPoolsnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPreSnapshotPoolsnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StatediffsnapshotPreSnapshotSesnapshot {
    operStatuses?: outputs.StatediffsnapshotPreSnapshotSesnapshotOperStatus[];
}

export interface StatediffsnapshotPreSnapshotSesnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPreSnapshotSesnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPreSnapshotSesnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StatediffsnapshotPreSnapshotVssnapshot {
    operStatuses?: outputs.StatediffsnapshotPreSnapshotVssnapshotOperStatus[];
}

export interface StatediffsnapshotPreSnapshotVssnapshotOperStatus {
    lastChangedTimes?: outputs.StatediffsnapshotPreSnapshotVssnapshotOperStatusLastChangedTime[];
    reasonCode: string;
    reasonCodeString: string;
    reasons?: string[];
    state?: string;
}

export interface StatediffsnapshotPreSnapshotVssnapshotOperStatusLastChangedTime {
    secs: string;
    usecs: string;
}

export interface StringgroupConfigpbAttribute {
    version: string;
}

export interface StringgroupKv {
    key: string;
    value: string;
}

export interface StringgroupMarker {
    key: string;
    values?: string[];
}

export interface SystemconfigurationAdminAuthConfiguration {
    allowLocalUserLogin?: string;
    remoteAuthConfigurations?: outputs.SystemconfigurationAdminAuthConfigurationRemoteAuthConfiguration[];
    serviceAuthConfigurations?: outputs.SystemconfigurationAdminAuthConfigurationServiceAuthConfiguration[];
}

export interface SystemconfigurationAdminAuthConfigurationRemoteAuthConfiguration {
    authMappingProfileRef: string;
    authProfileRef: string;
    index: string;
}

export interface SystemconfigurationAdminAuthConfigurationServiceAuthConfiguration {
    index: string;
    serviceAuthMappingProfileRef: string;
    serviceAuthProfileRef: string;
}

export interface SystemconfigurationConfigpbAttribute {
    version: string;
}

export interface SystemconfigurationControllerAnalyticsPolicy {
    metricsEventThresholds?: outputs.SystemconfigurationControllerAnalyticsPolicyMetricsEventThreshold[];
}

export interface SystemconfigurationControllerAnalyticsPolicyMetricsEventThreshold {
    metricsEventThresholdType: string;
    resetThreshold: string;
    watermarkThresholds?: number[];
}

export interface SystemconfigurationDnsConfiguration {
    searchDomain: string;
    serverLists?: outputs.SystemconfigurationDnsConfigurationServerList[];
}

export interface SystemconfigurationDnsConfigurationServerList {
    addr: string;
    type: string;
}

export interface SystemconfigurationEmailConfiguration {
    authPassword: string;
    authUsername: string;
    disableTls?: string;
    emailTimezone: string;
    fromEmail?: string;
    fromName: string;
    mailServerName?: string;
    mailServerPort?: string;
    smtpType: string;
}

export interface SystemconfigurationGlobalTenantConfig {
    seInProviderContext?: string;
    tenantAccessToProviderSe?: string;
    tenantVrf?: string;
}

export interface SystemconfigurationLinuxConfiguration {
    banner: string;
    cisMode?: string;
    motd: string;
}

export interface SystemconfigurationMgmtIpAccessControl {
    apiAccesses?: outputs.SystemconfigurationMgmtIpAccessControlApiAccess[];
    shellServerAccesses?: outputs.SystemconfigurationMgmtIpAccessControlShellServerAccess[];
    snmpAccesses?: outputs.SystemconfigurationMgmtIpAccessControlSnmpAccess[];
    sshAccesses?: outputs.SystemconfigurationMgmtIpAccessControlSshAccess[];
    sysintAccesses?: outputs.SystemconfigurationMgmtIpAccessControlSysintAccess[];
}

export interface SystemconfigurationMgmtIpAccessControlApiAccess {
    addrs?: outputs.SystemconfigurationMgmtIpAccessControlApiAccessAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.SystemconfigurationMgmtIpAccessControlApiAccessPrefix[];
    ranges?: outputs.SystemconfigurationMgmtIpAccessControlApiAccessRange[];
}

export interface SystemconfigurationMgmtIpAccessControlApiAccessAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlApiAccessPrefix {
    ipAddrs: outputs.SystemconfigurationMgmtIpAccessControlApiAccessPrefixIpAddr[];
    mask: string;
}

export interface SystemconfigurationMgmtIpAccessControlApiAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlApiAccessRange {
    begins: outputs.SystemconfigurationMgmtIpAccessControlApiAccessRangeBegin[];
    ends: outputs.SystemconfigurationMgmtIpAccessControlApiAccessRangeEnd[];
}

export interface SystemconfigurationMgmtIpAccessControlApiAccessRangeBegin {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlApiAccessRangeEnd {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlShellServerAccess {
    addrs?: outputs.SystemconfigurationMgmtIpAccessControlShellServerAccessAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.SystemconfigurationMgmtIpAccessControlShellServerAccessPrefix[];
    ranges?: outputs.SystemconfigurationMgmtIpAccessControlShellServerAccessRange[];
}

export interface SystemconfigurationMgmtIpAccessControlShellServerAccessAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlShellServerAccessPrefix {
    ipAddrs: outputs.SystemconfigurationMgmtIpAccessControlShellServerAccessPrefixIpAddr[];
    mask: string;
}

export interface SystemconfigurationMgmtIpAccessControlShellServerAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlShellServerAccessRange {
    begins: outputs.SystemconfigurationMgmtIpAccessControlShellServerAccessRangeBegin[];
    ends: outputs.SystemconfigurationMgmtIpAccessControlShellServerAccessRangeEnd[];
}

export interface SystemconfigurationMgmtIpAccessControlShellServerAccessRangeBegin {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlShellServerAccessRangeEnd {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSnmpAccess {
    addrs?: outputs.SystemconfigurationMgmtIpAccessControlSnmpAccessAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.SystemconfigurationMgmtIpAccessControlSnmpAccessPrefix[];
    ranges?: outputs.SystemconfigurationMgmtIpAccessControlSnmpAccessRange[];
}

export interface SystemconfigurationMgmtIpAccessControlSnmpAccessAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSnmpAccessPrefix {
    ipAddrs: outputs.SystemconfigurationMgmtIpAccessControlSnmpAccessPrefixIpAddr[];
    mask: string;
}

export interface SystemconfigurationMgmtIpAccessControlSnmpAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSnmpAccessRange {
    begins: outputs.SystemconfigurationMgmtIpAccessControlSnmpAccessRangeBegin[];
    ends: outputs.SystemconfigurationMgmtIpAccessControlSnmpAccessRangeEnd[];
}

export interface SystemconfigurationMgmtIpAccessControlSnmpAccessRangeBegin {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSnmpAccessRangeEnd {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSshAccess {
    addrs?: outputs.SystemconfigurationMgmtIpAccessControlSshAccessAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.SystemconfigurationMgmtIpAccessControlSshAccessPrefix[];
    ranges?: outputs.SystemconfigurationMgmtIpAccessControlSshAccessRange[];
}

export interface SystemconfigurationMgmtIpAccessControlSshAccessAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSshAccessPrefix {
    ipAddrs: outputs.SystemconfigurationMgmtIpAccessControlSshAccessPrefixIpAddr[];
    mask: string;
}

export interface SystemconfigurationMgmtIpAccessControlSshAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSshAccessRange {
    begins: outputs.SystemconfigurationMgmtIpAccessControlSshAccessRangeBegin[];
    ends: outputs.SystemconfigurationMgmtIpAccessControlSshAccessRangeEnd[];
}

export interface SystemconfigurationMgmtIpAccessControlSshAccessRangeBegin {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSshAccessRangeEnd {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSysintAccess {
    addrs?: outputs.SystemconfigurationMgmtIpAccessControlSysintAccessAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.SystemconfigurationMgmtIpAccessControlSysintAccessPrefix[];
    ranges?: outputs.SystemconfigurationMgmtIpAccessControlSysintAccessRange[];
}

export interface SystemconfigurationMgmtIpAccessControlSysintAccessAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSysintAccessPrefix {
    ipAddrs: outputs.SystemconfigurationMgmtIpAccessControlSysintAccessPrefixIpAddr[];
    mask: string;
}

export interface SystemconfigurationMgmtIpAccessControlSysintAccessPrefixIpAddr {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSysintAccessRange {
    begins: outputs.SystemconfigurationMgmtIpAccessControlSysintAccessRangeBegin[];
    ends: outputs.SystemconfigurationMgmtIpAccessControlSysintAccessRangeEnd[];
}

export interface SystemconfigurationMgmtIpAccessControlSysintAccessRangeBegin {
    addr: string;
    type: string;
}

export interface SystemconfigurationMgmtIpAccessControlSysintAccessRangeEnd {
    addr: string;
    type: string;
}

export interface SystemconfigurationNtpConfiguration {
    ntpAuthenticationKeys?: outputs.SystemconfigurationNtpConfigurationNtpAuthenticationKey[];
    ntpServerLists?: outputs.SystemconfigurationNtpConfigurationNtpServerList[];
    ntpServers?: outputs.SystemconfigurationNtpConfigurationNtpServer[];
}

export interface SystemconfigurationNtpConfigurationNtpAuthenticationKey {
    algorithm?: string;
    key: string;
    keyNumber: string;
}

export interface SystemconfigurationNtpConfigurationNtpServer {
    keyNumber: string;
    servers: outputs.SystemconfigurationNtpConfigurationNtpServerServer[];
}

export interface SystemconfigurationNtpConfigurationNtpServerList {
    addr: string;
    type: string;
}

export interface SystemconfigurationNtpConfigurationNtpServerServer {
    addr: string;
    type: string;
}

export interface SystemconfigurationPortalConfiguration {
    allowBasicAuthentication?: string;
    apiForceTimeout?: string;
    disableRemoteCliShell?: string;
    disableSwagger?: string;
    enableClickjackingProtection?: string;
    enableHttp?: string;
    enableHttps?: string;
    httpPort: string;
    httpsPort: string;
    minimumPasswordLength?: string;
    passwordStrengthCheck?: string;
    pkiprofileRef: string;
    redirectToHttps?: string;
    sslkeyandcertificateRefs?: string[];
    sslprofileRef: string;
    useUuidFromInput?: string;
}

export interface SystemconfigurationProxyConfiguration {
    host: string;
    password: string;
    port: string;
    username: string;
}

export interface SystemconfigurationSecureChannelConfiguration {
    sslkeyandcertificateRefs?: string[];
}

export interface SystemconfigurationSnmpConfiguration {
    community: string;
    largeTrapPayload?: string;
    snmpV3Configs?: outputs.SystemconfigurationSnmpConfigurationSnmpV3Config[];
    sysContact?: string;
    sysLocation: string;
    version?: string;
}

export interface SystemconfigurationSnmpConfigurationSnmpV3Config {
    engineId: string;
    users?: outputs.SystemconfigurationSnmpConfigurationSnmpV3ConfigUser[];
}

export interface SystemconfigurationSnmpConfigurationSnmpV3ConfigUser {
    authPassphrase?: string;
    authType?: string;
    privPassphrase?: string;
    privType?: string;
    username: string;
}

export interface SystemlimitsConfigpbAttribute {
    version: string;
}

export interface SystemlimitsControllerLimit {
    botLimits?: outputs.SystemlimitsControllerLimitBotLimit[];
    certificatesPerVirtualservice: string;
    controllerCloudLimits?: outputs.SystemlimitsControllerLimitControllerCloudLimit[];
    controllerSizingLimits?: outputs.SystemlimitsControllerLimitControllerSizingLimit[];
    defaultRoutesPerVrfcontext: string;
    gatewayMonPerVrf: string;
    ipaddressLimits?: outputs.SystemlimitsControllerLimitIpaddressLimit[];
    ipsPerIpgroup: string;
    l7Limits?: outputs.SystemlimitsControllerLimitL7Limit[];
    poolgroupsPerVirtualservice: string;
    poolsPerPoolgroup: string;
    poolsPerVirtualservice: string;
    routesPerVrfcontext: string;
    rulesPerNatPolicy: string;
    rulesPerNetworksecuritypolicy: string;
    serversPerPool: string;
    sniChildrenPerParent: string;
    stringsPerStringgroup: string;
    vsBgpScaleout: string;
    vsL2Scaleout: string;
    wafLimits?: outputs.SystemlimitsControllerLimitWafLimit[];
}

export interface SystemlimitsControllerLimitBotLimit {
    allowRules: string;
    hdrs: string;
    mappingRules: string;
}

export interface SystemlimitsControllerLimitControllerCloudLimit {
    numClouds: string;
    t1LrsPerCloud: string;
    type: string;
}

export interface SystemlimitsControllerLimitControllerSizingLimit {
    controllerSizingCloudLimits?: outputs.SystemlimitsControllerLimitControllerSizingLimitControllerSizingCloudLimit[];
    flavor: string;
    numClouds: string;
    numEastWestVirtualservices: string;
    numServers: string;
    numServiceengines: string;
    numTenants: string;
    numVirtualservices: string;
    numVirtualservicesRtMetrics: string;
    numVrfs: string;
    numWafVirtualservices: string;
}

export interface SystemlimitsControllerLimitControllerSizingLimitControllerSizingCloudLimit {
    numClouds: string;
    type: string;
}

export interface SystemlimitsControllerLimitIpaddressLimit {
    ipAddressGroupPerMatchCriteria: string;
    ipAddressPrefixPerMatchCriteria: string;
    ipAddressRangePerMatchCriteria: string;
    ipAddressesPerMatchCriteria: string;
}

export interface SystemlimitsControllerLimitL7Limit {
    httpPoliciesPerVs: string;
    numCompressionFilters: string;
    numCustomStr: string;
    numMatchesPerRule: string;
    numRulesPerEvhHost: string;
    numRulesPerHttpPolicy: string;
    numStrgroupsPerMatch: string;
    strCacheMime: string;
    strGroupsCacheMime: string;
    strGroupsNoCacheMime: string;
    strGroupsNoCacheUri: string;
    strNoCacheMime: string;
    strNoCacheUri: string;
}

export interface SystemlimitsControllerLimitWafLimit {
    numAllowedContentTypes: string;
    numAllowedRequestContentTypeCharsets: string;
    numAllowlistPolicyRules: string;
    numApplications: string;
    numContentTypeMappings: string;
    numDataFiles: string;
    numExcludeListPerRuleGroup: string;
    numPrePostCrsGroups: string;
    numPsmGroups: string;
    numPsmMatchElements: string;
    numPsmMatchRulesPerLoc: string;
    numPsmTotalLocations: string;
    numRestrictedExtensions: string;
    numRestrictedHeaders: string;
    numRuleTags: string;
    numRulesPerRulegroup: string;
    numStaticExtensions: string;
}

export interface SystemlimitsControllerSize {
    flavor: string;
    minCpus: string;
    minMemory: string;
}

export interface SystemlimitsServiceengineLimit {
    allVirtualservicesPerServiceengine: string;
    ewVirtualservicesPerServiceengine: string;
    nsVirtualservicesPerServiceengine: string;
    numLogicalIntfPerSe: string;
    numPhyIntfPerSe: string;
    numVirtualservicesRtMetrics: string;
    numVlanIntfPerPhyIntf: string;
    numVlanIntfPerSe: string;
    serviceengineCloudLimits?: outputs.SystemlimitsServiceengineLimitServiceengineCloudLimit[];
}

export interface SystemlimitsServiceengineLimitServiceengineCloudLimit {
    type: string;
    vrfsPerServiceengine: string;
}

export interface SystemreportEvent {
    duration: string;
    endTime: string;
    eventName: string;
    messages?: string[];
    startTime: string;
    status: string;
}

export interface SystemreportReadinessReport {
    name: string;
    nodeRef: string;
    nodeType: string;
    objCloudRef: string;
    systemReadinesses?: outputs.SystemreportReadinessReportSystemReadiness[];
}

export interface SystemreportReadinessReportSystemReadiness {
    checks?: outputs.SystemreportReadinessReportSystemReadinessCheck[];
    checksCompleted: string;
    duration: string;
    endTime: string;
    imageRef: string;
    patchImageRef: string;
    startTime: string;
    states?: outputs.SystemreportReadinessReportSystemReadinessState[];
    totalChecks: string;
    upgradeOps: string;
}

export interface SystemreportReadinessReportSystemReadinessCheck {
    checkCode: string;
    description: string;
    details?: string[];
    duration: string;
    endTime: string;
    errorDetails?: string[];
    startTime: string;
    state: string;
}

export interface SystemreportReadinessReportSystemReadinessState {
    lastChangedTimes?: outputs.SystemreportReadinessReportSystemReadinessStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface SystemreportReadinessReportSystemReadinessStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface SystemreportState {
    lastChangedTimes?: outputs.SystemreportStateLastChangedTime[];
    reason: string;
    state: string;
}

export interface SystemreportStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface SystemreportSummary {
    description: string;
    previews?: string[];
    title: string;
}

export interface SystemreportTask {
    name: string;
    reason: string;
    summaries?: outputs.SystemreportTaskSummary[];
    taskJournalRef: string;
}

export interface SystemreportTaskSummary {
    description: string;
    duration: string;
    endTime: string;
    errorCount: string;
    reason: string;
    startTime: string;
    status: string;
    type: string;
}

export interface TaskjournalError {
    details?: string[];
    name: string;
    object: string;
    tenant: string;
    uuid: string;
    version: string;
}

export interface TaskjournalInfo {
    actions?: outputs.TaskjournalInfoAction[];
    totalObjects: string;
    versions?: string[];
}

export interface TaskjournalInfoAction {
    objects?: outputs.TaskjournalInfoActionObject[];
    version: string;
}

export interface TaskjournalInfoActionObject {
    failed: string;
    model: string;
    skipped: string;
    success: string;
}

export interface TaskjournalSummary {
    description: string;
    duration: string;
    endTime: string;
    errorCount: string;
    reason: string;
    startTime: string;
    status: string;
    type: string;
}

export interface TenantAttr {
    key: string;
    value: string;
}

export interface TenantConfigSetting {
    seInProviderContext?: string;
    tenantAccessToProviderSe?: string;
    tenantVrf?: string;
}

export interface TenantConfigpbAttribute {
    version: string;
}

export interface TenantsystemconfigurationConfigpbAttribute {
    version: string;
}

export interface Testsedatastorelevel1ConfigpbAttribute {
    version: string;
}

export interface Testsedatastorelevel2ConfigpbAttribute {
    version: string;
}

export interface Testsedatastorelevel3ConfigpbAttribute {
    version: string;
}

export interface TrafficcloneprofileCloneServer {
    ipAddresses?: outputs.TrafficcloneprofileCloneServerIpAddress[];
    mac: string;
    networkRef: string;
    subnets?: outputs.TrafficcloneprofileCloneServerSubnet[];
}

export interface TrafficcloneprofileCloneServerIpAddress {
    addr: string;
    type: string;
}

export interface TrafficcloneprofileCloneServerSubnet {
    ipAddrs: outputs.TrafficcloneprofileCloneServerSubnetIpAddr[];
    mask: string;
}

export interface TrafficcloneprofileCloneServerSubnetIpAddr {
    addr: string;
    type: string;
}

export interface TrafficcloneprofileConfigpbAttribute {
    version: string;
}

export interface TrafficcloneprofileMarker {
    key: string;
    values?: string[];
}

export interface UpgradestatusinfoHistory {
    duration: string;
    endTime: string;
    ops: string;
    patchVersion: string;
    seUpgradeEvents?: outputs.UpgradestatusinfoHistorySeUpgradeEvent[];
    segStatuses?: outputs.UpgradestatusinfoHistorySegStatus[];
    startTime: string;
    statediffRef: string;
    states?: outputs.UpgradestatusinfoHistoryState[];
    upgradeEvents?: outputs.UpgradestatusinfoHistoryUpgradeEvent[];
    version: string;
}

export interface UpgradestatusinfoHistorySeUpgradeEvent {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons?: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks?: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface UpgradestatusinfoHistorySegStatus {
    controllerVersion: string;
    disruptedVsReves?: string[];
    duration: string;
    endTime: string;
    enqueueTime: string;
    haMode: string;
    inProgress: string;
    notes?: string[];
    numSe: string;
    numSeWithNoVs: string;
    numSeWithVsNotScaledout: string;
    numSeWithVsScaledout: string;
    numVs: string;
    numVsDisrupted: string;
    progress: string;
    reasons?: string[];
    requestTime: string;
    seAlreadyUpgradedAtStarts?: string[];
    seDisconnectedAtStarts?: string[];
    seGroupName: string;
    seGroupUuid: string;
    seIpMissingAtStarts?: string[];
    sePoweredoffAtStarts?: string[];
    seRebootInProgressRef: string;
    seUpgradeCompleteds?: string[];
    seUpgradeErrors?: outputs.UpgradestatusinfoHistorySegStatusSeUpgradeError[];
    seUpgradeFaileds?: string[];
    seUpgradeInProgresses?: string[];
    seUpgradeNotStarteds?: string[];
    seUpgradeSkipSuspendeds?: string[];
    seUpgradeSuspendeds?: string[];
    seWithNoVs?: string[];
    seWithVsNotScaledouts?: string[];
    seWithVsScaledouts?: string[];
    startTime: string;
    state: string;
    tenantRef: string;
    thread: string;
    trafficStatus: string;
    vsErrors?: outputs.UpgradestatusinfoHistorySegStatusVsError[];
    vsMigrateInProgressReves?: string[];
    vsScaleinInProgressReves?: string[];
    vsScaleoutInProgressReves?: string[];
    worker: string;
}

export interface UpgradestatusinfoHistorySegStatusSeUpgradeError {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons?: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks?: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface UpgradestatusinfoHistorySegStatusVsError {
    eventTimestamps?: outputs.UpgradestatusinfoHistorySegStatusVsErrorEventTimestamp[];
    reasons?: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    tenantRef: string;
    trafficStatus: string;
    vipId: string;
    vsRef: string;
}

export interface UpgradestatusinfoHistorySegStatusVsErrorEventTimestamp {
    secs: string;
    usecs: string;
}

export interface UpgradestatusinfoHistoryState {
    lastChangedTimes?: outputs.UpgradestatusinfoHistoryStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface UpgradestatusinfoHistoryStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface UpgradestatusinfoHistoryUpgradeEvent {
    nodesEvents?: outputs.UpgradestatusinfoHistoryUpgradeEventNodesEvent[];
    subEvents?: outputs.UpgradestatusinfoHistoryUpgradeEventSubEvent[];
    task: string;
    taskName: string;
}

export interface UpgradestatusinfoHistoryUpgradeEventNodesEvent {
    duration: string;
    endTime: string;
    ips?: outputs.UpgradestatusinfoHistoryUpgradeEventNodesEventIp[];
    message: string;
    startTime: string;
    status?: string;
    subTasks?: string[];
}

export interface UpgradestatusinfoHistoryUpgradeEventNodesEventIp {
    addr: string;
    type: string;
}

export interface UpgradestatusinfoHistoryUpgradeEventSubEvent {
    duration: string;
    endTime: string;
    ips?: outputs.UpgradestatusinfoHistoryUpgradeEventSubEventIp[];
    message: string;
    startTime: string;
    status?: string;
    subTasks?: string[];
}

export interface UpgradestatusinfoHistoryUpgradeEventSubEventIp {
    addr: string;
    type: string;
}

export interface UpgradestatusinfoParam {
    imageRef: string;
    patchRef: string;
    seGroupOptions?: outputs.UpgradestatusinfoParamSeGroupOption[];
    seGroupResumeOptions?: outputs.UpgradestatusinfoParamSeGroupResumeOption[];
}

export interface UpgradestatusinfoParamSeGroupOption {
    actionOnError?: string;
    disruptive?: string;
}

export interface UpgradestatusinfoParamSeGroupResumeOption {
    actionOnError?: string;
    disruptive?: string;
    skipSuspended?: string;
}

export interface UpgradestatusinfoPatchList {
    patchImagePath: string;
    patchImageRef: string;
    patchVersion: string;
}

export interface UpgradestatusinfoPreviousPatchList {
    patchImagePath: string;
    patchImageRef: string;
    patchVersion: string;
}

export interface UpgradestatusinfoSeUpgradeEvent {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons?: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks?: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface UpgradestatusinfoSegParam {
    imageRef: string;
    patchRef: string;
    seGroupOptions?: outputs.UpgradestatusinfoSegParamSeGroupOption[];
    seGroupResumeOptions?: outputs.UpgradestatusinfoSegParamSeGroupResumeOption[];
}

export interface UpgradestatusinfoSegParamSeGroupOption {
    actionOnError?: string;
    disruptive?: string;
}

export interface UpgradestatusinfoSegParamSeGroupResumeOption {
    actionOnError?: string;
    disruptive?: string;
    skipSuspended?: string;
}

export interface UpgradestatusinfoSegStatus {
    controllerVersion: string;
    disruptedVsReves?: string[];
    duration: string;
    endTime: string;
    enqueueTime: string;
    haMode: string;
    inProgress: string;
    notes?: string[];
    numSe: string;
    numSeWithNoVs: string;
    numSeWithVsNotScaledout: string;
    numSeWithVsScaledout: string;
    numVs: string;
    numVsDisrupted: string;
    progress: string;
    reasons?: string[];
    requestTime: string;
    seAlreadyUpgradedAtStarts?: string[];
    seDisconnectedAtStarts?: string[];
    seGroupName: string;
    seGroupUuid: string;
    seIpMissingAtStarts?: string[];
    sePoweredoffAtStarts?: string[];
    seRebootInProgressRef: string;
    seUpgradeCompleteds?: string[];
    seUpgradeErrors?: outputs.UpgradestatusinfoSegStatusSeUpgradeError[];
    seUpgradeFaileds?: string[];
    seUpgradeInProgresses?: string[];
    seUpgradeNotStarteds?: string[];
    seUpgradeSkipSuspendeds?: string[];
    seUpgradeSuspendeds?: string[];
    seWithNoVs?: string[];
    seWithVsNotScaledouts?: string[];
    seWithVsScaledouts?: string[];
    startTime: string;
    state: string;
    tenantRef: string;
    thread: string;
    trafficStatus: string;
    vsErrors?: outputs.UpgradestatusinfoSegStatusVsError[];
    vsMigrateInProgressReves?: string[];
    vsScaleinInProgressReves?: string[];
    vsScaleoutInProgressReves?: string[];
    worker: string;
}

export interface UpgradestatusinfoSegStatusSeUpgradeError {
    fromSeRef: string;
    numSe: string;
    numSeGroup: string;
    numVs: string;
    reasons?: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    subTasks?: string[];
    task: string;
    toSeRef: string;
    trafficStatus: string;
    vsRef: string;
}

export interface UpgradestatusinfoSegStatusVsError {
    eventTimestamps?: outputs.UpgradestatusinfoSegStatusVsErrorEventTimestamp[];
    reasons?: string[];
    seGroupHaMode: string;
    seGroupRef: string;
    seRef: string;
    tenantRef: string;
    trafficStatus: string;
    vipId: string;
    vsRef: string;
}

export interface UpgradestatusinfoSegStatusVsErrorEventTimestamp {
    secs: string;
    usecs: string;
}

export interface UpgradestatusinfoState {
    lastChangedTimes?: outputs.UpgradestatusinfoStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface UpgradestatusinfoStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface UpgradestatusinfoUpgradeEvent {
    nodesEvents?: outputs.UpgradestatusinfoUpgradeEventNodesEvent[];
    subEvents?: outputs.UpgradestatusinfoUpgradeEventSubEvent[];
    task: string;
    taskName: string;
}

export interface UpgradestatusinfoUpgradeEventNodesEvent {
    duration: string;
    endTime: string;
    ips?: outputs.UpgradestatusinfoUpgradeEventNodesEventIp[];
    message: string;
    startTime: string;
    status?: string;
    subTasks?: string[];
}

export interface UpgradestatusinfoUpgradeEventNodesEventIp {
    addr: string;
    type: string;
}

export interface UpgradestatusinfoUpgradeEventSubEvent {
    duration: string;
    endTime: string;
    ips?: outputs.UpgradestatusinfoUpgradeEventSubEventIp[];
    message: string;
    startTime: string;
    status?: string;
    subTasks?: string[];
}

export interface UpgradestatusinfoUpgradeEventSubEventIp {
    addr: string;
    type: string;
}

export interface UpgradestatusinfoUpgradeReadiness {
    checks?: outputs.UpgradestatusinfoUpgradeReadinessCheck[];
    checksCompleted: string;
    duration: string;
    endTime: string;
    imageRef: string;
    patchImageRef: string;
    startTime: string;
    states?: outputs.UpgradestatusinfoUpgradeReadinessState[];
    totalChecks: string;
    upgradeOps: string;
}

export interface UpgradestatusinfoUpgradeReadinessCheck {
    checkCode: string;
    description: string;
    details?: string[];
    duration: string;
    endTime: string;
    errorDetails?: string[];
    startTime: string;
    state: string;
}

export interface UpgradestatusinfoUpgradeReadinessState {
    lastChangedTimes?: outputs.UpgradestatusinfoUpgradeReadinessStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface UpgradestatusinfoUpgradeReadinessStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface UpgradestatussummaryState {
    lastChangedTimes?: outputs.UpgradestatussummaryStateLastChangedTime[];
    reason: string;
    rebooted: string;
    state: string;
}

export interface UpgradestatussummaryStateLastChangedTime {
    secs: string;
    usecs: string;
}

export interface UserAccess {
    allTenants?: string;
    roleRef: string;
    tenantRef: string;
}

export interface UseraccountprofileConfigpbAttribute {
    version: string;
}

export interface VcenterserverConfigpbAttribute {
    version: string;
}

export interface VcenterserverContentLib {
    id: string;
    name: string;
}

export interface VirtualserviceAnalyticsPolicy {
    allHeaders?: string;
    clientInsights?: string;
    clientInsightsSamplings?: outputs.VirtualserviceAnalyticsPolicyClientInsightsSampling[];
    clientLogFilters?: outputs.VirtualserviceAnalyticsPolicyClientLogFilter[];
    fullClientLogs?: outputs.VirtualserviceAnalyticsPolicyFullClientLog[];
    learningLogPolicies?: outputs.VirtualserviceAnalyticsPolicyLearningLogPolicy[];
    metricsRealtimeUpdates?: outputs.VirtualserviceAnalyticsPolicyMetricsRealtimeUpdate[];
    significantLogThrottle?: string;
    udfLogThrottle?: string;
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSampling {
    clientIps?: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIp[];
    sampleUris?: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingSampleUri[];
    skipUris?: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingSkipUri[];
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIp {
    addrs?: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefix[];
    ranges?: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRange[];
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefix {
    ipAddrs: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefixIpAddr[];
    mask: string;
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRange {
    begins: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeBegin[];
    ends: outputs.VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeEnd[];
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingSampleUri {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface VirtualserviceAnalyticsPolicyClientInsightsSamplingSkipUri {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface VirtualserviceAnalyticsPolicyClientLogFilter {
    allHeaders?: string;
    clientIps?: outputs.VirtualserviceAnalyticsPolicyClientLogFilterClientIp[];
    duration?: string;
    enabled: string;
    index: string;
    name: string;
    uris?: outputs.VirtualserviceAnalyticsPolicyClientLogFilterUri[];
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterClientIp {
    addrs?: outputs.VirtualserviceAnalyticsPolicyClientLogFilterClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.VirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefix[];
    ranges?: outputs.VirtualserviceAnalyticsPolicyClientLogFilterClientIpRange[];
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterClientIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefix {
    ipAddrs: outputs.VirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefixIpAddr[];
    mask: string;
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterClientIpRange {
    begins: outputs.VirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeBegin[];
    ends: outputs.VirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeEnd[];
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface VirtualserviceAnalyticsPolicyClientLogFilterUri {
    matchCriteria: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface VirtualserviceAnalyticsPolicyFullClientLog {
    duration?: string;
    enabled: string;
    throttle?: string;
}

export interface VirtualserviceAnalyticsPolicyLearningLogPolicy {
    enabled?: string;
    host: string;
    port: string;
}

export interface VirtualserviceAnalyticsPolicyMetricsRealtimeUpdate {
    duration?: string;
    enabled: string;
}

export interface VirtualserviceConfigpbAttribute {
    version: string;
}

export interface VirtualserviceConnectionsRateLimit {
    actions: outputs.VirtualserviceConnectionsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.VirtualserviceConnectionsRateLimitRateLimiter[];
}

export interface VirtualserviceConnectionsRateLimitAction {
    files?: outputs.VirtualserviceConnectionsRateLimitActionFile[];
    redirects?: outputs.VirtualserviceConnectionsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface VirtualserviceConnectionsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface VirtualserviceConnectionsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.VirtualserviceConnectionsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.VirtualserviceConnectionsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface VirtualserviceConnectionsRateLimitActionRedirectHost {
    tokens: outputs.VirtualserviceConnectionsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface VirtualserviceConnectionsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface VirtualserviceConnectionsRateLimitActionRedirectPath {
    tokens: outputs.VirtualserviceConnectionsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface VirtualserviceConnectionsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface VirtualserviceConnectionsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface VirtualserviceContentRewrite {
    rewritableContentRef: string;
    rspRewriteRules?: outputs.VirtualserviceContentRewriteRspRewriteRule[];
}

export interface VirtualserviceContentRewriteRspRewriteRule {
    enable: string;
    index: string;
    name: string;
    pairs?: outputs.VirtualserviceContentRewriteRspRewriteRulePair[];
}

export interface VirtualserviceContentRewriteRspRewriteRulePair {
    replacementStrings?: outputs.VirtualserviceContentRewriteRspRewriteRulePairReplacementString[];
    searchStrings: outputs.VirtualserviceContentRewriteRspRewriteRulePairSearchString[];
}

export interface VirtualserviceContentRewriteRspRewriteRulePairReplacementString {
    type?: string;
    val: string;
}

export interface VirtualserviceContentRewriteRspRewriteRulePairSearchString {
    type?: string;
    val: string;
}

export interface VirtualserviceDnsInfo {
    algorithm?: string;
    cnames?: outputs.VirtualserviceDnsInfoCname[];
    fqdn: string;
    metadata: string;
    numRecordsInResponse: string;
    ttl: string;
    type?: string;
}

export interface VirtualserviceDnsInfoCname {
    cname: string;
}

export interface VirtualserviceDnsPolicy {
    dnsPolicyRef: string;
    index: string;
}

export interface VirtualserviceHttpPolicy {
    httpPolicySetRef: string;
    index: string;
}

export interface VirtualserviceJwtConfig {
    audience: string;
    jwtLocation?: string;
    jwtName: string;
}

export interface VirtualserviceL4Policy {
    index: string;
    l4PolicySetRef: string;
}

export interface VirtualserviceLdapVsConfig {
    realm: string;
    seAuthLdapBindTimeout?: string;
    seAuthLdapCacheSize?: string;
    seAuthLdapConnectTimeout?: string;
    seAuthLdapConnsPerServer?: string;
    seAuthLdapReconnectTimeout?: string;
    seAuthLdapRequestTimeout?: string;
    seAuthLdapServersFailoverOnly?: string;
}

export interface VirtualserviceMarker {
    key: string;
    values?: string[];
}

export interface VirtualserviceOauthVsConfig {
    cookieName: string;
    cookieTimeout?: string;
    keys?: outputs.VirtualserviceOauthVsConfigKey[];
    logoutUri: string;
    oauthSettings?: outputs.VirtualserviceOauthVsConfigOauthSetting[];
    postLogoutRedirectUri: string;
    redirectUri: string;
}

export interface VirtualserviceOauthVsConfigKey {
    aesKey: string;
    hmacKey: string;
    name: string;
}

export interface VirtualserviceOauthVsConfigOauthSetting {
    appSettings?: outputs.VirtualserviceOauthVsConfigOauthSettingAppSetting[];
    authProfileRef: string;
    resourceServers?: outputs.VirtualserviceOauthVsConfigOauthSettingResourceServer[];
}

export interface VirtualserviceOauthVsConfigOauthSettingAppSetting {
    clientId: string;
    clientSecret: string;
    oidcConfigs?: outputs.VirtualserviceOauthVsConfigOauthSettingAppSettingOidcConfig[];
    scopes?: string[];
}

export interface VirtualserviceOauthVsConfigOauthSettingAppSettingOidcConfig {
    oidcEnable: string;
    profile?: string;
    userinfo: string;
}

export interface VirtualserviceOauthVsConfigOauthSettingResourceServer {
    accessType?: string;
    introspectionDataTimeout?: string;
    jwtParams?: outputs.VirtualserviceOauthVsConfigOauthSettingResourceServerJwtParam[];
    opaqueTokenParams?: outputs.VirtualserviceOauthVsConfigOauthSettingResourceServerOpaqueTokenParam[];
}

export interface VirtualserviceOauthVsConfigOauthSettingResourceServerJwtParam {
    audience: string;
}

export interface VirtualserviceOauthVsConfigOauthSettingResourceServerOpaqueTokenParam {
    serverId: string;
    serverSecret: string;
}

export interface VirtualservicePerformanceLimit {
    maxConcurrentConnections: string;
    maxThroughput: string;
}

export interface VirtualserviceRequestsRateLimit {
    actions: outputs.VirtualserviceRequestsRateLimitAction[];
    explicitTracking?: string;
    fineGrain?: string;
    httpCookie: string;
    httpHeader: string;
    rateLimiters?: outputs.VirtualserviceRequestsRateLimitRateLimiter[];
}

export interface VirtualserviceRequestsRateLimitAction {
    files?: outputs.VirtualserviceRequestsRateLimitActionFile[];
    redirects?: outputs.VirtualserviceRequestsRateLimitActionRedirect[];
    statusCode?: string;
    type?: string;
}

export interface VirtualserviceRequestsRateLimitActionFile {
    contentType: string;
    fileContent: string;
    fileLength: string;
}

export interface VirtualserviceRequestsRateLimitActionRedirect {
    addString: string;
    hosts?: outputs.VirtualserviceRequestsRateLimitActionRedirectHost[];
    keepQuery?: string;
    paths?: outputs.VirtualserviceRequestsRateLimitActionRedirectPath[];
    port: string;
    protocol: string;
    statusCode?: string;
}

export interface VirtualserviceRequestsRateLimitActionRedirectHost {
    tokens: outputs.VirtualserviceRequestsRateLimitActionRedirectHostToken[];
    type: string;
}

export interface VirtualserviceRequestsRateLimitActionRedirectHostToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface VirtualserviceRequestsRateLimitActionRedirectPath {
    tokens: outputs.VirtualserviceRequestsRateLimitActionRedirectPathToken[];
    type: string;
}

export interface VirtualserviceRequestsRateLimitActionRedirectPathToken {
    endIndex: string;
    startIndex: string;
    strValue: string;
    type: string;
}

export interface VirtualserviceRequestsRateLimitRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface VirtualserviceSamlSpConfig {
    acsIndex?: string;
    authnReqAcsType?: string;
    cookieName: string;
    cookieTimeout?: string;
    entityId: string;
    keys?: outputs.VirtualserviceSamlSpConfigKey[];
    signingSslKeyAndCertificateRef: string;
    singleSignonUrl: string;
    spMetadata: string;
    useIdpSessionTimeout: string;
}

export interface VirtualserviceSamlSpConfigKey {
    aesKey: string;
    hmacKey: string;
    name: string;
}

export interface VirtualserviceService {
    enableHttp2?: string;
    enableSsl?: string;
    horizonInternalPorts?: string;
    isActiveFtpDataPort?: string;
    overrideApplicationProfileRef: string;
    overrideNetworkProfileRef: string;
    port: string;
    portRangeEnd?: string;
}

export interface VirtualserviceServicePoolSelect {
    servicePoolGroupRef: string;
    servicePoolRef: string;
    servicePort: string;
    servicePortRangeEnd?: string;
    serviceProtocol: string;
}

export interface VirtualserviceSidebandProfile {
    ips?: outputs.VirtualserviceSidebandProfileIp[];
    sidebandMaxRequestBodySize?: string;
}

export interface VirtualserviceSidebandProfileIp {
    addr: string;
    type: string;
}

export interface VirtualserviceSnatIp {
    addr: string;
    type: string;
}

export interface VirtualserviceSnatIp6Address {
    addr: string;
    type: string;
}

export interface VirtualserviceSslProfileSelector {
    clientIpLists: outputs.VirtualserviceSslProfileSelectorClientIpList[];
    sslProfileRef: string;
}

export interface VirtualserviceSslProfileSelectorClientIpList {
    addrs?: outputs.VirtualserviceSslProfileSelectorClientIpListAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.VirtualserviceSslProfileSelectorClientIpListPrefix[];
    ranges?: outputs.VirtualserviceSslProfileSelectorClientIpListRange[];
}

export interface VirtualserviceSslProfileSelectorClientIpListAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceSslProfileSelectorClientIpListPrefix {
    ipAddrs: outputs.VirtualserviceSslProfileSelectorClientIpListPrefixIpAddr[];
    mask: string;
}

export interface VirtualserviceSslProfileSelectorClientIpListPrefixIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceSslProfileSelectorClientIpListRange {
    begins: outputs.VirtualserviceSslProfileSelectorClientIpListRangeBegin[];
    ends: outputs.VirtualserviceSslProfileSelectorClientIpListRangeEnd[];
}

export interface VirtualserviceSslProfileSelectorClientIpListRangeBegin {
    addr: string;
    type: string;
}

export interface VirtualserviceSslProfileSelectorClientIpListRangeEnd {
    addr: string;
    type: string;
}

export interface VirtualserviceStaticDnsRecord {
    algorithm?: string;
    cnames?: outputs.VirtualserviceStaticDnsRecordCname[];
    delegated?: string;
    description: string;
    fqdns: string[];
    ip6Addresses?: outputs.VirtualserviceStaticDnsRecordIp6Address[];
    ipAddresses?: outputs.VirtualserviceStaticDnsRecordIpAddress[];
    metadata: string;
    mxRecords?: outputs.VirtualserviceStaticDnsRecordMxRecord[];
    ns?: outputs.VirtualserviceStaticDnsRecordN[];
    numRecordsInResponse?: string;
    serviceLocators?: outputs.VirtualserviceStaticDnsRecordServiceLocator[];
    ttl: string;
    txtRecords?: outputs.VirtualserviceStaticDnsRecordTxtRecord[];
    type: string;
    wildcardMatch?: string;
}

export interface VirtualserviceStaticDnsRecordCname {
    cname: string;
}

export interface VirtualserviceStaticDnsRecordIp6Address {
    ip6Addresses: outputs.VirtualserviceStaticDnsRecordIp6AddressIp6Address[];
}

export interface VirtualserviceStaticDnsRecordIp6AddressIp6Address {
    addr: string;
    type: string;
}

export interface VirtualserviceStaticDnsRecordIpAddress {
    ipAddresses: outputs.VirtualserviceStaticDnsRecordIpAddressIpAddress[];
}

export interface VirtualserviceStaticDnsRecordIpAddressIpAddress {
    addr: string;
    type: string;
}

export interface VirtualserviceStaticDnsRecordMxRecord {
    host: string;
    priority: string;
}

export interface VirtualserviceStaticDnsRecordN {
    ip6Addresses?: outputs.VirtualserviceStaticDnsRecordNIp6Address[];
    ipAddresses?: outputs.VirtualserviceStaticDnsRecordNIpAddress[];
    nsname: string;
}

export interface VirtualserviceStaticDnsRecordNIp6Address {
    addr: string;
    type: string;
}

export interface VirtualserviceStaticDnsRecordNIpAddress {
    addr: string;
    type: string;
}

export interface VirtualserviceStaticDnsRecordServiceLocator {
    port: string;
    priority?: string;
    target?: string;
    weight?: string;
}

export interface VirtualserviceStaticDnsRecordTxtRecord {
    textStr: string;
}

export interface VirtualserviceTopologyPolicy {
    dnsPolicyRef: string;
    index: string;
}

export interface VirtualserviceVhMatch {
    host: string;
    rules: outputs.VirtualserviceVhMatchRule[];
}

export interface VirtualserviceVhMatchRule {
    matches: outputs.VirtualserviceVhMatchRuleMatch[];
    name: string;
}

export interface VirtualserviceVhMatchRuleMatch {
    botDetectionResults?: outputs.VirtualserviceVhMatchRuleMatchBotDetectionResult[];
    clientIps?: outputs.VirtualserviceVhMatchRuleMatchClientIp[];
    cookies?: outputs.VirtualserviceVhMatchRuleMatchCookie[];
    geoMatches?: outputs.VirtualserviceVhMatchRuleMatchGeoMatch[];
    hdrs?: outputs.VirtualserviceVhMatchRuleMatchHdr[];
    hostHdrs?: outputs.VirtualserviceVhMatchRuleMatchHostHdr[];
    ipReputationTypes?: outputs.VirtualserviceVhMatchRuleMatchIpReputationType[];
    methods?: outputs.VirtualserviceVhMatchRuleMatchMethod[];
    paths?: outputs.VirtualserviceVhMatchRuleMatchPath[];
    protocols?: outputs.VirtualserviceVhMatchRuleMatchProtocol[];
    queries?: outputs.VirtualserviceVhMatchRuleMatchQuery[];
    sourceIps?: outputs.VirtualserviceVhMatchRuleMatchSourceIp[];
    tlsFingerprintMatches?: outputs.VirtualserviceVhMatchRuleMatchTlsFingerprintMatch[];
    versions?: outputs.VirtualserviceVhMatchRuleMatchVersion[];
    vsPorts?: outputs.VirtualserviceVhMatchRuleMatchVsPort[];
}

export interface VirtualserviceVhMatchRuleMatchBotDetectionResult {
    classifications?: outputs.VirtualserviceVhMatchRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface VirtualserviceVhMatchRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface VirtualserviceVhMatchRuleMatchClientIp {
    addrs?: outputs.VirtualserviceVhMatchRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.VirtualserviceVhMatchRuleMatchClientIpPrefix[];
    ranges?: outputs.VirtualserviceVhMatchRuleMatchClientIpRange[];
}

export interface VirtualserviceVhMatchRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchClientIpPrefix {
    ipAddrs: outputs.VirtualserviceVhMatchRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface VirtualserviceVhMatchRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchClientIpRange {
    begins: outputs.VirtualserviceVhMatchRuleMatchClientIpRangeBegin[];
    ends: outputs.VirtualserviceVhMatchRuleMatchClientIpRangeEnd[];
}

export interface VirtualserviceVhMatchRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchCookie {
    matchCase?: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface VirtualserviceVhMatchRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface VirtualserviceVhMatchRuleMatchHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface VirtualserviceVhMatchRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface VirtualserviceVhMatchRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface VirtualserviceVhMatchRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface VirtualserviceVhMatchRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface VirtualserviceVhMatchRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface VirtualserviceVhMatchRuleMatchQuery {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface VirtualserviceVhMatchRuleMatchSourceIp {
    addrs?: outputs.VirtualserviceVhMatchRuleMatchSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.VirtualserviceVhMatchRuleMatchSourceIpPrefix[];
    ranges?: outputs.VirtualserviceVhMatchRuleMatchSourceIpRange[];
}

export interface VirtualserviceVhMatchRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchSourceIpPrefix {
    ipAddrs: outputs.VirtualserviceVhMatchRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface VirtualserviceVhMatchRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchSourceIpRange {
    begins: outputs.VirtualserviceVhMatchRuleMatchSourceIpRangeBegin[];
    ends: outputs.VirtualserviceVhMatchRuleMatchSourceIpRangeEnd[];
}

export interface VirtualserviceVhMatchRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface VirtualserviceVhMatchRuleMatchTlsFingerprintMatch {
    fingerprints?: string[];
    matchOperation: string;
    stringGroupRefs?: string[];
}

export interface VirtualserviceVhMatchRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface VirtualserviceVhMatchRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface VirtualserviceVip {
    autoAllocateFloatingIp?: string;
    autoAllocateIp?: string;
    autoAllocateIpType?: string;
    availabilityZone: string;
    aviAllocatedFip?: string;
    aviAllocatedVip?: string;
    discoveredNetworks?: outputs.VirtualserviceVipDiscoveredNetwork[];
    enabled?: string;
    floatingIp6s?: outputs.VirtualserviceVipFloatingIp6[];
    floatingIps?: outputs.VirtualserviceVipFloatingIp[];
    floatingSubnet6Uuid: string;
    floatingSubnetUuid: string;
    ip6Addresses?: outputs.VirtualserviceVipIp6Address[];
    ipAddresses?: outputs.VirtualserviceVipIpAddress[];
    ipamNetworkSubnets?: outputs.VirtualserviceVipIpamNetworkSubnet[];
    networkRef: string;
    placementNetworks?: outputs.VirtualserviceVipPlacementNetwork[];
    portUuid: string;
    prefixLength?: string;
    subnet6Uuid: string;
    subnet6s?: outputs.VirtualserviceVipSubnet6[];
    subnetUuid: string;
    subnets?: outputs.VirtualserviceVipSubnet[];
    vipId: string;
}

export interface VirtualserviceVipDiscoveredNetwork {
    networkRef: string;
    subnet6s?: outputs.VirtualserviceVipDiscoveredNetworkSubnet6[];
    subnets?: outputs.VirtualserviceVipDiscoveredNetworkSubnet[];
}

export interface VirtualserviceVipDiscoveredNetworkSubnet {
    ipAddrs: outputs.VirtualserviceVipDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface VirtualserviceVipDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.VirtualserviceVipDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface VirtualserviceVipDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVipDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVipFloatingIp {
    addr: string;
    type: string;
}

export interface VirtualserviceVipFloatingIp6 {
    addr: string;
    type: string;
}

export interface VirtualserviceVipIp6Address {
    addr: string;
    type: string;
}

export interface VirtualserviceVipIpAddress {
    addr: string;
    type: string;
}

export interface VirtualserviceVipIpamNetworkSubnet {
    networkRef: string;
    subnet6Uuid: string;
    subnet6s?: outputs.VirtualserviceVipIpamNetworkSubnetSubnet6[];
    subnetUuid: string;
    subnets?: outputs.VirtualserviceVipIpamNetworkSubnetSubnet[];
}

export interface VirtualserviceVipIpamNetworkSubnetSubnet {
    ipAddrs: outputs.VirtualserviceVipIpamNetworkSubnetSubnetIpAddr[];
    mask: string;
}

export interface VirtualserviceVipIpamNetworkSubnetSubnet6 {
    ipAddrs: outputs.VirtualserviceVipIpamNetworkSubnetSubnet6IpAddr[];
    mask: string;
}

export interface VirtualserviceVipIpamNetworkSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVipIpamNetworkSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVipPlacementNetwork {
    networkRef: string;
    subnet6s?: outputs.VirtualserviceVipPlacementNetworkSubnet6[];
    subnets?: outputs.VirtualserviceVipPlacementNetworkSubnet[];
}

export interface VirtualserviceVipPlacementNetworkSubnet {
    ipAddrs: outputs.VirtualserviceVipPlacementNetworkSubnetIpAddr[];
    mask: string;
}

export interface VirtualserviceVipPlacementNetworkSubnet6 {
    ipAddrs: outputs.VirtualserviceVipPlacementNetworkSubnet6IpAddr[];
    mask: string;
}

export interface VirtualserviceVipPlacementNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVipPlacementNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVipSubnet {
    ipAddrs: outputs.VirtualserviceVipSubnetIpAddr[];
    mask: string;
}

export interface VirtualserviceVipSubnet6 {
    ipAddrs: outputs.VirtualserviceVipSubnet6IpAddr[];
    mask: string;
}

export interface VirtualserviceVipSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVipSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VirtualserviceVsDatascript {
    index: string;
    vsDatascriptSetRef: string;
}

export interface VrfcontextAttr {
    key: string;
    value: string;
}

export interface VrfcontextBfdProfile {
    minrx?: string;
    mintx?: string;
    multi?: string;
}

export interface VrfcontextBgpProfile {
    communities?: string[];
    holdTime?: string;
    ibgp: string;
    ipCommunities?: outputs.VrfcontextBgpProfileIpCommunity[];
    keepaliveInterval?: string;
    localAs: string;
    localPreference: string;
    numAsPathPrepend: string;
    peers?: outputs.VrfcontextBgpProfilePeer[];
    routingOptions?: outputs.VrfcontextBgpProfileRoutingOption[];
    sendCommunity?: string;
    shutdown?: string;
}

export interface VrfcontextBgpProfileIpCommunity {
    communities: string[];
    ipBegins: outputs.VrfcontextBgpProfileIpCommunityIpBegin[];
    ipEnds?: outputs.VrfcontextBgpProfileIpCommunityIpEnd[];
}

export interface VrfcontextBgpProfileIpCommunityIpBegin {
    addr: string;
    type: string;
}

export interface VrfcontextBgpProfileIpCommunityIpEnd {
    addr: string;
    type: string;
}

export interface VrfcontextBgpProfilePeer {
    advertiseSnatIp?: string;
    advertiseVip?: string;
    advertisementInterval?: string;
    bfd?: string;
    connectTimer?: string;
    ebgpMultihop?: string;
    holdTime: string;
    ibgpLocalAsOverride: string;
    keepaliveInterval: string;
    label: string;
    localAs: string;
    md5Secret: string;
    networkRef: string;
    peerIp6s?: outputs.VrfcontextBgpProfilePeerPeerIp6[];
    peerIps?: outputs.VrfcontextBgpProfilePeerPeerIp[];
    remoteAs: string;
    shutdown?: string;
    subnet6s?: outputs.VrfcontextBgpProfilePeerSubnet6[];
    subnets?: outputs.VrfcontextBgpProfilePeerSubnet[];
}

export interface VrfcontextBgpProfilePeerPeerIp {
    addr: string;
    type: string;
}

export interface VrfcontextBgpProfilePeerPeerIp6 {
    addr: string;
    type: string;
}

export interface VrfcontextBgpProfilePeerSubnet {
    ipAddrs: outputs.VrfcontextBgpProfilePeerSubnetIpAddr[];
    mask: string;
}

export interface VrfcontextBgpProfilePeerSubnet6 {
    ipAddrs: outputs.VrfcontextBgpProfilePeerSubnet6IpAddr[];
    mask: string;
}

export interface VrfcontextBgpProfilePeerSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VrfcontextBgpProfilePeerSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VrfcontextBgpProfileRoutingOption {
    advertiseDefaultRoute: string;
    advertiseLearnedRoutes: string;
    label: string;
    learnOnlyDefaultRoute: string;
    learnRoutes: string;
    maxLearnLimit?: string;
}

export interface VrfcontextConfigpbAttribute {
    version: string;
}

export interface VrfcontextDebugvrfcontext {
    commandBufferInterval?: string;
    commandBufferSize?: string;
    flags?: outputs.VrfcontextDebugvrfcontextFlag[];
}

export interface VrfcontextDebugvrfcontextFlag {
    flag: string;
}

export interface VrfcontextGatewayMon {
    gatewayIps: outputs.VrfcontextGatewayMonGatewayIp[];
    gatewayMonitorFailThreshold?: string;
    gatewayMonitorInterval?: string;
    gatewayMonitorSuccessThreshold?: string;
    subnets?: outputs.VrfcontextGatewayMonSubnet[];
}

export interface VrfcontextGatewayMonGatewayIp {
    addr: string;
    type: string;
}

export interface VrfcontextGatewayMonSubnet {
    ipAddrs: outputs.VrfcontextGatewayMonSubnetIpAddr[];
    mask: string;
}

export interface VrfcontextGatewayMonSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VrfcontextInternalGatewayMonitor {
    disableGatewayMonitor?: string;
    gatewayMonitorFailureThreshold?: string;
    gatewayMonitorInterval?: string;
    gatewayMonitorSuccessThreshold?: string;
}

export interface VrfcontextMarker {
    key: string;
    values?: string[];
}

export interface VrfcontextStaticRoute {
    disableGatewayMonitor: string;
    ifName: string;
    labels?: outputs.VrfcontextStaticRouteLabel[];
    nextHops: outputs.VrfcontextStaticRouteNextHop[];
    prefixes: outputs.VrfcontextStaticRoutePrefix[];
    routeId: string;
}

export interface VrfcontextStaticRouteLabel {
    key: string;
    value: string;
}

export interface VrfcontextStaticRouteNextHop {
    addr: string;
    type: string;
}

export interface VrfcontextStaticRoutePrefix {
    ipAddrs: outputs.VrfcontextStaticRoutePrefixIpAddr[];
    mask: string;
}

export interface VrfcontextStaticRoutePrefixIpAddr {
    addr: string;
    type: string;
}

export interface VsdatascriptsetConfigpbAttribute {
    version: string;
}

export interface VsdatascriptsetDatascript {
    evt: string;
    script: string;
}

export interface VsdatascriptsetMarker {
    key: string;
    values?: string[];
}

export interface VsdatascriptsetRateLimiter {
    burstSz?: string;
    count?: string;
    name: string;
    period?: string;
}

export interface VsgsConfigpbAttribute {
    version: string;
}

export interface VsvipConfigpbAttribute {
    version: string;
}

export interface VsvipDnsInfo {
    algorithm?: string;
    cnames?: outputs.VsvipDnsInfoCname[];
    fqdn: string;
    metadata: string;
    numRecordsInResponse: string;
    ttl: string;
    type?: string;
}

export interface VsvipDnsInfoCname {
    cname: string;
}

export interface VsvipIpamSelector {
    labels: outputs.VsvipIpamSelectorLabel[];
    type: string;
}

export interface VsvipIpamSelectorLabel {
    key: string;
    value: string;
}

export interface VsvipMarker {
    key: string;
    values?: string[];
}

export interface VsvipVip {
    autoAllocateFloatingIp?: string;
    autoAllocateIp?: string;
    autoAllocateIpType?: string;
    availabilityZone: string;
    aviAllocatedFip?: string;
    aviAllocatedVip?: string;
    discoveredNetworks?: outputs.VsvipVipDiscoveredNetwork[];
    enabled?: string;
    floatingIp6s?: outputs.VsvipVipFloatingIp6[];
    floatingIps?: outputs.VsvipVipFloatingIp[];
    floatingSubnet6Uuid: string;
    floatingSubnetUuid: string;
    ip6Addresses?: outputs.VsvipVipIp6Address[];
    ipAddresses?: outputs.VsvipVipIpAddress[];
    ipamNetworkSubnets?: outputs.VsvipVipIpamNetworkSubnet[];
    networkRef: string;
    placementNetworks?: outputs.VsvipVipPlacementNetwork[];
    portUuid: string;
    prefixLength?: string;
    subnet6Uuid: string;
    subnet6s?: outputs.VsvipVipSubnet6[];
    subnetUuid: string;
    subnets?: outputs.VsvipVipSubnet[];
    vipId: string;
}

export interface VsvipVipDiscoveredNetwork {
    networkRef: string;
    subnet6s?: outputs.VsvipVipDiscoveredNetworkSubnet6[];
    subnets?: outputs.VsvipVipDiscoveredNetworkSubnet[];
}

export interface VsvipVipDiscoveredNetworkSubnet {
    ipAddrs: outputs.VsvipVipDiscoveredNetworkSubnetIpAddr[];
    mask: string;
}

export interface VsvipVipDiscoveredNetworkSubnet6 {
    ipAddrs: outputs.VsvipVipDiscoveredNetworkSubnet6IpAddr[];
    mask: string;
}

export interface VsvipVipDiscoveredNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VsvipVipDiscoveredNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VsvipVipFloatingIp {
    addr: string;
    type: string;
}

export interface VsvipVipFloatingIp6 {
    addr: string;
    type: string;
}

export interface VsvipVipIp6Address {
    addr: string;
    type: string;
}

export interface VsvipVipIpAddress {
    addr: string;
    type: string;
}

export interface VsvipVipIpamNetworkSubnet {
    networkRef: string;
    subnet6Uuid: string;
    subnet6s?: outputs.VsvipVipIpamNetworkSubnetSubnet6[];
    subnetUuid: string;
    subnets?: outputs.VsvipVipIpamNetworkSubnetSubnet[];
}

export interface VsvipVipIpamNetworkSubnetSubnet {
    ipAddrs: outputs.VsvipVipIpamNetworkSubnetSubnetIpAddr[];
    mask: string;
}

export interface VsvipVipIpamNetworkSubnetSubnet6 {
    ipAddrs: outputs.VsvipVipIpamNetworkSubnetSubnet6IpAddr[];
    mask: string;
}

export interface VsvipVipIpamNetworkSubnetSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VsvipVipIpamNetworkSubnetSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VsvipVipPlacementNetwork {
    networkRef: string;
    subnet6s?: outputs.VsvipVipPlacementNetworkSubnet6[];
    subnets?: outputs.VsvipVipPlacementNetworkSubnet[];
}

export interface VsvipVipPlacementNetworkSubnet {
    ipAddrs: outputs.VsvipVipPlacementNetworkSubnetIpAddr[];
    mask: string;
}

export interface VsvipVipPlacementNetworkSubnet6 {
    ipAddrs: outputs.VsvipVipPlacementNetworkSubnet6IpAddr[];
    mask: string;
}

export interface VsvipVipPlacementNetworkSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VsvipVipPlacementNetworkSubnetIpAddr {
    addr: string;
    type: string;
}

export interface VsvipVipSubnet {
    ipAddrs: outputs.VsvipVipSubnetIpAddr[];
    mask: string;
}

export interface VsvipVipSubnet6 {
    ipAddrs: outputs.VsvipVipSubnet6IpAddr[];
    mask: string;
}

export interface VsvipVipSubnet6IpAddr {
    addr: string;
    type: string;
}

export interface VsvipVipSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafapplicationsignatureproviderAvailableApplication {
    application: string;
    lastChangedRulesetVersion: string;
    numberOfRules: string;
}

export interface WafapplicationsignatureproviderConfigpbAttribute {
    version: string;
}

export interface WafapplicationsignatureproviderServiceStatus {
    error: string;
    lastSuccessfulUpdateChecks?: outputs.WafapplicationsignatureproviderServiceStatusLastSuccessfulUpdateCheck[];
    upstreamSyncTimestamps?: outputs.WafapplicationsignatureproviderServiceStatusUpstreamSyncTimestamp[];
}

export interface WafapplicationsignatureproviderServiceStatusLastSuccessfulUpdateCheck {
    secs: string;
    usecs: string;
}

export interface WafapplicationsignatureproviderServiceStatusUpstreamSyncTimestamp {
    secs: string;
    usecs: string;
}

export interface WafapplicationsignatureproviderSignature {
    enable?: string;
    excludeLists?: outputs.WafapplicationsignatureproviderSignatureExcludeList[];
    index: string;
    isSensitive?: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags?: string[];
}

export interface WafapplicationsignatureproviderSignatureExcludeList {
    clientSubnets?: outputs.WafapplicationsignatureproviderSignatureExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafapplicationsignatureproviderSignatureExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafapplicationsignatureproviderSignatureExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafapplicationsignatureproviderSignatureExcludeListClientSubnet {
    ipAddrs: outputs.WafapplicationsignatureproviderSignatureExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafapplicationsignatureproviderSignatureExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafapplicationsignatureproviderSignatureExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafapplicationsignatureproviderSignatureExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafcrsConfigpbAttribute {
    version: string;
}

export interface WafcrsFile {
    data: string;
    name: string;
    type?: string;
}

export interface WafcrsGroup {
    enable?: string;
    excludeLists?: outputs.WafcrsGroupExcludeList[];
    index: string;
    name: string;
    rules?: outputs.WafcrsGroupRule[];
}

export interface WafcrsGroupExcludeList {
    clientSubnets?: outputs.WafcrsGroupExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafcrsGroupExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafcrsGroupExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafcrsGroupExcludeListClientSubnet {
    ipAddrs: outputs.WafcrsGroupExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafcrsGroupExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafcrsGroupExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafcrsGroupExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafcrsGroupRule {
    enable?: string;
    excludeLists?: outputs.WafcrsGroupRuleExcludeList[];
    index: string;
    isSensitive?: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags?: string[];
}

export interface WafcrsGroupRuleExcludeList {
    clientSubnets?: outputs.WafcrsGroupRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafcrsGroupRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafcrsGroupRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafcrsGroupRuleExcludeListClientSubnet {
    ipAddrs: outputs.WafcrsGroupRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafcrsGroupRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafcrsGroupRuleExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafcrsGroupRuleExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafcrsMarker {
    key: string;
    values?: string[];
}

export interface WafpolicyAllowlist {
    rules?: outputs.WafpolicyAllowlistRule[];
}

export interface WafpolicyAllowlistRule {
    actions: string[];
    description: string;
    enable?: string;
    index: string;
    matches: outputs.WafpolicyAllowlistRuleMatch[];
    name: string;
    samplingPercent?: string;
}

export interface WafpolicyAllowlistRuleMatch {
    botDetectionResults?: outputs.WafpolicyAllowlistRuleMatchBotDetectionResult[];
    clientIps?: outputs.WafpolicyAllowlistRuleMatchClientIp[];
    cookies?: outputs.WafpolicyAllowlistRuleMatchCookie[];
    geoMatches?: outputs.WafpolicyAllowlistRuleMatchGeoMatch[];
    hdrs?: outputs.WafpolicyAllowlistRuleMatchHdr[];
    hostHdrs?: outputs.WafpolicyAllowlistRuleMatchHostHdr[];
    ipReputationTypes?: outputs.WafpolicyAllowlistRuleMatchIpReputationType[];
    methods?: outputs.WafpolicyAllowlistRuleMatchMethod[];
    paths?: outputs.WafpolicyAllowlistRuleMatchPath[];
    protocols?: outputs.WafpolicyAllowlistRuleMatchProtocol[];
    queries?: outputs.WafpolicyAllowlistRuleMatchQuery[];
    sourceIps?: outputs.WafpolicyAllowlistRuleMatchSourceIp[];
    tlsFingerprintMatches?: outputs.WafpolicyAllowlistRuleMatchTlsFingerprintMatch[];
    versions?: outputs.WafpolicyAllowlistRuleMatchVersion[];
    vsPorts?: outputs.WafpolicyAllowlistRuleMatchVsPort[];
}

export interface WafpolicyAllowlistRuleMatchBotDetectionResult {
    classifications?: outputs.WafpolicyAllowlistRuleMatchBotDetectionResultClassification[];
    matchOperation: string;
}

export interface WafpolicyAllowlistRuleMatchBotDetectionResultClassification {
    type: string;
    userDefinedType: string;
}

export interface WafpolicyAllowlistRuleMatchClientIp {
    addrs?: outputs.WafpolicyAllowlistRuleMatchClientIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.WafpolicyAllowlistRuleMatchClientIpPrefix[];
    ranges?: outputs.WafpolicyAllowlistRuleMatchClientIpRange[];
}

export interface WafpolicyAllowlistRuleMatchClientIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchClientIpPrefix {
    ipAddrs: outputs.WafpolicyAllowlistRuleMatchClientIpPrefixIpAddr[];
    mask: string;
}

export interface WafpolicyAllowlistRuleMatchClientIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchClientIpRange {
    begins: outputs.WafpolicyAllowlistRuleMatchClientIpRangeBegin[];
    ends: outputs.WafpolicyAllowlistRuleMatchClientIpRangeEnd[];
}

export interface WafpolicyAllowlistRuleMatchClientIpRangeBegin {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchClientIpRangeEnd {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchCookie {
    matchCase?: string;
    matchCriteria: string;
    name: string;
    value: string;
}

export interface WafpolicyAllowlistRuleMatchGeoMatch {
    attribute: string;
    matchOperation: string;
    values: string[];
}

export interface WafpolicyAllowlistRuleMatchHdr {
    hdr: string;
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface WafpolicyAllowlistRuleMatchHostHdr {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface WafpolicyAllowlistRuleMatchIpReputationType {
    matchOperation: string;
    reputationTypes: string[];
}

export interface WafpolicyAllowlistRuleMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface WafpolicyAllowlistRuleMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface WafpolicyAllowlistRuleMatchProtocol {
    matchCriteria: string;
    protocols: string;
}

export interface WafpolicyAllowlistRuleMatchQuery {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface WafpolicyAllowlistRuleMatchSourceIp {
    addrs?: outputs.WafpolicyAllowlistRuleMatchSourceIpAddr[];
    groupRefs?: string[];
    matchCriteria: string;
    prefixes?: outputs.WafpolicyAllowlistRuleMatchSourceIpPrefix[];
    ranges?: outputs.WafpolicyAllowlistRuleMatchSourceIpRange[];
}

export interface WafpolicyAllowlistRuleMatchSourceIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchSourceIpPrefix {
    ipAddrs: outputs.WafpolicyAllowlistRuleMatchSourceIpPrefixIpAddr[];
    mask: string;
}

export interface WafpolicyAllowlistRuleMatchSourceIpPrefixIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchSourceIpRange {
    begins: outputs.WafpolicyAllowlistRuleMatchSourceIpRangeBegin[];
    ends: outputs.WafpolicyAllowlistRuleMatchSourceIpRangeEnd[];
}

export interface WafpolicyAllowlistRuleMatchSourceIpRangeBegin {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchSourceIpRangeEnd {
    addr: string;
    type: string;
}

export interface WafpolicyAllowlistRuleMatchTlsFingerprintMatch {
    fingerprints?: string[];
    matchOperation: string;
    stringGroupRefs?: string[];
}

export interface WafpolicyAllowlistRuleMatchVersion {
    matchCriteria: string;
    versions: string[];
}

export interface WafpolicyAllowlistRuleMatchVsPort {
    matchCriteria: string;
    ports: number[];
}

export interface WafpolicyApplicationSignature {
    providerRef: string;
    resolvedRules?: outputs.WafpolicyApplicationSignatureResolvedRule[];
    ruleOverrides?: outputs.WafpolicyApplicationSignatureRuleOverride[];
    rulesetVersion: string;
    selectedApplications?: string[];
}

export interface WafpolicyApplicationSignatureResolvedRule {
    enable?: string;
    excludeLists?: outputs.WafpolicyApplicationSignatureResolvedRuleExcludeList[];
    index: string;
    isSensitive?: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags?: string[];
}

export interface WafpolicyApplicationSignatureResolvedRuleExcludeList {
    clientSubnets?: outputs.WafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyApplicationSignatureResolvedRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyApplicationSignatureResolvedRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyApplicationSignatureResolvedRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyApplicationSignatureResolvedRuleExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyApplicationSignatureResolvedRuleExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyApplicationSignatureRuleOverride {
    enable: string;
    excludeLists?: outputs.WafpolicyApplicationSignatureRuleOverrideExcludeList[];
    mode: string;
    ruleId: string;
}

export interface WafpolicyApplicationSignatureRuleOverrideExcludeList {
    clientSubnets?: outputs.WafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyApplicationSignatureRuleOverrideExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyApplicationSignatureRuleOverrideExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyApplicationSignatureRuleOverrideExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyApplicationSignatureRuleOverrideExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyApplicationSignatureRuleOverrideExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyConfidenceOverride {
    confidHighValue?: string;
    confidLowValue?: string;
    confidProbableValue?: string;
    confidVeryHighValue?: string;
}

export interface WafpolicyConfigpbAttribute {
    version: string;
}

export interface WafpolicyCrsOverride {
    enable: string;
    excludeLists?: outputs.WafpolicyCrsOverrideExcludeList[];
    mode: string;
    name: string;
    ruleOverrides?: outputs.WafpolicyCrsOverrideRuleOverride[];
}

export interface WafpolicyCrsOverrideExcludeList {
    clientSubnets?: outputs.WafpolicyCrsOverrideExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyCrsOverrideExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyCrsOverrideExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyCrsOverrideExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyCrsOverrideExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyCrsOverrideExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyCrsOverrideExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyCrsOverrideExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyCrsOverrideRuleOverride {
    enable: string;
    excludeLists?: outputs.WafpolicyCrsOverrideRuleOverrideExcludeList[];
    mode: string;
    ruleId: string;
}

export interface WafpolicyCrsOverrideRuleOverrideExcludeList {
    clientSubnets?: outputs.WafpolicyCrsOverrideRuleOverrideExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyCrsOverrideRuleOverrideExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyCrsOverrideRuleOverrideExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyCrsOverrideRuleOverrideExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyCrsOverrideRuleOverrideExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyCrsOverrideRuleOverrideExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyCrsOverrideRuleOverrideExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyCrsOverrideRuleOverrideExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyLearningParam {
    enableLearnFromBots?: string;
    enablePerUriLearning?: string;
    learnFromAuthenticatedClientsOnly?: string;
    learnFromBots?: outputs.WafpolicyLearningParamLearnFromBot[];
    maxParams?: string;
    maxUris?: string;
    minHitsToLearn?: string;
    samplingPercent?: string;
    trustedIpgroupRef: string;
    updateInterval?: string;
}

export interface WafpolicyLearningParamLearnFromBot {
    classifications?: outputs.WafpolicyLearningParamLearnFromBotClassification[];
    matchOperation: string;
}

export interface WafpolicyLearningParamLearnFromBotClassification {
    type: string;
    userDefinedType: string;
}

export interface WafpolicyMarker {
    key: string;
    values?: string[];
}

export interface WafpolicyPositiveSecurityModel {
    groupRefs?: string[];
}

export interface WafpolicyPostCrsGroup {
    enable?: string;
    excludeLists?: outputs.WafpolicyPostCrsGroupExcludeList[];
    index: string;
    name: string;
    rules?: outputs.WafpolicyPostCrsGroupRule[];
}

export interface WafpolicyPostCrsGroupExcludeList {
    clientSubnets?: outputs.WafpolicyPostCrsGroupExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyPostCrsGroupExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyPostCrsGroupExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyPostCrsGroupExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyPostCrsGroupExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyPostCrsGroupExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyPostCrsGroupExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyPostCrsGroupExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyPostCrsGroupRule {
    enable?: string;
    excludeLists?: outputs.WafpolicyPostCrsGroupRuleExcludeList[];
    index: string;
    isSensitive?: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags?: string[];
}

export interface WafpolicyPostCrsGroupRuleExcludeList {
    clientSubnets?: outputs.WafpolicyPostCrsGroupRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyPostCrsGroupRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyPostCrsGroupRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyPostCrsGroupRuleExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyPostCrsGroupRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyPostCrsGroupRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyPostCrsGroupRuleExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyPostCrsGroupRuleExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyPreCrsGroup {
    enable?: string;
    excludeLists?: outputs.WafpolicyPreCrsGroupExcludeList[];
    index: string;
    name: string;
    rules?: outputs.WafpolicyPreCrsGroupRule[];
}

export interface WafpolicyPreCrsGroupExcludeList {
    clientSubnets?: outputs.WafpolicyPreCrsGroupExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyPreCrsGroupExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyPreCrsGroupExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyPreCrsGroupExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyPreCrsGroupExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyPreCrsGroupExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyPreCrsGroupExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyPreCrsGroupExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyPreCrsGroupRule {
    enable?: string;
    excludeLists?: outputs.WafpolicyPreCrsGroupRuleExcludeList[];
    index: string;
    isSensitive?: string;
    mode: string;
    name: string;
    paranoiaLevel: string;
    phase: string;
    rule: string;
    ruleId: string;
    tags?: string[];
}

export interface WafpolicyPreCrsGroupRuleExcludeList {
    clientSubnets?: outputs.WafpolicyPreCrsGroupRuleExcludeListClientSubnet[];
    description: string;
    matchElement: string;
    matchElementCriterias?: outputs.WafpolicyPreCrsGroupRuleExcludeListMatchElementCriteria[];
    uriMatchCriterias?: outputs.WafpolicyPreCrsGroupRuleExcludeListUriMatchCriteria[];
    uriPath: string;
}

export interface WafpolicyPreCrsGroupRuleExcludeListClientSubnet {
    ipAddrs: outputs.WafpolicyPreCrsGroupRuleExcludeListClientSubnetIpAddr[];
    mask: string;
}

export interface WafpolicyPreCrsGroupRuleExcludeListClientSubnetIpAddr {
    addr: string;
    type: string;
}

export interface WafpolicyPreCrsGroupRuleExcludeListMatchElementCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyPreCrsGroupRuleExcludeListUriMatchCriteria {
    matchCase?: string;
    matchOp?: string;
}

export interface WafpolicyRequiredDataFile {
    name: string;
    type: string;
}

export interface WafpolicypsmgroupConfigpbAttribute {
    version: string;
}

export interface WafpolicypsmgroupLocation {
    description: string;
    index: string;
    matches?: outputs.WafpolicypsmgroupLocationMatch[];
    name: string;
    rules?: outputs.WafpolicypsmgroupLocationRule[];
}

export interface WafpolicypsmgroupLocationMatch {
    hosts?: outputs.WafpolicypsmgroupLocationMatchHost[];
    methods?: outputs.WafpolicypsmgroupLocationMatchMethod[];
    paths?: outputs.WafpolicypsmgroupLocationMatchPath[];
}

export interface WafpolicypsmgroupLocationMatchHost {
    matchCase?: string;
    matchCriteria: string;
    values?: string[];
}

export interface WafpolicypsmgroupLocationMatchMethod {
    matchCriteria: string;
    methods: string[];
}

export interface WafpolicypsmgroupLocationMatchPath {
    matchCase?: string;
    matchCriteria: string;
    matchDecodedString?: string;
    matchStrs?: string[];
    stringGroupRefs?: string[];
}

export interface WafpolicypsmgroupLocationRule {
    description: string;
    enable?: string;
    index: string;
    matchCase?: string;
    matchElements?: outputs.WafpolicypsmgroupLocationRuleMatchElement[];
    matchValueMaxLength: string;
    matchValuePattern: string;
    matchValueStringGroupKey: string;
    matchValueStringGroupRef: string;
    mode: string;
    name: string;
    paranoiaLevel?: string;
    ruleId: string;
}

export interface WafpolicypsmgroupLocationRuleMatchElement {
    excluded?: string;
    index: string;
    matchCase?: string;
    matchOp?: string;
    name: string;
    subElement: string;
}

export interface WafpolicypsmgroupMarker {
    key: string;
    values?: string[];
}

export interface WafprofileConfig {
    allowedHttpVersions?: string[];
    allowedMethods?: string[];
    allowedRequestContentTypeCharsets?: string[];
    argumentSeparator?: string;
    clientRequestMaxBodySize?: string;
    contentTypeMappings?: outputs.WafprofileConfigContentTypeMapping[];
    cookieFormatVersion?: string;
    ignoreIncompleteRequestBodyError?: string;
    maxExecutionTime?: string;
    regexMatchLimit?: string;
    regexRecursionLimit?: string;
    requestBodyDefaultAction?: string;
    requestHdrDefaultAction?: string;
    responseBodyDefaultAction?: string;
    responseHdrDefaultAction?: string;
    restrictedExtensions?: string[];
    restrictedHeaders?: string[];
    sendStatusHeader?: string;
    serverResponseMaxBodySize?: string;
    staticExtensions?: string[];
    statusCodeForRejectedRequests?: string;
    statusHeaderName?: string;
    xmlXxeProtection?: string;
}

export interface WafprofileConfigContentTypeMapping {
    contentType: string;
    matchOp?: string;
    requestBodyParser: string;
}

export interface WafprofileConfigpbAttribute {
    version: string;
}

export interface WafprofileFile {
    data: string;
    name: string;
    type?: string;
}

export interface WafprofileMarker {
    key: string;
    values?: string[];
}

export interface WebapputConfigpbAttribute {
    version: string;
}

export interface WebapputMandatoryTest {
    mandatoryMessage: outputs.WebapputMandatoryTestMandatoryMessage[];
    mandatoryMessages: outputs.WebapputMandatoryTestMandatoryMessage[];
    mandatoryString: string;
    mandatoryStrings: string[];
}

export interface WebapputMandatoryTestMandatoryMessage {
    mandatoryMessage: outputs.WebapputMandatoryTestMandatoryMessageMandatoryMessage[];
    mandatoryMessages: outputs.WebapputMandatoryTestMandatoryMessageMandatoryMessage[];
    mandatoryString: string;
    mandatoryStrings: string[];
}

export interface WebapputMandatoryTestMandatoryMessageMandatoryMessage {
    optionalString: string;
}

export interface WebapputSensitiveTest {
    sensitiveMessage?: outputs.WebapputSensitiveTestSensitiveMessage[];
    sensitiveMessages?: outputs.WebapputSensitiveTestSensitiveMessage[];
    sensitiveString: string;
}

export interface WebapputSensitiveTestSensitiveMessage {
    sensitiveMessage?: outputs.WebapputSensitiveTestSensitiveMessageSensitiveMessage[];
    sensitiveMessages?: outputs.WebapputSensitiveTestSensitiveMessageSensitiveMessage[];
    sensitiveString: string;
}

export interface WebapputSensitiveTestSensitiveMessageSensitiveMessage {
    optionalSensitiveString: string;
}

export interface WebapputStringLengthTest {
    stringLengthMessage?: outputs.WebapputStringLengthTestStringLengthMessage[];
    stringLengthMessages?: outputs.WebapputStringLengthTestStringLengthMessage[];
    testString: string;
    testStrings?: string[];
}

export interface WebapputStringLengthTestStringLengthMessage {
    stringLengthMessage?: outputs.WebapputStringLengthTestStringLengthMessageStringLengthMessage[];
    stringLengthMessages?: outputs.WebapputStringLengthTestStringLengthMessageStringLengthMessage[];
    testString: string;
    testStrings?: string[];
}

export interface WebapputStringLengthTestStringLengthMessageStringLengthMessage {
    testString: string;
}

export interface WebhookConfigpbAttribute {
    version: string;
}

export interface WebhookMarker {
    key: string;
    values?: string[];
}

