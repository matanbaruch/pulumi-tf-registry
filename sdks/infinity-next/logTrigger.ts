// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class LogTrigger extends pulumi.CustomResource {
    /**
     * Get an existing LogTrigger resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: LogTriggerState, opts?: pulumi.CustomResourceOptions): LogTrigger {
        return new LogTrigger(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'infinity-next:index/logTrigger:LogTrigger';

    /**
     * Returns true if the given object is an instance of LogTrigger.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is LogTrigger {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === LogTrigger.__pulumiType;
    }

    /**
     * Log Access Control accepts
     */
    public readonly accessControlAllowEvents!: pulumi.Output<boolean | undefined>;
    /**
     * Log Access Control drops
     */
    public readonly accessControlDropEvents!: pulumi.Output<boolean | undefined>;
    public readonly cefIpAddress!: pulumi.Output<string | undefined>;
    public readonly cefPort!: pulumi.Output<number | undefined>;
    public readonly extendLogging!: pulumi.Output<boolean | undefined>;
    /**
     * Minimum severity of events that will trigger extended logging: High or Critical
     */
    public readonly extendLoggingMinSeverity!: pulumi.Output<string | undefined>;
    public readonly logToAgent!: pulumi.Output<boolean | undefined>;
    public readonly logToCef!: pulumi.Output<boolean | undefined>;
    public readonly logToCloud!: pulumi.Output<boolean | undefined>;
    public readonly logToSyslog!: pulumi.Output<boolean | undefined>;
    /**
     * The name of the resource, also acts as its unique ID
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Add response body to log if true
     */
    public readonly responseBody!: pulumi.Output<boolean | undefined>;
    /**
     * Add response code to log if true
     */
    public readonly responseCode!: pulumi.Output<boolean | undefined>;
    public readonly syslogIpAddress!: pulumi.Output<string | undefined>;
    public readonly syslogPort!: pulumi.Output<number | undefined>;
    /**
     * Log Threat Prevention Prevents
     */
    public readonly threatPreventionDetectEvents!: pulumi.Output<boolean | undefined>;
    /**
     * Log Threat Prevention Detects
     */
    public readonly threatPreventionPreventEvents!: pulumi.Output<boolean | undefined>;
    /**
     * The verbosity of the log: Standard, Minimal or Extended
     */
    public readonly verbosity!: pulumi.Output<string | undefined>;
    public readonly webBody!: pulumi.Output<boolean | undefined>;
    public readonly webHeaders!: pulumi.Output<boolean | undefined>;
    public readonly webRequests!: pulumi.Output<boolean | undefined>;
    public readonly webUrlPath!: pulumi.Output<boolean | undefined>;
    public readonly webUrlQuery!: pulumi.Output<boolean | undefined>;

    /**
     * Create a LogTrigger resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: LogTriggerArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: LogTriggerArgs | LogTriggerState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as LogTriggerState | undefined;
            resourceInputs["accessControlAllowEvents"] = state ? state.accessControlAllowEvents : undefined;
            resourceInputs["accessControlDropEvents"] = state ? state.accessControlDropEvents : undefined;
            resourceInputs["cefIpAddress"] = state ? state.cefIpAddress : undefined;
            resourceInputs["cefPort"] = state ? state.cefPort : undefined;
            resourceInputs["extendLogging"] = state ? state.extendLogging : undefined;
            resourceInputs["extendLoggingMinSeverity"] = state ? state.extendLoggingMinSeverity : undefined;
            resourceInputs["logToAgent"] = state ? state.logToAgent : undefined;
            resourceInputs["logToCef"] = state ? state.logToCef : undefined;
            resourceInputs["logToCloud"] = state ? state.logToCloud : undefined;
            resourceInputs["logToSyslog"] = state ? state.logToSyslog : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["responseBody"] = state ? state.responseBody : undefined;
            resourceInputs["responseCode"] = state ? state.responseCode : undefined;
            resourceInputs["syslogIpAddress"] = state ? state.syslogIpAddress : undefined;
            resourceInputs["syslogPort"] = state ? state.syslogPort : undefined;
            resourceInputs["threatPreventionDetectEvents"] = state ? state.threatPreventionDetectEvents : undefined;
            resourceInputs["threatPreventionPreventEvents"] = state ? state.threatPreventionPreventEvents : undefined;
            resourceInputs["verbosity"] = state ? state.verbosity : undefined;
            resourceInputs["webBody"] = state ? state.webBody : undefined;
            resourceInputs["webHeaders"] = state ? state.webHeaders : undefined;
            resourceInputs["webRequests"] = state ? state.webRequests : undefined;
            resourceInputs["webUrlPath"] = state ? state.webUrlPath : undefined;
            resourceInputs["webUrlQuery"] = state ? state.webUrlQuery : undefined;
        } else {
            const args = argsOrState as LogTriggerArgs | undefined;
            resourceInputs["accessControlAllowEvents"] = args ? args.accessControlAllowEvents : undefined;
            resourceInputs["accessControlDropEvents"] = args ? args.accessControlDropEvents : undefined;
            resourceInputs["cefIpAddress"] = args ? args.cefIpAddress : undefined;
            resourceInputs["cefPort"] = args ? args.cefPort : undefined;
            resourceInputs["extendLogging"] = args ? args.extendLogging : undefined;
            resourceInputs["extendLoggingMinSeverity"] = args ? args.extendLoggingMinSeverity : undefined;
            resourceInputs["logToAgent"] = args ? args.logToAgent : undefined;
            resourceInputs["logToCef"] = args ? args.logToCef : undefined;
            resourceInputs["logToCloud"] = args ? args.logToCloud : undefined;
            resourceInputs["logToSyslog"] = args ? args.logToSyslog : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["responseBody"] = args ? args.responseBody : undefined;
            resourceInputs["responseCode"] = args ? args.responseCode : undefined;
            resourceInputs["syslogIpAddress"] = args ? args.syslogIpAddress : undefined;
            resourceInputs["syslogPort"] = args ? args.syslogPort : undefined;
            resourceInputs["threatPreventionDetectEvents"] = args ? args.threatPreventionDetectEvents : undefined;
            resourceInputs["threatPreventionPreventEvents"] = args ? args.threatPreventionPreventEvents : undefined;
            resourceInputs["verbosity"] = args ? args.verbosity : undefined;
            resourceInputs["webBody"] = args ? args.webBody : undefined;
            resourceInputs["webHeaders"] = args ? args.webHeaders : undefined;
            resourceInputs["webRequests"] = args ? args.webRequests : undefined;
            resourceInputs["webUrlPath"] = args ? args.webUrlPath : undefined;
            resourceInputs["webUrlQuery"] = args ? args.webUrlQuery : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(LogTrigger.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering LogTrigger resources.
 */
export interface LogTriggerState {
    /**
     * Log Access Control accepts
     */
    accessControlAllowEvents?: pulumi.Input<boolean>;
    /**
     * Log Access Control drops
     */
    accessControlDropEvents?: pulumi.Input<boolean>;
    cefIpAddress?: pulumi.Input<string>;
    cefPort?: pulumi.Input<number>;
    extendLogging?: pulumi.Input<boolean>;
    /**
     * Minimum severity of events that will trigger extended logging: High or Critical
     */
    extendLoggingMinSeverity?: pulumi.Input<string>;
    logToAgent?: pulumi.Input<boolean>;
    logToCef?: pulumi.Input<boolean>;
    logToCloud?: pulumi.Input<boolean>;
    logToSyslog?: pulumi.Input<boolean>;
    /**
     * The name of the resource, also acts as its unique ID
     */
    name?: pulumi.Input<string>;
    /**
     * Add response body to log if true
     */
    responseBody?: pulumi.Input<boolean>;
    /**
     * Add response code to log if true
     */
    responseCode?: pulumi.Input<boolean>;
    syslogIpAddress?: pulumi.Input<string>;
    syslogPort?: pulumi.Input<number>;
    /**
     * Log Threat Prevention Prevents
     */
    threatPreventionDetectEvents?: pulumi.Input<boolean>;
    /**
     * Log Threat Prevention Detects
     */
    threatPreventionPreventEvents?: pulumi.Input<boolean>;
    /**
     * The verbosity of the log: Standard, Minimal or Extended
     */
    verbosity?: pulumi.Input<string>;
    webBody?: pulumi.Input<boolean>;
    webHeaders?: pulumi.Input<boolean>;
    webRequests?: pulumi.Input<boolean>;
    webUrlPath?: pulumi.Input<boolean>;
    webUrlQuery?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a LogTrigger resource.
 */
export interface LogTriggerArgs {
    /**
     * Log Access Control accepts
     */
    accessControlAllowEvents?: pulumi.Input<boolean>;
    /**
     * Log Access Control drops
     */
    accessControlDropEvents?: pulumi.Input<boolean>;
    cefIpAddress?: pulumi.Input<string>;
    cefPort?: pulumi.Input<number>;
    extendLogging?: pulumi.Input<boolean>;
    /**
     * Minimum severity of events that will trigger extended logging: High or Critical
     */
    extendLoggingMinSeverity?: pulumi.Input<string>;
    logToAgent?: pulumi.Input<boolean>;
    logToCef?: pulumi.Input<boolean>;
    logToCloud?: pulumi.Input<boolean>;
    logToSyslog?: pulumi.Input<boolean>;
    /**
     * The name of the resource, also acts as its unique ID
     */
    name?: pulumi.Input<string>;
    /**
     * Add response body to log if true
     */
    responseBody?: pulumi.Input<boolean>;
    /**
     * Add response code to log if true
     */
    responseCode?: pulumi.Input<boolean>;
    syslogIpAddress?: pulumi.Input<string>;
    syslogPort?: pulumi.Input<number>;
    /**
     * Log Threat Prevention Prevents
     */
    threatPreventionDetectEvents?: pulumi.Input<boolean>;
    /**
     * Log Threat Prevention Detects
     */
    threatPreventionPreventEvents?: pulumi.Input<boolean>;
    /**
     * The verbosity of the log: Standard, Minimal or Extended
     */
    verbosity?: pulumi.Input<string>;
    webBody?: pulumi.Input<boolean>;
    webHeaders?: pulumi.Input<boolean>;
    webRequests?: pulumi.Input<boolean>;
    webUrlPath?: pulumi.Input<boolean>;
    webUrlQuery?: pulumi.Input<boolean>;
}
