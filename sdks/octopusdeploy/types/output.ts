// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AzureCloudServiceDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.AzureCloudServiceDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.AzureCloudServiceDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.AzureCloudServiceDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.AzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.AzureServiceFabricClusterDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.AzureServiceFabricClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.AzureServiceFabricClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.AzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface AzureWebAppDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.AzureWebAppDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.AzureWebAppDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.AzureWebAppDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.AzureWebAppDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface AzureWebAppDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface AzureWebAppDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface AzureWebAppDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface AzureWebAppDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface ChannelRule {
    actionPackages: outputs.ChannelRuleActionPackage[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    tag?: string;
    versionRange?: string;
}

export interface ChannelRuleActionPackage {
    deploymentAction?: string;
    packageReference?: string;
}

export interface CloudRegionDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.CloudRegionDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.CloudRegionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.CloudRegionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.CloudRegionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface CloudRegionDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface CloudRegionDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface CloudRegionDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface CloudRegionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface DeploymentProcessStep {
    actions?: outputs.DeploymentProcessStepAction[];
    applyTerraformTemplateActions?: outputs.DeploymentProcessStepApplyTerraformTemplateAction[];
    /**
     * When to run the step, one of 'Success', 'Failure', 'Always' or 'Variable'
     */
    condition?: string;
    /**
     * The expression to evaluate to determine whether to run this step when 'condition' is 'Variable'
     */
    conditionExpression: string;
    deployKubernetesSecretActions?: outputs.DeploymentProcessStepDeployKubernetesSecretAction[];
    deployPackageActions?: outputs.DeploymentProcessStepDeployPackageAction[];
    deployWindowsServiceActions?: outputs.DeploymentProcessStepDeployWindowsServiceAction[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    manualInterventionActions?: outputs.DeploymentProcessStepManualInterventionAction[];
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * Whether to run this step before or after package acquisition (if possible)
     */
    packageRequirement?: string;
    properties: {[key: string]: string};
    runKubectlScriptActions?: outputs.DeploymentProcessStepRunKubectlScriptAction[];
    runScriptActions?: outputs.DeploymentProcessStepRunScriptAction[];
    /**
     * Whether to run this step after the previous step ('StartAfterPrevious') or at the same time as the previous step ('StartWithPrevious')
     */
    startTrigger?: string;
    /**
     * The roles that this step run against, or runs on behalf of
     */
    targetRoles: string[];
    /**
     * The maximum number of targets to deploy to simultaneously
     */
    windowSize?: string;
}

export interface DeploymentProcessStepAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepActionActionTemplate;
    /**
     * The type of action
     */
    actionType: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.DeploymentProcessStepActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of the package
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepApplyTerraformTemplateAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepApplyTerraformTemplateActionActionTemplate;
    advancedOptions: outputs.DeploymentProcessStepApplyTerraformTemplateActionAdvancedOptions;
    awsAccount?: outputs.DeploymentProcessStepApplyTerraformTemplateActionAwsAccount;
    azureAccount?: outputs.DeploymentProcessStepApplyTerraformTemplateActionAzureAccount;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepApplyTerraformTemplateActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepApplyTerraformTemplateActionGitDependency;
    googleCloudAccount?: outputs.DeploymentProcessStepApplyTerraformTemplateActionGoogleCloudAccount;
    /**
     * The unique ID for this resource.
     */
    id: string;
    inlineTemplate?: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepApplyTerraformTemplateActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.DeploymentProcessStepApplyTerraformTemplateActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    template?: outputs.DeploymentProcessStepApplyTerraformTemplateActionTemplate;
    templateParameters?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAdvancedOptions {
    allowAdditionalPluginDownloads?: boolean;
    applyParameters?: string;
    initParameters?: string;
    pluginCacheDirectory?: string;
    workspace?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAwsAccount {
    region?: string;
    role?: outputs.DeploymentProcessStepApplyTerraformTemplateActionAwsAccountRole;
    useInstanceRole?: boolean;
    variable?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAwsAccountRole {
    arn?: string;
    externalId?: string;
    roleSessionName?: string;
    sessionDuration?: number;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAzureAccount {
    variable?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionGoogleCloudAccount {
    /**
     * Impersonate service accounts
     */
    impersonateServiceAccount?: boolean;
    /**
     * This sets GOOGLE_PROJECT environment variable
     */
    project?: string;
    /**
     * This sets GOOGLE_REGION environment variable
     */
    region?: string;
    /**
     * This sets GOOGLE_IMPERSONATE_SERVICE_ACCOUNT environment variable
     */
    serviceAccountEmails?: string;
    /**
     * When running in a Compute Engine virtual machine, use the associated VM service account
     */
    useVmServiceAccount?: boolean;
    variable?: string;
    /**
     * This sets GOOGLE_ZONE environment variable
     */
    zone?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepApplyTerraformTemplateActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepApplyTerraformTemplateActionTemplate {
    additionalVariableFiles?: string;
    directory?: string;
    runAutomaticFileSubstitution?: boolean;
    targetFiles?: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepDeployKubernetesSecretActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepDeployKubernetesSecretActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepDeployKubernetesSecretActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * Indicates the status of the Kubernetes Object Status feature
     */
    kubernetesObjectStatusCheckEnabled?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepDeployKubernetesSecretActionPackage[];
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The name of the secret resource
     */
    secretName: string;
    secretValues: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployPackageAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepDeployPackageActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepDeployPackageActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepDeployPackageActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepDeployPackageActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepDeployPackageActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * Deploy a windows service feature
     */
    windowsService?: outputs.DeploymentProcessStepDeployPackageActionWindowsService;
}

export interface DeploymentProcessStepDeployPackageActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepDeployPackageActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepDeployPackageActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepDeployPackageActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployPackageActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployPackageActionWindowsService {
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
}

export interface DeploymentProcessStepDeployWindowsServiceAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepDeployWindowsServiceActionActionTemplate;
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepDeployWindowsServiceActionContainer[];
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepDeployWindowsServiceActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepDeployWindowsServiceActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepDeployWindowsServiceActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface DeploymentProcessStepDeployWindowsServiceActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepDeployWindowsServiceActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepDeployWindowsServiceActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepDeployWindowsServiceActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployWindowsServiceActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepManualInterventionAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepManualInterventionActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepManualInterventionActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepManualInterventionActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The instructions for the user to follow
     */
    instructions: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepManualInterventionActionPackage[];
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * The teams responsible to resolve this step. If no teams are specified, all users who have permission to deploy the project can resolve it.
     */
    responsibleTeams?: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface DeploymentProcessStepManualInterventionActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepManualInterventionActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepManualInterventionActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepManualInterventionActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunKubectlScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepRunKubectlScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepRunKubectlScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepRunKubectlScriptActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    namespace?: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepRunKubectlScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.DeploymentProcessStepRunKubectlScriptActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepRunKubectlScriptActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepRunKubectlScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepRunKubectlScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepRunKubectlScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of the package
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunKubectlScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.DeploymentProcessStepRunScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.DeploymentProcessStepRunScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.DeploymentProcessStepRunScriptActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.DeploymentProcessStepRunScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.DeploymentProcessStepRunScriptActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     *
     * @deprecated Deprecated
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepRunScriptActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface DeploymentProcessStepRunScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepRunScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepRunScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of the package
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface EnvironmentJiraExtensionSetting {
    /**
     * The Jira environment type of this Octopus deployment environment. Valid values are `"development"`, `"production"`, `"staging"`, `"testing"`, `"unmapped"`.
     */
    environmentType?: string;
}

export interface EnvironmentJiraServiceManagementExtensionSetting {
    /**
     * Specifies whether or not this extension is enabled for this project.
     */
    isEnabled?: boolean;
}

export interface EnvironmentServicenowExtensionSetting {
    /**
     * Specifies whether or not this extension is enabled for this project.
     */
    isEnabled?: boolean;
}

export interface ExternalFeedCreateReleaseTriggerPackage {
    deploymentActionSlug: string;
    packageReference: string;
}

export interface ExternalFeedCreateReleaseTriggerPrimaryPackage {
    deploymentActionSlug: string;
}

export interface GetAccountsAccount {
    accessKey: string;
    accountType: string;
    activeDirectoryEndpointBaseUri: string;
    applicationId: string;
    authenticationEndpoint: string;
    azureEnvironment: string;
    certificateData: string;
    certificateThumbprint: string;
    clientSecret: string;
    description: string;
    environments: string[];
    id: string;
    name: string;
    password: string;
    privateKeyFile: string;
    privateKeyPassphrase: string;
    resourceManagerEndpoint: string;
    secretKey: string;
    serviceManagementEndpointBaseUri: string;
    serviceManagementEndpointSuffix: string;
    spaceId: string;
    subscriptionId: string;
    tenantId: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    token: string;
    username: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTarget {
    accountId: string;
    cloudServiceName: string;
    defaultWorkerPoolId: string;
    endpoints: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpoint[];
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    slot: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTarget {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialPassword: string;
    aadUserCredentialUsername: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    connectionEndpoint: string;
    endpoints: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpoint[];
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    roles: string[];
    securityMode: string;
    serverCertificateThumbprint: string;
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTarget {
    accountId: string;
    endpoints: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpoint[];
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    resourceGroupName: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
    webAppName: string;
    webAppSlotName: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetCertificatesCertificate {
    archived: string;
    certificateData: string;
    certificateDataFormat: string;
    environments: string[];
    hasPrivateKey: boolean;
    id: string;
    isExpired: boolean;
    issuerCommonName: string;
    issuerDistinguishedName: string;
    issuerOrganization: string;
    name: string;
    notAfter: string;
    notBefore: string;
    notes: string;
    password: string;
    replacedBy: string;
    selfSigned: boolean;
    serialNumber: string;
    signatureAlgorithmName: string;
    spaceId: string;
    subjectAlternativeNames: string[];
    subjectCommonName: string;
    subjectDistinguishedName: string;
    subjectOrganization: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    version: number;
}

export interface GetChannelsChannel {
    description: string;
    id: string;
    isDefault: boolean;
    lifecycleId: string;
    name: string;
    projectId: string;
    rules: outputs.GetChannelsChannelRule[];
    spaceId: string;
    tenantTags: string[];
}

export interface GetChannelsChannelRule {
    actionPackages: outputs.GetChannelsChannelRuleActionPackage[];
    id: string;
    tag: string;
    versionRange: string;
}

export interface GetChannelsChannelRuleActionPackage {
    deploymentAction: string;
    packageReference: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTarget {
    defaultWorkerPoolId: string;
    endpoints: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpoint[];
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetDeploymentTargetsDeploymentTarget {
    endpoints: outputs.GetDeploymentTargetsDeploymentTargetEndpoint[];
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetDeploymentTargetsDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetDeploymentTargetsDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetDeploymentTargetsDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetDeploymentTargetsDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetEnvironmentsEnvironment {
    allowDynamicInfrastructure: boolean;
    /**
     * The description of this environment.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Provides extension settings for the Jira integration for this environment.
     */
    jiraExtensionSettings: outputs.GetEnvironmentsEnvironmentJiraExtensionSetting[];
    /**
     * Provides extension settings for the Jira Service Management (JSM) integration for this environment.
     */
    jiraServiceManagementExtensionSettings: outputs.GetEnvironmentsEnvironmentJiraServiceManagementExtensionSetting[];
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * Provides extension settings for the ServiceNow integration for this environment.
     */
    servicenowExtensionSettings: outputs.GetEnvironmentsEnvironmentServicenowExtensionSetting[];
    /**
     * The unique slug of this environment
     */
    slug: string;
    /**
     * The order number to sort an environment
     */
    sortOrder: number;
    /**
     * The space ID associated with this environment.
     */
    spaceId: string;
    useGuidedFailure: boolean;
}

export interface GetEnvironmentsEnvironmentJiraExtensionSetting {
    environmentType: string;
}

export interface GetEnvironmentsEnvironmentJiraServiceManagementExtensionSetting {
    isEnabled: boolean;
}

export interface GetEnvironmentsEnvironmentServicenowExtensionSetting {
    isEnabled: boolean;
}

export interface GetFeedsFeed {
    /**
     * The AWS access key to use when authenticating against Amazon Web Services.
     */
    accessKey: string;
    apiVersion: string;
    deleteUnreleasedPackagesAfterDays: number;
    /**
     * The number of times a deployment should attempt to download a package from this feed before failing.
     */
    downloadAttempts: number;
    /**
     * The number of seconds to apply as a linear back off between download attempts.
     */
    downloadRetryBackoffSeconds: number;
    /**
     * A filter to search by feed type. Valid feed types are `AwsElasticContainerRegistry`, `BuiltIn`, `Docker`, `GitHub`, `Helm`, `Maven`, `NuGet`, or `OctopusProject`.
     */
    feedType: string;
    feedUri: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isEnhancedMode: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    packageAcquisitionLocationOptions: string[];
    /**
     * The password associated with this resource.
     */
    password: string;
    region: string;
    registryPath: string;
    secretKey: string;
    /**
     * The space ID associated with this feeds.
     */
    spaceId: string;
    /**
     * The username associated with this resource.
     */
    username: string;
}

export interface GetGitCredentialsGitCredential {
    /**
     * The description of this Git Credential.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this Git Credential.
     */
    name: string;
    /**
     * The space ID associated with this Git Credential.
     */
    spaceId: string;
    /**
     * The Git credential authentication type.
     */
    type: string;
    /**
     * The username for the Git credential.
     */
    username: string;
}

export interface GetKubernetesAgentDeploymentTargetsKubernetesAgentDeploymentTarget {
    agentHelmReleaseName: string;
    agentKubernetesNamespace: string;
    agentTentacleVersion: string;
    agentUpgradeStatus: string;
    agentVersion: string;
    communicationMode: string;
    defaultNamespace: string;
    environments: string[];
    id: string;
    isDisabled: boolean;
    machinePolicyId: string;
    name: string;
    roles: string[];
    spaceId: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    upgradeLocked: boolean;
    uri: string;
}

export interface GetKubernetesAgentWorkersKubernetesAgentWorker {
    agentHelmReleaseName: string;
    agentKubernetesNamespace: string;
    agentTentacleVersion: string;
    agentUpgradeStatus: string;
    agentVersion: string;
    communicationMode: string;
    id: string;
    isDisabled: boolean;
    machinePolicyId: string;
    name: string;
    spaceId: string;
    thumbprint: string;
    upgradeLocked: boolean;
    uri: string;
    workerPoolIds: string[];
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTarget {
    authentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAuthentication[];
    awsAccountAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAwsAccountAuthentication[];
    azureServicePrincipalAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAzureServicePrincipalAuthentication[];
    certificateAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetCertificateAuthentication[];
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    containerOptions: string;
    containers: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetContainer[];
    defaultWorkerPoolId: string;
    endpoints: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpoint[];
    environments: string[];
    gcpAccountAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetGcpAccountAuthentication[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    namespace: string;
    operatingSystem: string;
    podAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetPodAuthentication[];
    proxyId: string;
    roles: string[];
    runningInContainer: boolean;
    shellName: string;
    shellVersion: string;
    skipTlsVerification: boolean;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAuthentication {
    accountId: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAwsAccountAuthentication {
    accountId: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    clusterName: string;
    useInstanceRole: boolean;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAzureServicePrincipalAuthentication {
    accountId: string;
    clusterName: string;
    clusterResourceGroup: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetCertificateAuthentication {
    clientCertificate: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetContainer {
    feedId: string;
    image: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetGcpAccountAuthentication {
    accountId: string;
    clusterName: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetPodAuthentication {
    tokenPath: string;
}

export interface GetLibraryVariableSetsLibraryVariableSet {
    /**
     * The description of this library variable set.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The space ID associated with this library variable set.
     */
    spaceId: string;
    templateIds: {[key: string]: string};
    templates: outputs.GetLibraryVariableSetsLibraryVariableSetTemplate[];
    variableSetId: string;
}

export interface GetLibraryVariableSetsLibraryVariableSetTemplate {
    defaultValue: string;
    displaySettings: {[key: string]: string};
    helpText: string;
    id: string;
    label: string;
    name: string;
}

export interface GetLifecyclesLifecycle {
    /**
     * The description of the lifecycle.
     */
    description: string;
    /**
     * The ID of the lifecycle.
     */
    id: string;
    /**
     * The name of the lifecycle.
     */
    name: string;
    phases: outputs.GetLifecyclesLifecyclePhase[];
    releaseRetentionPolicies: outputs.GetLifecyclesLifecycleReleaseRetentionPolicy[];
    /**
     * The space ID associated with this lifecycle.
     */
    spaceId: string;
    tentacleRetentionPolicies: outputs.GetLifecyclesLifecycleTentacleRetentionPolicy[];
}

export interface GetLifecyclesLifecyclePhase {
    /**
     * The automatic deployment targets for this phase.
     */
    automaticDeploymentTargets: string[];
    /**
     * The ID of the phase.
     */
    id: string;
    /**
     * Whether this phase is optional.
     */
    isOptionalPhase: boolean;
    /**
     * The minimum number of environments before promotion.
     */
    minimumEnvironmentsBeforePromotion: number;
    /**
     * The name of the phase.
     */
    name: string;
    /**
     * The optional deployment targets for this phase.
     */
    optionalDeploymentTargets: string[];
    releaseRetentionPolicies: outputs.GetLifecyclesLifecyclePhaseReleaseRetentionPolicy[];
    tentacleRetentionPolicies: outputs.GetLifecyclesLifecyclePhaseTentacleRetentionPolicy[];
}

export interface GetLifecyclesLifecyclePhaseReleaseRetentionPolicy {
    /**
     * The quantity of releases to keep.
     */
    quantityToKeep: number;
    /**
     * Whether releases should be kept forever.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of time for the retention policy.
     */
    unit: string;
}

export interface GetLifecyclesLifecyclePhaseTentacleRetentionPolicy {
    /**
     * The quantity of releases to keep.
     */
    quantityToKeep: number;
    /**
     * Whether releases should be kept forever.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of time for the retention policy.
     */
    unit: string;
}

export interface GetLifecyclesLifecycleReleaseRetentionPolicy {
    /**
     * The quantity of releases to keep.
     */
    quantityToKeep: number;
    /**
     * Whether releases should be kept forever.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of time for the retention policy.
     */
    unit: string;
}

export interface GetLifecyclesLifecycleTentacleRetentionPolicy {
    /**
     * The quantity of releases to keep.
     */
    quantityToKeep: number;
    /**
     * Whether releases should be kept forever.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of time for the retention policy.
     */
    unit: string;
}

export interface GetListeningTentacleDeploymentTargetsListeningTentacleDeploymentTarget {
    certificateSignatureAlgorithm: string;
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    proxyId: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    tentacleUrl: string;
    tentacleVersionDetails: outputs.GetListeningTentacleDeploymentTargetsListeningTentacleDeploymentTargetTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
}

export interface GetListeningTentacleDeploymentTargetsListeningTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetMachinePoliciesMachinePolicy {
    connectionConnectTimeout: number;
    connectionRetryCountLimit: number;
    connectionRetrySleepInterval: number;
    connectionRetryTimeLimit: number;
    description: string;
    id: string;
    isDefault: boolean;
    machineCleanupPolicies: outputs.GetMachinePoliciesMachinePolicyMachineCleanupPolicy[];
    machineConnectivityPolicies: outputs.GetMachinePoliciesMachinePolicyMachineConnectivityPolicy[];
    machineHealthCheckPolicies: outputs.GetMachinePoliciesMachinePolicyMachineHealthCheckPolicy[];
    machineUpdatePolicies: outputs.GetMachinePoliciesMachinePolicyMachineUpdatePolicy[];
    name: string;
    pollingRequestQueueTimeout: number;
    spaceId: string;
}

export interface GetMachinePoliciesMachinePolicyMachineCleanupPolicy {
    deleteMachinesBehavior: string;
    deleteMachinesElapsedTimespan: number;
}

export interface GetMachinePoliciesMachinePolicyMachineConnectivityPolicy {
    machineConnectivityBehavior: string;
}

export interface GetMachinePoliciesMachinePolicyMachineHealthCheckPolicy {
    bashHealthCheckPolicies: outputs.GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy[];
    healthCheckCron: string;
    healthCheckCronTimezone: string;
    healthCheckInterval: number;
    healthCheckType: string;
    powershellHealthCheckPolicies: outputs.GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy[];
}

export interface GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy {
    runType: string;
    scriptBody: string;
}

export interface GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy {
    runType: string;
    scriptBody: string;
}

export interface GetMachinePoliciesMachinePolicyMachineUpdatePolicy {
    calamariUpdateBehavior: string;
    kubernetesAgentUpdateBehavior: string;
    tentacleUpdateAccountId: string;
    tentacleUpdateBehavior: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTarget {
    applicationsDirectory: string;
    destinations: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetDestination[];
    endpoints: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpoint[];
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
    workingDirectory: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTarget {
    certificateSignatureAlgorithm: string;
    endpoints: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpoint[];
    environments: string[];
    hasLatestCalamari: boolean;
    healthStatus: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    tentacleUrl: string;
    tentacleVersionDetails: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetProjectGroupsProjectGroup {
    /**
     * The description of this project group.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The space ID associated with this project group.
     */
    spaceId: string;
}

export interface GetProjectsProject {
    /**
     * @deprecated Deprecated
     */
    allowDeploymentsToNoTargets: boolean;
    autoCreateRelease: boolean;
    autoDeployReleaseOverrides: outputs.GetProjectsProjectAutoDeployReleaseOverride[];
    clonedFromProjectId: string;
    connectivityPolicies: outputs.GetProjectsProjectConnectivityPolicy[];
    defaultGuidedFailureMode: string;
    defaultToSkipIfAlreadyInstalled: boolean;
    deploymentChangesTemplate: string;
    deploymentProcessId: string;
    /**
     * The description of this project
     */
    description: string;
    /**
     * Treats releases of different channels to the same environment as a separate deployment dimension
     */
    discreteChannelRelease: boolean;
    /**
     * Git-related persistence settings for a version-controlled project using anonymous authentication.
     */
    gitAnonymousPersistenceSettings: outputs.GetProjectsProjectGitAnonymousPersistenceSetting[];
    /**
     * Git-related persistence settings for a version-controlled project using library authentication.
     */
    gitLibraryPersistenceSettings: outputs.GetProjectsProjectGitLibraryPersistenceSetting[];
    /**
     * Git-related persistence settings for a version-controlled project using username_password authentication.
     */
    gitUsernamePasswordPersistenceSettings: outputs.GetProjectsProjectGitUsernamePasswordPersistenceSetting[];
    id: string;
    includedLibraryVariableSets: string[];
    isDisabled: boolean;
    isDiscreteChannelRelease: boolean;
    isVersionControlled: boolean;
    /**
     * Extension settings for the Jira Service Management (JSM) integration.
     */
    jiraServiceManagementExtensionSettings: outputs.GetProjectsProjectJiraServiceManagementExtensionSetting[];
    /**
     * The lifecycle ID associated with this project
     */
    lifecycleId: string;
    /**
     * The name of the project in Octopus Deploy. This name must be unique.
     */
    name: string;
    /**
     * The project group ID associated with this project.
     */
    projectGroupId: string;
    /**
     * The release creation strategy for the project.
     */
    releaseCreationStrategies: outputs.GetProjectsProjectReleaseCreationStrategy[];
    /**
     * The template to use for release notes.
     */
    releaseNotesTemplate: string;
    /**
     * Extension settings for the ServiceNow integration.
     */
    servicenowExtensionSettings: outputs.GetProjectsProjectServicenowExtensionSetting[];
    /**
     * A human-readable, unique identifier, used to identify a project.
     */
    slug: string;
    /**
     * The space ID associated with this project.
     */
    spaceId: string;
    /**
     * Template parameters for the project.
     */
    templates: outputs.GetProjectsProjectTemplate[];
    /**
     * The tenanted deployment mode of the project.
     */
    tenantedDeploymentParticipation: string;
    /**
     * The ID of the variable set associated with this project.
     */
    variableSetId: string;
    /**
     * The versioning strategy for the project.
     */
    versioningStrategies: outputs.GetProjectsProjectVersioningStrategy[];
}

export interface GetProjectsProjectAutoDeployReleaseOverride {
    /**
     * The environment ID for the auto deploy release override.
     */
    environmentId: string;
    /**
     * The release ID for the auto deploy release override.
     */
    releaseId: string;
    /**
     * The tenant ID for the auto deploy release override.
     */
    tenantId: string;
}

export interface GetProjectsProjectConnectivityPolicy {
    /**
     * Allow deployments to be created when there are no targets.
     */
    allowDeploymentsToNoTargets: boolean;
    /**
     * Exclude unhealthy targets from deployments.
     */
    excludeUnhealthyTargets: boolean;
    /**
     * The behavior when a machine is skipped.
     */
    skipMachineBehavior: string;
    /**
     * The target roles for the connectivity policy.
     */
    targetRoles: string[];
}

export interface GetProjectsProjectGitAnonymousPersistenceSetting {
    /**
     * The base path associated with these version control settings.
     */
    basePath: string;
    /**
     * The default branch associated with these version control settings.
     */
    defaultBranch: string;
    /**
     * A list of protected branch patterns.
     */
    protectedBranches: string[];
    /**
     * The URL associated with these version control settings.
     */
    url: string;
}

export interface GetProjectsProjectGitLibraryPersistenceSetting {
    /**
     * The base path associated with these version control settings.
     */
    basePath: string;
    /**
     * The default branch associated with these version control settings.
     */
    defaultBranch: string;
    /**
     * The ID of the Git credential.
     */
    gitCredentialId: string;
    /**
     * A list of protected branch patterns.
     */
    protectedBranches: string[];
    /**
     * The URL associated with these version control settings.
     */
    url: string;
}

export interface GetProjectsProjectGitUsernamePasswordPersistenceSetting {
    /**
     * The base path associated with these version control settings.
     */
    basePath: string;
    /**
     * The default branch associated with these version control settings.
     */
    defaultBranch: string;
    /**
     * The password for the Git credential.
     */
    password: string;
    /**
     * A list of protected branch patterns.
     */
    protectedBranches: string[];
    /**
     * The URL associated with these version control settings.
     */
    url: string;
    /**
     * The username for the Git credential.
     */
    username: string;
}

export interface GetProjectsProjectJiraServiceManagementExtensionSetting {
    /**
     * The connection identifier for JSM.
     */
    connectionId: string;
    /**
     * Whether the JSM extension is enabled.
     */
    isEnabled: boolean;
    /**
     * The JSM service desk project name.
     */
    serviceDeskProjectName: string;
}

export interface GetProjectsProjectReleaseCreationStrategy {
    /**
     * The ID of the channel to use for release creation.
     */
    channelId: string;
    /**
     * The ID of the step containing the package for release creation.
     */
    releaseCreationPackageStepId: string;
    /**
     * Details of the package used for release creation.
     */
    releaseCreationPackages: outputs.GetProjectsProjectReleaseCreationStrategyReleaseCreationPackage[];
}

export interface GetProjectsProjectReleaseCreationStrategyReleaseCreationPackage {
    /**
     * The deployment action for the release creation package.
     */
    deploymentAction: string;
    /**
     * The package reference for the release creation package.
     */
    packageReference: string;
}

export interface GetProjectsProjectServicenowExtensionSetting {
    /**
     * The connection identifier for ServiceNow.
     */
    connectionId: string;
    /**
     * Whether the ServiceNow extension is enabled.
     */
    isEnabled: boolean;
    /**
     * Whether state is automatically transitioned in ServiceNow.
     */
    isStateAutomaticallyTransitioned: boolean;
    /**
     * The name of the standard change template in ServiceNow.
     */
    standardChangeTemplateName: string;
}

export interface GetProjectsProjectTemplate {
    /**
     * The default value for the parameter.
     */
    defaultValue: string;
    /**
     * The display settings for the parameter.
     */
    displaySettings: {[key: string]: string};
    /**
     * The help text for the parameter.
     */
    helpText: string;
    /**
     * The ID of the template parameter.
     */
    id: string;
    /**
     * The label shown beside the parameter.
     */
    label: string;
    /**
     * The name of the variable set by the parameter.
     */
    name: string;
}

export interface GetProjectsProjectVersioningStrategy {
    /**
     * The ID of the step containing the donor package.
     */
    donorPackageStepId: string;
    donorPackages: outputs.GetProjectsProjectVersioningStrategyDonorPackage[];
    /**
     * The template to use for version numbers.
     */
    template: string;
}

export interface GetProjectsProjectVersioningStrategyDonorPackage {
    /**
     * The deployment action for the donor package.
     */
    deploymentAction: string;
    /**
     * The package reference for the donor package.
     */
    packageReference: string;
}

export interface GetScriptModulesScriptModule {
    /**
     * The description of this script module.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The script associated with this script module.
     */
    scripts: outputs.GetScriptModulesScriptModuleScript[];
    /**
     * The space ID associated with this Script Module.
     */
    spaceId: string;
    /**
     * The variable set ID for this script module.
     */
    variableSetId: string;
}

export interface GetScriptModulesScriptModuleScript {
    /**
     * The body of this script module.
     */
    body: string;
    /**
     * The syntax of the script. Valid types are `Bash`, `CSharp`, `FSharp`, `PowerShell`, or `Python`.
     */
    syntax: string;
}

export interface GetSpacesSpace {
    /**
     * The description of this space.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Specifies if this space is the default space in Octopus.
     */
    isDefault: boolean;
    /**
     * Specifies the status of the task queue for this space.
     */
    isTaskQueueStopped: boolean;
    /**
     * The name of this resource, no more than 20 characters long
     */
    name: string;
    /**
     * The unique slug of this space
     */
    slug: string;
    /**
     * A list of user IDs designated to be managers of this space.
     */
    spaceManagersTeamMembers: string[];
    /**
     * A list of team IDs designated to be managers of this space.
     */
    spaceManagersTeams: string[];
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTarget {
    accountId: string;
    dotNetCorePlatform: string;
    endpoints: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpoint[];
    environments: string[];
    fingerprint: string;
    hasLatestCalamari: boolean;
    healthStatus: string;
    host: string;
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    name: string;
    operatingSystem: string;
    port: number;
    proxyId: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    spaceId: string;
    status: string;
    statusSummary: string;
    tenantTags: string[];
    tenantedDeploymentParticipation: string;
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpoint {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialUsername: string;
    accountId: string;
    applicationsDirectory: string;
    authentications: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointAuthentication[];
    certificateSignatureAlgorithm: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    cloudServiceName: string;
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    communicationStyle: string;
    connectionEndpoint: string;
    containerOptions: string;
    containers: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId: string;
    destinations: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform: string;
    fingerprint: string;
    host: string;
    id: string;
    namespace: string;
    port: number;
    proxyId: string;
    resourceGroupName: string;
    runningInContainer: boolean;
    securityMode: string;
    serverCertificateThumbprint: string;
    skipTlsVerification: boolean;
    slot: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    tentacleVersionDetails: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
    webAppName: string;
    webAppSlotName: string;
    workingDirectory: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointAuthentication {
    accountId: string;
    adminLogin: string;
    assumeRole: boolean;
    assumeRoleExternalId: string;
    assumeRoleSessionDuration: number;
    assumedRoleArn: string;
    assumedRoleSession: string;
    authenticationType: string;
    clientCertificate: string;
    clusterName: string;
    clusterResourceGroup: string;
    impersonateServiceAccount: boolean;
    project: string;
    region: string;
    serviceAccountEmails: string;
    tokenPath: string;
    useInstanceRole: boolean;
    useVmServiceAccount: boolean;
    zone: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointContainer {
    feedId: string;
    image: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointDestination {
    destinationType: string;
    dropFolderPath: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetTagSetsTagSet {
    /**
     * The description of this tag set.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The sort order associated with this resource.
     */
    sortOrder: number;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
}

export interface GetTeamsTeam {
    canBeDeleted: boolean;
    canBeRenamed: boolean;
    canChangeMembers: boolean;
    canChangeRoles: boolean;
    description: string;
    externalSecurityGroups: outputs.GetTeamsTeamExternalSecurityGroup[];
    id: string;
    name: string;
    spaceId: string;
    users: string[];
}

export interface GetTeamsTeamExternalSecurityGroup {
    displayIdAndName: boolean;
    displayName: string;
    id: string;
}

export interface GetTenantProjectsTenantProject {
    /**
     * The environment IDs associated with this tenant.
     */
    environmentIds: string[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The project ID associated with this tenant.
     */
    projectId: string;
    /**
     * The tenant ID associated with this tenant.
     */
    tenantId: string;
}

export interface GetTenantsTenant {
    /**
     * The ID of the tenant from which this tenant was cloned.
     */
    clonedFromTenantId: string;
    /**
     * The description of this tenants.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The space ID associated with this tenant.
     */
    spaceId: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface GetUserRolesUserRole {
    canBeDeleted: boolean;
    description: string;
    grantedSpacePermissions: string[];
    grantedSystemPermissions: string[];
    id: string;
    name: string;
    spacePermissionDescriptions: string[];
    supportedRestrictions: string[];
    systemPermissionDescriptions: string[];
}

export interface GetUsersUser {
    canPasswordBeEdited: boolean;
    displayName: string;
    emailAddress: string;
    id: string;
    identities: outputs.GetUsersUserIdentity[];
    isActive: boolean;
    isRequestor: boolean;
    isService: boolean;
    password: string;
    username: string;
}

export interface GetUsersUserIdentity {
    claims: outputs.GetUsersUserIdentityClaim[];
    provider: string;
}

export interface GetUsersUserIdentityClaim {
    isIdentifyingClaim: boolean;
    name: string;
    value: string;
}

export interface GetVariablesPrompt {
    /**
     * The description of this variable prompt option.
     */
    description: string;
    displaySettings: outputs.GetVariablesPromptDisplaySetting[];
    isRequired: boolean;
    label: string;
}

export interface GetVariablesPromptDisplaySetting {
    /**
     * The type of control for rendering this prompted variable. Valid types are `SingleLineText`, `MultiLineText`, `Checkbox`, `Select`.
     */
    controlType: string;
    /**
     * If the `control_type` is `Select`, then this value defines an option.
     */
    selectOptions: outputs.GetVariablesPromptDisplaySettingSelectOption[];
}

export interface GetVariablesPromptDisplaySettingSelectOption {
    /**
     * The display name for the select value
     */
    displayName: string;
    /**
     * The select value
     */
    value: string;
}

export interface GetVariablesScope {
    /**
     * A list of actions that are scoped to this variable value.
     */
    actions?: string[];
    /**
     * A list of channels that are scoped to this variable value.
     */
    channels?: string[];
    /**
     * A list of environments that are scoped to this variable value.
     */
    environments?: string[];
    /**
     * A list of machines that are scoped to this variable value.
     */
    machines?: string[];
    /**
     * A list of processes that are scoped to this variable value.
     */
    processes?: string[];
    /**
     * A list of roles that are scoped to this variable value.
     */
    roles?: string[];
    /**
     * A list of tenant tags that are scoped to this variable value.
     */
    tenantTags?: string[];
}

export interface GetWorkerPoolsWorkerPool {
    canAddWorkers: boolean;
    description: string;
    id: string;
    isDefault: boolean;
    name: string;
    sortOrder: number;
    spaceId: string;
    workerPoolType: string;
    workerType: string;
}

export interface KubernetesClusterDeploymentTargetAuthentication {
    accountId?: string;
}

export interface KubernetesClusterDeploymentTargetAwsAccountAuthentication {
    accountId: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    clusterName: string;
    useInstanceRole?: boolean;
}

export interface KubernetesClusterDeploymentTargetAzureServicePrincipalAuthentication {
    accountId: string;
    clusterName: string;
    clusterResourceGroup: string;
}

export interface KubernetesClusterDeploymentTargetCertificateAuthentication {
    clientCertificate?: string;
}

export interface KubernetesClusterDeploymentTargetContainer {
    feedId?: string;
    image?: string;
}

export interface KubernetesClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.KubernetesClusterDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.KubernetesClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.KubernetesClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.KubernetesClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface KubernetesClusterDeploymentTargetGcpAccountAuthentication {
    accountId: string;
    clusterName: string;
    impersonateServiceAccount?: boolean;
    project: string;
    region?: string;
    serviceAccountEmails?: string;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface KubernetesClusterDeploymentTargetPodAuthentication {
    tokenPath: string;
}

export interface LibraryVariableSetTemplate {
    /**
     * A default value for the parameter, if applicable. This can be a hard-coded value or a variable reference.
     */
    defaultValue: string;
    /**
     * The display settings for the parameter.
     */
    displaySettings?: {[key: string]: string};
    /**
     * The help presented alongside the parameter input.
     */
    helpText: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The label shown beside the parameter when presented in the deployment process. Example: `Server name`.
     */
    label?: string;
    /**
     * The name of the variable set by the parameter. The name can contain letters, digits, dashes and periods. Example: `ServerName`
     */
    name: string;
}

export interface LifecyclePhase {
    /**
     * Environment IDs in this phase that a release is automatically deployed to when it is eligible for this phase
     */
    automaticDeploymentTargets: string[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * If false a release must be deployed to this phase before it can be deployed to the next phase.
     */
    isOptionalPhase: boolean;
    /**
     * The number of units required before a release can enter the next phase. If 0, all environments are required.
     */
    minimumEnvironmentsBeforePromotion: number;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * Environment IDs in this phase that a release can be deployed to, but is not automatically deployed to
     */
    optionalDeploymentTargets: string[];
    /**
     * Defines the retention policy for releases or tentacles.
     */
    releaseRetentionPolicies?: outputs.LifecyclePhaseReleaseRetentionPolicy[];
    /**
     * Defines the retention policy for releases or tentacles.
     */
    tentacleRetentionPolicies?: outputs.LifecyclePhaseTentacleRetentionPolicy[];
}

export interface LifecyclePhaseReleaseRetentionPolicy {
    /**
     * The number of days/releases to keep. The default value is 30. If 0 then all are kept.
     */
    quantityToKeep: number;
    /**
     * Indicates if items should never be deleted. The default value is false.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of quantity to keep. Valid units are Days or Items. The default value is Days.
     */
    unit: string;
}

export interface LifecyclePhaseTentacleRetentionPolicy {
    /**
     * The number of days/releases to keep. The default value is 30. If 0 then all are kept.
     */
    quantityToKeep: number;
    /**
     * Indicates if items should never be deleted. The default value is false.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of quantity to keep. Valid units are Days or Items. The default value is Days.
     */
    unit: string;
}

export interface LifecycleReleaseRetentionPolicy {
    /**
     * The number of days/releases to keep. The default value is 30. If 0 then all are kept.
     */
    quantityToKeep: number;
    /**
     * Indicates if items should never be deleted. The default value is false.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of quantity to keep. Valid units are Days or Items. The default value is Days.
     */
    unit: string;
}

export interface LifecycleTentacleRetentionPolicy {
    /**
     * The number of days/releases to keep. The default value is 30. If 0 then all are kept.
     */
    quantityToKeep: number;
    /**
     * Indicates if items should never be deleted. The default value is false.
     */
    shouldKeepForever: boolean;
    /**
     * The unit of quantity to keep. Valid units are Days or Items. The default value is Days.
     */
    unit: string;
}

export interface ListeningTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface MachinePolicyMachineCleanupPolicy {
    deleteMachinesBehavior?: string;
    /**
     * In nanoseconds.
     */
    deleteMachinesElapsedTimespan: number;
}

export interface MachinePolicyMachineConnectivityPolicy {
    machineConnectivityBehavior?: string;
}

export interface MachinePolicyMachineHealthCheckPolicy {
    bashHealthCheckPolicy: outputs.MachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy;
    healthCheckCron?: string;
    healthCheckCronTimezone?: string;
    /**
     * In nanoseconds.
     */
    healthCheckInterval?: number;
    healthCheckType?: string;
    powershellHealthCheckPolicy: outputs.MachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy;
}

export interface MachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy {
    runType?: string;
    scriptBody?: string;
}

export interface MachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy {
    runType?: string;
    scriptBody?: string;
}

export interface MachinePolicyMachineUpdatePolicy {
    /**
     * The behaviour of how Calamari is updated. Valid values are `UpdateAlways`, `UpdateOnDeployment` and `UpdateOnNewMachine`.
     */
    calamariUpdateBehavior?: string;
    /**
     * The behaviour of how Kubernetes agent machines are updated. Valid values are `NeverUpdate` and `Update`.
     */
    kubernetesAgentUpdateBehavior?: string;
    /**
     * The Account ID to perform any Tentacle updates under.
     */
    tentacleUpdateAccountId?: string;
    /**
     * The behaviour of how Tentacle machines are updated. Valid values are `NeverUpdate` and `Update`.
     */
    tentacleUpdateBehavior?: string;
}

export interface OfflinePackageDropDeploymentTargetDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.OfflinePackageDropDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.OfflinePackageDropDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.OfflinePackageDropDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.OfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface PollingTentacleDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.PollingTentacleDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.PollingTentacleDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.PollingTentacleDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.PollingTentacleDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface PollingTentacleDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface PollingTentacleDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface PollingTentacleDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface PollingTentacleDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface PollingTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface ProjectAutoDeployReleaseOverride {
    environmentId?: string;
    releaseId?: string;
    tenantId?: string;
}

export interface ProjectConnectivityPolicy {
    allowDeploymentsToNoTargets: boolean;
    excludeUnhealthyTargets: boolean;
    skipMachineBehavior: string;
    targetRoles: string[];
}

export interface ProjectGitAnonymousPersistenceSetting {
    /**
     * The base path associated with these version control settings.
     */
    basePath?: string;
    /**
     * The default branch associated with these version control settings.
     */
    defaultBranch?: string;
    /**
     * A list of protected branch patterns.
     */
    protectedBranches?: string[];
    /**
     * The URL associated with these version control settings.
     */
    url: string;
}

export interface ProjectGitLibraryPersistenceSetting {
    /**
     * The base path associated with these version control settings.
     */
    basePath?: string;
    /**
     * The default branch associated with these version control settings.
     */
    defaultBranch?: string;
    gitCredentialId: string;
    /**
     * A list of protected branch patterns.
     */
    protectedBranches?: string[];
    /**
     * The URL associated with these version control settings.
     */
    url: string;
}

export interface ProjectGitUsernamePasswordPersistenceSetting {
    /**
     * The base path associated with these version control settings.
     */
    basePath?: string;
    /**
     * The default branch associated with these version control settings.
     */
    defaultBranch?: string;
    /**
     * The password for the Git credential
     */
    password: string;
    /**
     * A list of protected branch patterns.
     */
    protectedBranches?: string[];
    /**
     * The URL associated with these version control settings.
     */
    url: string;
    /**
     * The username for the Git credential.
     */
    username: string;
}

export interface ProjectJiraServiceManagementExtensionSetting {
    /**
     * The connection identifier associated with the extension settings.
     */
    connectionId: string;
    /**
     * Specifies whether or not this extension is enabled for this project.
     */
    isEnabled: boolean;
    /**
     * The project name associated with this extension.
     */
    serviceDeskProjectName: string;
}

export interface ProjectReleaseCreationStrategy {
    channelId?: string;
    releaseCreationPackageStepId?: string;
    releaseCreationPackages?: outputs.ProjectReleaseCreationStrategyReleaseCreationPackage[];
}

export interface ProjectReleaseCreationStrategyReleaseCreationPackage {
    deploymentAction?: string;
    packageReference?: string;
}

export interface ProjectScheduledTriggerContinuousDailySchedule {
    /**
     * The days of the week to run the trigger.
     */
    daysOfWeeks: string[];
    /**
     * How often to run the trigger in hours. Only used when the interval is set to 'OnceHourly'.
     */
    hourInterval?: number;
    /**
     * The interval in minutes to run the trigger.
     */
    interval: string;
    /**
     * How often to run the trigger in minutes. Only used when the interval is set to 'OnceEveryMinute'.
     */
    minuteInterval?: number;
    /**
     * The time of day to start the trigger.
     */
    runAfter: string;
    /**
     * The time of day to end the trigger.
     */
    runUntil: string;
}

export interface ProjectScheduledTriggerCronExpressionSchedule {
    /**
     * The cron expression for the schedule.
     */
    cronExpression: string;
}

export interface ProjectScheduledTriggerDaysPerMonthSchedule {
    /**
     * Which date of the month to run the trigger. String number between 1 - 31 Incl. or L for the last day of the month.
     */
    dateOfMonth?: string;
    /**
     * Which ordinal day of the week to run the trigger on. String number between 1 - 4 Incl. or L for the last occurrence of day_of_week for the month.
     */
    dayNumberOfMonth?: string;
    /**
     * Which day of the week to run the trigger on. Required when monthly_schedule_type is set to 'DayOfMonth'.
     */
    dayOfWeek?: string;
    /**
     * The type of monthly schedule to run the trigger
     */
    monthlyScheduleType: string;
    /**
     * The time of day to start the trigger.
     */
    startTime: string;
}

export interface ProjectScheduledTriggerDeployLatestReleaseAction {
    /**
     * The environment ID to deploy the selected release to.
     */
    destinationEnvironmentId: string;
    /**
     * Enable to re-deploy to the deployment targets even if they are already up-to-date with the current deployment.
     */
    shouldRedeploy?: boolean;
    /**
     * The environment ID to use when selecting the release to deploy from.
     */
    sourceEnvironmentId: string;
}

export interface ProjectScheduledTriggerDeployNewReleaseAction {
    /**
     * The environment ID to deploy the selected release to.
     */
    destinationEnvironmentId: string;
    /**
     * The git reference to use when creating the release. Can be a branch, tag, or commit hash.
     */
    gitReference?: string;
}

export interface ProjectScheduledTriggerOnceDailySchedule {
    /**
     * The days of the week to run the trigger.
     */
    daysOfWeeks: string[];
    /**
     * The time of day to start the trigger.
     */
    startTime: string;
}

export interface ProjectScheduledTriggerRunRunbookAction {
    /**
     * The ID of the runbook to run.
     */
    runbookId: string;
    /**
     * The IDs of the environments to run the runbook in.
     */
    targetEnvironmentIds: string[];
}

export interface ProjectServicenowExtensionSetting {
    /**
     * The connection identifier associated with the extension settings.
     */
    connectionId: string;
    /**
     * Specifies whether or not this extension is enabled for this project.
     */
    isEnabled: boolean;
    /**
     * Specifies whether or not this extension will automatically transition the state of a deployment for this project.
     */
    isStateAutomaticallyTransitioned: boolean;
    /**
     * The name of the standard change template associated with this extension. If provided, deployments will create a standard change based on the provided template, otherwise a normal change will be created.
     */
    standardChangeTemplateName?: string;
}

export interface ProjectTemplate {
    /**
     * A default value for the parameter, if applicable. This can be a hard-coded value or a variable reference.
     */
    defaultValue?: string;
    /**
     * The display settings for the parameter.
     */
    displaySettings?: {[key: string]: string};
    /**
     * The help presented alongside the parameter input.
     */
    helpText?: string;
    /**
     * The ID of the template parameter.
     */
    id: string;
    /**
     * The label shown beside the parameter when presented in the deployment process.
     */
    label?: string;
    /**
     * The name of the variable set by the parameter. The name can contain letters, digits, dashes and periods.
     */
    name: string;
}

export interface ProjectVersioningStrategy {
    donorPackageStepId?: string;
    donorPackages?: outputs.ProjectVersioningStrategyDonorPackage[];
    template: string;
}

export interface ProjectVersioningStrategyDonorPackage {
    deploymentAction?: string;
    packageReference?: string;
}

export interface RunbookConnectivityPolicy {
    allowDeploymentsToNoTargets: boolean;
    excludeUnhealthyTargets: boolean;
    skipMachineBehavior: string;
    targetRoles: string[];
}

export interface RunbookProcessStep {
    actions?: outputs.RunbookProcessStepAction[];
    applyTerraformTemplateActions?: outputs.RunbookProcessStepApplyTerraformTemplateAction[];
    /**
     * When to run the step, one of 'Success', 'Failure', 'Always' or 'Variable'
     */
    condition?: string;
    /**
     * The expression to evaluate to determine whether to run this step when 'condition' is 'Variable'
     */
    conditionExpression: string;
    deployKubernetesSecretActions?: outputs.RunbookProcessStepDeployKubernetesSecretAction[];
    deployPackageActions?: outputs.RunbookProcessStepDeployPackageAction[];
    deployWindowsServiceActions?: outputs.RunbookProcessStepDeployWindowsServiceAction[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    manualInterventionActions?: outputs.RunbookProcessStepManualInterventionAction[];
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * Whether to run this step before or after package acquisition (if possible)
     */
    packageRequirement?: string;
    properties: {[key: string]: string};
    runKubectlScriptActions?: outputs.RunbookProcessStepRunKubectlScriptAction[];
    runScriptActions?: outputs.RunbookProcessStepRunScriptAction[];
    /**
     * Whether to run this step after the previous step ('StartAfterPrevious') or at the same time as the previous step ('StartWithPrevious')
     */
    startTrigger?: string;
    /**
     * The roles that this step run against, or runs on behalf of
     */
    targetRoles: string[];
    /**
     * The maximum number of targets to deploy to simultaneously
     */
    windowSize?: string;
}

export interface RunbookProcessStepAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepActionActionTemplate;
    /**
     * The type of action
     */
    actionType: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.RunbookProcessStepActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of the package
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepApplyTerraformTemplateAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepApplyTerraformTemplateActionActionTemplate;
    advancedOptions: outputs.RunbookProcessStepApplyTerraformTemplateActionAdvancedOptions;
    awsAccount?: outputs.RunbookProcessStepApplyTerraformTemplateActionAwsAccount;
    azureAccount?: outputs.RunbookProcessStepApplyTerraformTemplateActionAzureAccount;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepApplyTerraformTemplateActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepApplyTerraformTemplateActionGitDependency;
    googleCloudAccount?: outputs.RunbookProcessStepApplyTerraformTemplateActionGoogleCloudAccount;
    /**
     * The unique ID for this resource.
     */
    id: string;
    inlineTemplate?: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepApplyTerraformTemplateActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.RunbookProcessStepApplyTerraformTemplateActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    template?: outputs.RunbookProcessStepApplyTerraformTemplateActionTemplate;
    templateParameters?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAdvancedOptions {
    allowAdditionalPluginDownloads?: boolean;
    applyParameters?: string;
    initParameters?: string;
    pluginCacheDirectory?: string;
    workspace?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAwsAccount {
    region?: string;
    role?: outputs.RunbookProcessStepApplyTerraformTemplateActionAwsAccountRole;
    useInstanceRole?: boolean;
    variable?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAwsAccountRole {
    arn?: string;
    externalId?: string;
    roleSessionName?: string;
    sessionDuration?: number;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAzureAccount {
    variable?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionGoogleCloudAccount {
    /**
     * Impersonate service accounts
     */
    impersonateServiceAccount?: boolean;
    /**
     * This sets GOOGLE_PROJECT environment variable
     */
    project?: string;
    /**
     * This sets GOOGLE_REGION environment variable
     */
    region?: string;
    /**
     * This sets GOOGLE_IMPERSONATE_SERVICE_ACCOUNT environment variable
     */
    serviceAccountEmails?: string;
    /**
     * When running in a Compute Engine virtual machine, use the associated VM service account
     */
    useVmServiceAccount?: boolean;
    variable?: string;
    /**
     * This sets GOOGLE_ZONE environment variable
     */
    zone?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepApplyTerraformTemplateActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepApplyTerraformTemplateActionTemplate {
    additionalVariableFiles?: string;
    directory?: string;
    runAutomaticFileSubstitution?: boolean;
    targetFiles?: string;
}

export interface RunbookProcessStepDeployKubernetesSecretAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepDeployKubernetesSecretActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepDeployKubernetesSecretActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepDeployKubernetesSecretActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * Indicates the status of the Kubernetes Object Status feature
     */
    kubernetesObjectStatusCheckEnabled?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepDeployKubernetesSecretActionPackage[];
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The name of the secret resource
     */
    secretName: string;
    secretValues: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepDeployKubernetesSecretActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepDeployKubernetesSecretActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepDeployKubernetesSecretActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepDeployKubernetesSecretActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployPackageAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepDeployPackageActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepDeployPackageActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepDeployPackageActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepDeployPackageActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepDeployPackageActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * Deploy a windows service feature
     */
    windowsService?: outputs.RunbookProcessStepDeployPackageActionWindowsService;
}

export interface RunbookProcessStepDeployPackageActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepDeployPackageActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepDeployPackageActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepDeployPackageActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployPackageActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployPackageActionWindowsService {
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
}

export interface RunbookProcessStepDeployWindowsServiceAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepDeployWindowsServiceActionActionTemplate;
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepDeployWindowsServiceActionContainer[];
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepDeployWindowsServiceActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepDeployWindowsServiceActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepDeployWindowsServiceActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface RunbookProcessStepDeployWindowsServiceActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepDeployWindowsServiceActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepDeployWindowsServiceActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepDeployWindowsServiceActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployWindowsServiceActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepManualInterventionAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepManualInterventionActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepManualInterventionActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepManualInterventionActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The instructions for the user to follow
     */
    instructions: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepManualInterventionActionPackage[];
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * The teams responsible to resolve this step. If no teams are specified, all users who have permission to deploy the project can resolve it.
     */
    responsibleTeams?: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface RunbookProcessStepManualInterventionActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepManualInterventionActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepManualInterventionActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepManualInterventionActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunKubectlScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepRunKubectlScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepRunKubectlScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepRunKubectlScriptActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    namespace?: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepRunKubectlScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.RunbookProcessStepRunKubectlScriptActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepRunKubectlScriptActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepRunKubectlScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepRunKubectlScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepRunKubectlScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of the package
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunKubectlScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate?: outputs.RunbookProcessStepRunScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers?: outputs.RunbookProcessStepRunScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency?: outputs.RunbookProcessStepRunScriptActionGitDependency;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages?: outputs.RunbookProcessStepRunScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage?: outputs.RunbookProcessStepRunScriptActionPrimaryPackage;
    /**
     * The properties associated with this deployment action.
     *
     * @deprecated Deprecated
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepRunScriptActionActionTemplate {
    communityActionTemplateId: string;
    id: string;
    version: number;
}

export interface RunbookProcessStepRunScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepRunScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepRunScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of the package
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookRetentionPolicy {
    /**
     * How many runs to keep per environment.
     */
    quantityToKeep: number;
    /**
     * Indicates if items should never be deleted. The default value is `false`.
     */
    shouldKeepForever: boolean;
}

export interface ScriptModuleScript {
    /**
     * The body of this script module.
     */
    body: string;
    /**
     * The syntax of the script. Valid types are `Bash`, `CSharp`, `FSharp`, `PowerShell`, or `Python`.
     */
    syntax: string;
}

export interface SshConnectionDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication?: outputs.SshConnectionDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers?: outputs.SshConnectionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations?: outputs.SshConnectionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails?: outputs.SshConnectionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface SshConnectionDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface SshConnectionDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface SshConnectionDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface SshConnectionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface TeamExternalSecurityGroup {
    displayIdAndName: boolean;
    displayName: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
}

export interface TeamUserRole {
    environmentIds?: string[];
    id: string;
    projectGroupIds?: string[];
    projectIds?: string[];
    spaceId: string;
    teamId: string;
    tenantIds?: string[];
    userRoleId: string;
}

export interface UserIdentity {
    claims?: outputs.UserIdentityClaim[];
    provider?: string;
}

export interface UserIdentityClaim {
    isIdentifyingClaim: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    value: string;
}

export interface VariablePrompt {
    /**
     * The description of this variable prompt option.
     */
    description: string;
    displaySettings?: outputs.VariablePromptDisplaySetting[];
    isRequired?: boolean;
    label?: string;
}

export interface VariablePromptDisplaySetting {
    /**
     * The type of control for rendering this prompted variable. Valid types are `SingleLineText`, `MultiLineText`, `Checkbox`, `Select`.
     */
    controlType: string;
    /**
     * If the `control_type` is `Select`, then this value defines an option.
     */
    selectOptions?: outputs.VariablePromptDisplaySettingSelectOption[];
}

export interface VariablePromptDisplaySettingSelectOption {
    /**
     * The display name for the select value
     */
    displayName: string;
    /**
     * The select value
     */
    value: string;
}

export interface VariableScope {
    /**
     * A list of actions that are scoped to this variable value.
     */
    actions?: string[];
    /**
     * A list of channels that are scoped to this variable value.
     */
    channels?: string[];
    /**
     * A list of environments that are scoped to this variable value.
     */
    environments?: string[];
    /**
     * A list of machines that are scoped to this variable value.
     */
    machines?: string[];
    /**
     * A list of processes that are scoped to this variable value.
     */
    processes?: string[];
    /**
     * A list of roles that are scoped to this variable value.
     */
    roles?: string[];
    /**
     * A list of tenant tags that are scoped to this variable value.
     */
    tenantTags?: string[];
}

