// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterAutoscalerResourceLimits {
    /**
     * Minimum and maximum number of cores in cluster, in the format <min>:<max>. Cluster autoscaler will not scale the cluster beyond these numbers.
     */
    cores?: outputs.ClusterAutoscalerResourceLimitsCores;
    /**
     * Minimum and maximum number of different GPUs in cluster, in the format <gpu_type>:<min>:<max>. Cluster autoscaler will not scale the cluster beyond these numbers. Can be passed multiple times.
     */
    gpuses?: outputs.ClusterAutoscalerResourceLimitsGpus[];
    /**
     * Maximum number of nodes in all node groups. Cluster autoscaler will not grow the cluster beyond this number.
     */
    maxNodesTotal?: number;
    /**
     * Minimum and maximum number of gigabytes of memory in cluster, in the format <min>:<max>. Cluster autoscaler will not scale the cluster beyond these numbers.
     */
    memory?: outputs.ClusterAutoscalerResourceLimitsMemory;
}

export interface ClusterAutoscalerResourceLimitsCores {
    max: number;
    min: number;
}

export interface ClusterAutoscalerResourceLimitsGpus {
    /**
     * limit number of GPU type
     */
    range: outputs.ClusterAutoscalerResourceLimitsGpusRange;
    type: string;
}

export interface ClusterAutoscalerResourceLimitsGpusRange {
    max: number;
    min: number;
}

export interface ClusterAutoscalerResourceLimitsMemory {
    max: number;
    min: number;
}

export interface ClusterAutoscalerScaleDown {
    /**
     * How long after scale up that scale down evaluation resumes.
     */
    delayAfterAdd?: string;
    /**
     * How long after node deletion that scale down evaluation resumes.
     */
    delayAfterDelete?: string;
    /**
     * How long after scale down failure that scale down evaluation resumes.
     */
    delayAfterFailure?: string;
    /**
     * Should cluster-autoscaler scale down the cluster.
     */
    enabled?: boolean;
    /**
     * How long a node should be unneeded before it is eligible for scale down.
     */
    unneededTime?: string;
    /**
     * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down.
     */
    utilizationThreshold?: string;
}

export interface ClusterProxy {
    /**
     * A string containing a PEM-encoded X.509 certificate bundle that will be added to the nodes' trusted certificate store. To reset please provide '' (empty string)
     */
    additionalTrustBundle?: string;
    /**
     * HTTP proxy. To reset please provide '' (empty string)
     */
    httpProxy?: string;
    /**
     * HTTPS proxy. To reset please provide '' (empty string)
     */
    httpsProxy?: string;
    /**
     * No proxy. To reset please provide '' (empty string)
     */
    noProxy?: string;
}

export interface ClusterRosaClassicAdminCredentials {
    /**
     * Admin password that will be created with the cluster.
     */
    password: string;
    /**
     * Admin username that will be created with the cluster.
     */
    username: string;
}

export interface ClusterRosaClassicPrivateHostedZone {
    /**
     * ID assigned by AWS to private Route 53 hosted zone associated with intended shared VPC, e.g. 'Z05646003S02O1ENCDCSN'.
     */
    id: string;
    /**
     * AWS IAM role ARN with a policy attached, granting permissions necessary to create and manage Route 53 DNS records in private Route 53 hosted zone associated with intended shared VPC.
     */
    roleArn: string;
}

export interface ClusterRosaClassicProxy {
    /**
     * A string containing a PEM-encoded X.509 certificate bundle that will be added to the nodes' trusted certificate store. To reset please provide '' (empty string)
     */
    additionalTrustBundle?: string;
    /**
     * HTTP proxy. To reset please provide '' (empty string)
     */
    httpProxy?: string;
    /**
     * HTTPS proxy. To reset please provide '' (empty string)
     */
    httpsProxy?: string;
    /**
     * No proxy. To reset please provide '' (empty string)
     */
    noProxy?: string;
}

export interface ClusterRosaClassicSts {
    /**
     * Instance IAM Roles
     */
    instanceIamRoles: outputs.ClusterRosaClassicStsInstanceIamRoles;
    /**
     * OIDC Configuration ID
     */
    oidcConfigId?: string;
    /**
     * OIDC Endpoint URL
     */
    oidcEndpointUrl: string;
    /**
     * Operator IAM Role prefix
     */
    operatorRolePrefix: string;
    /**
     * Installer Role
     */
    roleArn: string;
    /**
     * Support Role
     */
    supportRoleArn: string;
    /**
     * SHA1-hash value of the root CA of the issuer URL
     */
    thumbprint: string;
}

export interface ClusterRosaClassicStsInstanceIamRoles {
    /**
     * Master/Control Plane Node Role ARN
     */
    masterRoleArn: string;
    /**
     * Worker/Compute Node Role ARN
     */
    workerRoleArn: string;
}

export interface ClusterRosaHcpAdminCredentials {
    /**
     * Admin password that will be created with the cluster.
     */
    password: string;
    /**
     * Admin username that will be created with the cluster.
     */
    username: string;
}

export interface ClusterRosaHcpProxy {
    /**
     * A string containing a PEM-encoded X.509 certificate bundle that will be added to the nodes' trusted certificate store. To reset please provide '' (empty string)
     */
    additionalTrustBundle?: string;
    /**
     * HTTP proxy. To reset please provide '' (empty string)
     */
    httpProxy?: string;
    /**
     * HTTPS proxy. To reset please provide '' (empty string)
     */
    httpsProxy?: string;
    /**
     * No proxy. To reset please provide '' (empty string)
     */
    noProxy?: string;
}

export interface ClusterRosaHcpSts {
    /**
     * Instance IAM Roles
     */
    instanceIamRoles: outputs.ClusterRosaHcpStsInstanceIamRoles;
    /**
     * OIDC Configuration ID
     */
    oidcConfigId?: string;
    /**
     * OIDC Endpoint URL
     */
    oidcEndpointUrl: string;
    /**
     * Operator IAM Role prefix
     */
    operatorRolePrefix: string;
    /**
     * Installer Role
     */
    roleArn: string;
    /**
     * Support Role
     */
    supportRoleArn: string;
    /**
     * SHA1-hash value of the root CA of the issuer URL
     */
    thumbprint: string;
}

export interface ClusterRosaHcpStsInstanceIamRoles {
    /**
     * Worker/Compute Node Role ARN
     */
    workerRoleArn: string;
}

export interface DefaultIngressComponentRoutes {
    hostname: string;
    tlsSecretRef: string;
}

export interface GetCloudProvidersItem {
    /**
     * Human friendly name of the cloud provider, for example 'AWS' or 'GCP'
     */
    displayName: string;
    /**
     * Unique identifier of the cloud provider. This is what should be used when referencing the cloud provider from other places, for example in the 'cloud_provider' attribute of the cluster resource.
     */
    id: string;
    /**
     * Short name of the cloud provider, for example 'aws' or 'gcp'.
     */
    name: string;
}

export interface GetClusterRosaClassicAdminCredentials {
    /**
     * Admin password that will be created with the cluster.
     */
    password: string;
    /**
     * Admin username that will be created with the cluster.
     */
    username: string;
}

export interface GetClusterRosaClassicPrivateHostedZone {
    /**
     * ID assigned by AWS to private Route 53 hosted zone associated with intended shared VPC, e.g. 'Z05646003S02O1ENCDCSN'.
     */
    id: string;
    /**
     * AWS IAM role ARN with a policy attached, granting permissions necessary to create and manage Route 53 DNS records in private Route 53 hosted zone associated with intended shared VPC.
     */
    roleArn: string;
}

export interface GetClusterRosaClassicProxy {
    /**
     * A string containing a PEM-encoded X.509 certificate bundle that will be added to the nodes' trusted certificate store.
     */
    additionalTrustBundle: string;
    /**
     * HTTP proxy.
     */
    httpProxy: string;
    /**
     * HTTPS proxy.
     */
    httpsProxy: string;
    /**
     * No proxy.
     */
    noProxy: string;
}

export interface GetClusterRosaClassicSts {
    /**
     * Instance IAM Roles
     */
    instanceIamRoles: outputs.GetClusterRosaClassicStsInstanceIamRoles;
    /**
     * OIDC Configuration ID
     */
    oidcConfigId: string;
    /**
     * OIDC Endpoint URL
     */
    oidcEndpointUrl: string;
    /**
     * Operator IAM Role prefix
     */
    operatorRolePrefix: string;
    /**
     * Installer Role
     */
    roleArn: string;
    /**
     * Support Role
     */
    supportRoleArn: string;
    /**
     * SHA1-hash value of the root CA of the issuer URL
     */
    thumbprint: string;
}

export interface GetClusterRosaClassicStsInstanceIamRoles {
    /**
     * Master/Control Plane Node Role ARN
     */
    masterRoleArn: string;
    /**
     * Worker/Compute Node Role ARN
     */
    workerRoleArn: string;
}

export interface GetClusterRosaHcpAdminCredentials {
    /**
     * Admin password that will be created with the cluster.
     */
    password: string;
    /**
     * Admin username that will be created with the cluster.
     */
    username: string;
}

export interface GetClusterRosaHcpProxy {
    /**
     * A string containing a PEM-encoded X.509 certificate bundle that will be added to the nodes' trusted certificate store.
     */
    additionalTrustBundle: string;
    /**
     * HTTP proxy.
     */
    httpProxy: string;
    /**
     * HTTPS proxy.
     */
    httpsProxy: string;
    /**
     * No proxy.
     */
    noProxy: string;
}

export interface GetClusterRosaHcpSts {
    /**
     * Instance IAM Roles
     */
    instanceIamRoles: outputs.GetClusterRosaHcpStsInstanceIamRoles;
    /**
     * OIDC Configuration ID
     */
    oidcConfigId: string;
    /**
     * OIDC Endpoint URL
     */
    oidcEndpointUrl: string;
    /**
     * Operator IAM Role prefix
     */
    operatorRolePrefix: string;
    /**
     * Installer Role
     */
    roleArn: string;
    /**
     * Support Role
     */
    supportRoleArn: string;
    /**
     * SHA1-hash value of the root CA of the issuer URL
     */
    thumbprint: string;
}

export interface GetClusterRosaHcpStsInstanceIamRoles {
    /**
     * Worker/Compute Node Role ARN
     */
    workerRoleArn: string;
}

export interface GetGroupsItem {
    /**
     * Unique identifier of the group. This is what should be used when referencing the group from other places, for example in the 'group' attribute of the user resource.
     */
    id: string;
    /**
     * Short name of the group for example 'dedicated-admins'.
     */
    name: string;
}

export interface GetHcpMachinePoolAutoscaling {
    /**
     * Enables autoscaling. If `true`, this variable requires you to set a maximum and minimum replicas range using the `max_replicas` and `min_replicas` variables.
     */
    enabled: boolean;
    /**
     * The maximum number of replicas for autoscaling functionality.
     */
    maxReplicas: number;
    /**
     * The minimum number of replicas for autoscaling functionality.
     */
    minReplicas: number;
}

export interface GetHcpMachinePoolAwsNodePool {
    /**
     * Additional security group ids. After the creation of the resource, it is not possible to update the attribute value.
     */
    additionalSecurityGroupIds?: string[];
    /**
     * This value determines which EC2 Instance Metadata Service mode to use for EC2 instances in the nodes.This can be set as `optional` (IMDS v1 or v2) or `required` (IMDSv2 only). This feature is available from After the creation of the resource, it is not possible to update the attribute value.
     */
    ec2MetadataHttpTokens: string;
    /**
     * Instance profile attached to the replica
     */
    instanceProfile: string;
    /**
     * Identifier of the machine type used by the nodes, for example `m5.xlarge`. Use the `rhcs.getMachineTypes` data source to find the possible values. After the creation of the resource, it is not possible to update the attribute value.
     */
    instanceType: string;
    /**
     * Apply user defined tags to all machine pool resources created in AWS. After the creation of the resource, it is not possible to update the attribute value.
     */
    tags?: {[key: string]: string};
}

export interface GetHcpMachinePoolStatus {
    /**
     * The current number of replicas.
     */
    currentReplicas: number;
    /**
     * Message regarding status of the replica
     */
    message: string;
}

export interface GetHcpMachinePoolTaint {
    /**
     * Taints key
     */
    key: string;
    /**
     * Taints schedule type
     */
    scheduleType: string;
    /**
     * Taints value
     */
    value: string;
}

export interface GetHcpPoliciesAccountRolePolicies {
    stsHcpInstallerPermissionPolicy: string;
    stsHcpInstanceWorkerPermissionPolicy: string;
    stsHcpSupportPermissionPolicy: string;
    stsSupportRhSreRole: string;
}

export interface GetHcpPoliciesOperatorRolePolicies {
    openshiftHcpCapaControllerManagerCredentialsPolicy: string;
    openshiftHcpCloudNetworkConfigControllerCloudCredentialsPolicy: string;
    openshiftHcpClusterCsiDriversEbsCloudCredentialsPolicy: string;
    openshiftHcpControlPlaneOperatorCredentialsPolicy: string;
    openshiftHcpImageRegistryInstallerCloudCredentialsPolicy: string;
    openshiftHcpIngressOperatorCloudCredentialsPolicy: string;
    openshiftHcpKmsProviderCredentialsPolicy: string;
    openshiftHcpKubeControllerManagerCredentialsPolicy: string;
}

export interface GetMachinePoolTaint {
    /**
     * Taints key
     */
    key: string;
    /**
     * Taints schedule type
     */
    scheduleType: string;
    /**
     * Taints value
     */
    value: string;
}

export interface GetMachineTypesItem {
    /**
     * Unique identifier of the cloud provider where the machine type is supported.
     */
    cloudProvider: string;
    /**
     * Number of vCPU cores.
     */
    cpu: number;
    /**
     * Unique identifier of the machine type.
     */
    id: string;
    /**
     * Short name of the machine type.
     */
    name: string;
    /**
     * Amount of RAM in bytes.
     */
    ram: number;
}

export interface GetPoliciesAccountRolePolicies {
    stsInstallerPermissionPolicy: string;
    stsInstanceControlplanePermissionPolicy: string;
    stsInstanceWorkerPermissionPolicy: string;
    stsSupportPermissionPolicy: string;
    stsSupportRhSreRole: string;
}

export interface GetPoliciesOperatorRolePolicies {
    openshiftCloudCredentialOperatorCloudCredentialOperatorIamRoCredsPolicy: string;
    openshiftCloudNetworkConfigControllerCloudCredentialsPolicy: string;
    openshiftClusterCsiDriversEbsCloudCredentialsPolicy: string;
    openshiftImageRegistryInstallerCloudCredentialsPolicy: string;
    openshiftIngressOperatorCloudCredentialsPolicy: string;
    openshiftMachineApiAwsCloudCredentialsPolicy: string;
    sharedVpcOpenshiftIngressOperatorCloudCredentialsPolicy: string;
}

export interface GetRosaHcpOperatorRolesOperatorIamRole {
    /**
     * Operator Name
     */
    operatorName: string;
    /**
     * Kubernetes Namespace
     */
    operatorNamespace: string;
    /**
     * policy name
     */
    policyName: string;
    /**
     * policy name
     */
    roleName: string;
    /**
     * service accounts
     */
    serviceAccounts: string[];
}

export interface GetRosaOperatorRolesOperatorIamRole {
    /**
     * Operator Name
     */
    operatorName: string;
    /**
     * Kubernetes Namespace
     */
    operatorNamespace: string;
    /**
     * policy name
     */
    policyName: string;
    /**
     * policy name
     */
    roleName: string;
    /**
     * service accounts
     */
    serviceAccounts: string[];
}

export interface GetTrustedIpAddressesItem {
    /**
     * Indicates if the IP is enabled.
     */
    enabled: boolean;
    /**
     * IP address.
     */
    id: string;
}

export interface GetVersionsItem {
    /**
     * Unique identifier of the version. This is what should be used when referencing the versions from other places, for example in the 'version' attribute of the cluster resource.
     */
    id: string;
    /**
     * Short name of the version, for example '4.1.0'.
     */
    name: string;
}

export interface HcpClusterAutoscalerResourceLimits {
    /**
     * Maximum number of nodes in all node groups. Cluster autoscaler will not grow the cluster beyond this number.
     */
    maxNodesTotal?: number;
}

export interface HcpMachinePoolAutoscaling {
    /**
     * Enables autoscaling. If `true`, this variable requires you to set a maximum and minimum replicas range using the `max_replicas` and `min_replicas` variables.
     */
    enabled: boolean;
    /**
     * The maximum number of replicas for autoscaling functionality.
     */
    maxReplicas?: number;
    /**
     * The minimum number of replicas for autoscaling functionality.
     */
    minReplicas?: number;
}

export interface HcpMachinePoolAwsNodePool {
    /**
     * Additional security group ids. After the creation of the resource, it is not possible to update the attribute value.
     */
    additionalSecurityGroupIds?: string[];
    /**
     * This value determines which EC2 Instance Metadata Service mode to use for EC2 instances in the nodes.This can be set as `optional` (IMDS v1 or v2) or `required` (IMDSv2 only). This feature is available from After the creation of the resource, it is not possible to update the attribute value.
     */
    ec2MetadataHttpTokens: string;
    /**
     * Instance profile attached to the replica
     */
    instanceProfile: string;
    /**
     * Identifier of the machine type used by the nodes, for example `m5.xlarge`. Use the `rhcs.getMachineTypes` data source to find the possible values. After the creation of the resource, it is not possible to update the attribute value.
     */
    instanceType: string;
    /**
     * Apply user defined tags to all machine pool resources created in AWS.After the creation of the resource, it is not possible to update the attribute value.
     */
    tags?: {[key: string]: string};
}

export interface HcpMachinePoolStatus {
    /**
     * The current number of replicas.
     */
    currentReplicas: number;
    /**
     * Message regarding status of the replica
     */
    message: string;
}

export interface HcpMachinePoolTaint {
    /**
     * Taints key
     */
    key: string;
    /**
     * Taints schedule type
     */
    scheduleType: string;
    /**
     * Taints value
     */
    value: string;
}

export interface IdentityProviderGithub {
    /**
     * Path to PEM-encoded certificate file to use when making requests to the server.
     */
    ca?: string;
    /**
     * Client identifier of a registered Github OAuth application.
     */
    clientId: string;
    /**
     * Client secret issued by Github.
     */
    clientSecret: string;
    /**
     * Optional domain to use with a hosted instance of GitHub Enterprise.
     */
    hostname?: string;
    /**
     * Only users that are members of at least one of the listed organizations will be allowed to log in.
     */
    organizations?: string[];
    /**
     * Only users that are members of at least one of the listed teams will be allowed to log in. The format is `<org>`/`<team>`.
     */
    teams?: string[];
}

export interface IdentityProviderGitlab {
    /**
     * Optional trusted certificate authority bundle.
     */
    ca?: string;
    /**
     * Client identifier of a registered Gitlab OAuth application.
     */
    clientId: string;
    /**
     * Client secret issued by Gitlab.
     */
    clientSecret: string;
    /**
     * URL of the Gitlab instance.
     */
    url: string;
}

export interface IdentityProviderGoogle {
    /**
     * Client identifier of a registered Google OAuth application.
     */
    clientId: string;
    /**
     * Client secret issued by Google.
     */
    clientSecret: string;
    /**
     * Restrict users to a Google Apps domain.
     */
    hostedDomain?: string;
}

export interface IdentityProviderHtpasswd {
    /**
     * A list of htpasswd user credentials
     */
    users: outputs.IdentityProviderHtpasswdUser[];
}

export interface IdentityProviderHtpasswdUser {
    /**
     * User password.
     */
    password: string;
    /**
     * User username.
     */
    username: string;
}

export interface IdentityProviderLdap {
    attributes: outputs.IdentityProviderLdapAttributes;
    /**
     * DN to bind with during the search phase.
     */
    bindDn?: string;
    /**
     * Password to bind with during the search phase.
     */
    bindPassword?: string;
    /**
     * Optional trusted certificate authority bundle.
     */
    ca?: string;
    /**
     * Do not make TLS connections to the server.
     */
    insecure: boolean;
    /**
     * An RFC 2255 URL which specifies the LDAP search parameters to use.
     */
    url: string;
}

export interface IdentityProviderLdapAttributes {
    /**
     * The list of attributes whose values should be used as the email address.
     */
    emails: string[];
    /**
     * The list of attributes whose values should be used as the user ID. (default ['dn'])
     */
    ids: string[];
    /**
     * The list of attributes whose values should be used as the display name. (default ['cn'])
     */
    names: string[];
    /**
     * The list of attributes whose values should be used as the preferred username. (default ['uid'])
     */
    preferredUsernames: string[];
}

export interface IdentityProviderOpenid {
    /**
     * Optional trusted certificate authority bundle.
     */
    ca?: string;
    /**
     * OpenID Claims config.
     */
    claims: outputs.IdentityProviderOpenidClaims;
    /**
     * Client ID from the registered application.
     */
    clientId: string;
    /**
     * Client Secret from the registered application.
     */
    clientSecret: string;
    extraAuthorizeParameters?: {[key: string]: string};
    /**
     * List of scopes to request, in addition to the 'openid' scope, during the authorization token request.
     */
    extraScopes?: string[];
    /**
     * The URL that the OpenID Provider asserts as the Issuer Identifier. It must use the https scheme with no URL query parameters or fragment.
     */
    issuer: string;
}

export interface IdentityProviderOpenidClaims {
    /**
     * List of claims to use as the email address.
     */
    emails?: string[];
    /**
     * List of claims to use as the groups names.
     */
    groups?: string[];
    /**
     * List of claims to use as the display name.
     */
    names?: string[];
    /**
     * List of claims to use as the preferred username when provisioning a user.
     */
    preferredUsernames?: string[];
}

export interface MachinePoolTaint {
    /**
     * Taints key
     */
    key: string;
    /**
     * Taints schedule type
     */
    scheduleType: string;
    /**
     * Taints value
     */
    value: string;
}

