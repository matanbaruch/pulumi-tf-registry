// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class CipherStreamProvider extends pulumi.CustomResource {
    /**
     * Get an existing CipherStreamProvider resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: CipherStreamProviderState, opts?: pulumi.CustomResourceOptions): CipherStreamProvider {
        return new CipherStreamProvider(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'pingdirectory:index/cipherStreamProvider:CipherStreamProvider';

    /**
     * Returns true if the given object is an instance of CipherStreamProvider.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is CipherStreamProvider {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === CipherStreamProvider.__pulumiType;
    }

    /**
     * The access key ID that will be used if this cipher stream provider will authenticate to the Amazon Key Management
     * Service using an access key rather than an IAM role associated with an EC2 instance.
     */
    public readonly awsAccessKeyId!: pulumi.Output<string | undefined>;
    /**
     * When the `type` attribute is set to: - `amazon-key-management-service`: The external server with information to use when
     * interacting with the Amazon Key Management Service. - `amazon-secrets-manager`: The external server with information to
     * use when interacting with the AWS Secrets Manager.
     */
    public readonly awsExternalServer!: pulumi.Output<string | undefined>;
    /**
     * The name of the Amazon Web Services region that holds the encryption key. This is optional, and if it is not provided,
     * then the server will attempt to determine the region from the key ARN.
     */
    public readonly awsRegionName!: pulumi.Output<string | undefined>;
    /**
     * The secret access key that will be used if this cipher stream provider will authenticate to the Amazon Key Management
     * Service using an access key rather than an IAM role associated with an EC2 instance.
     */
    public readonly awsSecretAccessKey!: pulumi.Output<string | undefined>;
    /**
     * The mechanism used to authenticate to the Azure service.
     */
    public readonly azureAuthenticationMethod!: pulumi.Output<string | undefined>;
    /**
     * An external server definition with information needed to connect and authenticate to the Conjur server.
     */
    public readonly conjurExternalServer!: pulumi.Output<string | undefined>;
    /**
     * The portion of the path that follows the account name in the URI needed to obtain the secret passphrase to use to
     * generate the encryption key. Any special characters in the path must be URL-encoded.
     */
    public readonly conjurSecretRelativePath!: pulumi.Output<string | undefined>;
    /**
     * A description for this Cipher Stream Provider
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * Indicates whether this Cipher Stream Provider is enabled for use in the Directory Server.
     */
    public readonly enabled!: pulumi.Output<boolean>;
    /**
     * The path to a file that will hold the encrypted passphrase used by this cipher stream provider.
     */
    public readonly encryptedPassphraseFile!: pulumi.Output<string>;
    /**
     * When the `type` attribute is set to: - `amazon-secrets-manager`: The path to a file that will hold metadata about the
     * encryption performed by this Amazon Secrets Manager Cipher Stream Provider. - `azure-key-vault`: The path to a file that
     * will hold metadata about the encryption performed by this Azure Key Vault Cipher Stream Provider. - `file-based`: The
     * path to a file that will hold metadata about the encryption performed by this File Based Cipher Stream Provider. -
     * `conjur`: The path to a file that will hold metadata about the encryption performed by this Conjur Cipher Stream
     * Provider. - `pkcs11`: The path to a file that will hold metadata about the encryption performed by this PKCS11 Cipher
     * Stream Provider.
     */
    public readonly encryptionMetadataFile!: pulumi.Output<string>;
    /**
     * The set of arguments used to customize the behavior for the Third Party Cipher Stream Provider. Each configuration
     * property should be given in the form 'name=value'.
     */
    public readonly extensionArguments!: pulumi.Output<string[]>;
    /**
     * The fully-qualified name of the Java class providing the logic for the Third Party Cipher Stream Provider.
     */
    public readonly extensionClass!: pulumi.Output<string | undefined>;
    /**
     * Supported in PingDirectory product version 9.2.0.0+. A reference to an HTTP proxy server that should be used for
     * requests sent to the Azure service.
     */
    public readonly httpProxyExternalServer!: pulumi.Output<string | undefined>;
    /**
     * Supported in PingDirectory product version 9.3.0.0+. The PBKDF2 iteration count that will be used when deriving the
     * encryption key used to protect the encryption settings database.
     */
    public readonly iterationCount!: pulumi.Output<number>;
    /**
     * The clear-text user PIN needed to interact with the PKCS #11 token.
     */
    public readonly keyStorePin!: pulumi.Output<string | undefined>;
    /**
     * The name of an environment variable whose value is the user PIN needed to interact with the PKCS #11 token. The
     * environment variable must be defined and must contain a clear-text representation of the PIN.
     */
    public readonly keyStorePinEnvironmentVariable!: pulumi.Output<string | undefined>;
    /**
     * The path to a file containing the user PIN needed to interact with the PKCS #11 token. The file must exist and must
     * contain exactly one line with a clear-text representation of the PIN.
     */
    public readonly keyStorePinFile!: pulumi.Output<string | undefined>;
    /**
     * The URI that identifies the Azure Key Vault from which the secret is to be retrieved.
     */
    public readonly keyVaultUri!: pulumi.Output<string | undefined>;
    /**
     * Supported in PingDirectory product version 10.1.0.0+. The cipher transformation that will be used to wrap and unwrap the
     * encryption key. If no key wrapping transformation is defined, then the server will select a transformation based on the
     * type of certificate being used.
     */
    public readonly keyWrappingTransformation!: pulumi.Output<string | undefined>;
    /**
     * The Amazon resource name (ARN) for the KMS key that will be used to encrypt the contents of the passphrase file. This
     * key must exist, and the AWS client must have access to encrypt and decrypt data using this key.
     */
    public readonly kmsEncryptionKeyArn!: pulumi.Output<string | undefined>;
    /**
     * Name of this config object.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Notifications returned by the PingDirectory Configuration API.
     */
    public /*out*/ readonly notifications!: pulumi.Output<string[]>;
    /**
     * The path to the file containing the password to use when generating ciphers.
     */
    public readonly passwordFile!: pulumi.Output<string | undefined>;
    /**
     * The key store type to use when obtaining an instance of a key store for interacting with a PKCS #11 token.
     */
    public readonly pkcs11KeyStoreType!: pulumi.Output<string>;
    /**
     * The fully-qualified name of the Java security provider class that implements support for interacting with PKCS #11
     * tokens.
     */
    public readonly pkcs11ProviderClass!: pulumi.Output<string | undefined>;
    /**
     * The path to the file to use to configure the security provider that implements support for interacting with PKCS #11
     * tokens.
     */
    public readonly pkcs11ProviderConfigurationFile!: pulumi.Output<string | undefined>;
    /**
     * Required actions returned by the PingDirectory Configuration API.
     */
    public /*out*/ readonly requiredActions!: pulumi.Output<outputs.CipherStreamProviderRequiredAction[]>;
    /**
     * The name of the JSON field whose value is the passphrase that will be used to generate the encryption key for protecting
     * the contents of the encryption settings database.
     */
    public readonly secretFieldName!: pulumi.Output<string | undefined>;
    /**
     * The Amazon Resource Name (ARN) or the user-friendly name of the secret to be retrieved.
     */
    public readonly secretId!: pulumi.Output<string | undefined>;
    /**
     * The name of the secret to retrieve.
     */
    public readonly secretName!: pulumi.Output<string | undefined>;
    /**
     * The unique identifier for the version of the secret to be retrieved.
     */
    public readonly secretVersionId!: pulumi.Output<string | undefined>;
    /**
     * The staging label for the version of the secret to be retrieved.
     */
    public readonly secretVersionStage!: pulumi.Output<string | undefined>;
    /**
     * The alias for the certificate in the PKCS #11 token that will be used to wrap the encryption key. The target certificate
     * must exist in the PKCS #11 token, and it must have an RSA key pair because the JVM does not currently provide adequate
     * key wrapping support for elliptic curve key pairs. If you have also configured the server to use a PKCS #11 token for
     * accessing listener certificates, we strongly recommend that you use a different certificate to protect the contents of
     * the encryption settings database than you use for negotiating TLS sessions with clients. It is imperative that the
     * certificate used by this PKCS11 Cipher Stream Provider remain constant for the life of the provider because if the
     * certificate were to be replaced, then the contents of the encryption settings database could become inaccessible. Unlike
     * with listener certificates used for TLS negotiation that need to be replaced on a regular basis, this PKCS11 Cipher
     * Stream Provider does not consider the validity period for the associated certificate, and it will continue to function
     * even after the certificate has expired. If you need to rotate the certificate used to protect the server's encryption
     * settings database, you should first install the desired new certificate in the PKCS #11 token under a different alias.
     * Then, you should create a new instance of this PKCS11 Cipher Stream Provider that is configured to use that certificate,
     * and that also uses a different value for the encryption-metadata-file because the information in that file is tied to
     * the certificate used to generate it. Finally, you will need to update the global configuration so that the
     * encryption-settings-cipher-stream-provider property references the new cipher stream provider rather than this one. The
     * update to the global configuration must be done with the server online so that it can properly re-encrypt the contents
     * of the encryption settings database with the correct key tied to the new certificate.
     */
    public readonly sslCertNickname!: pulumi.Output<string | undefined>;
    /**
     * The path to a file containing the information needed to trust the certificate presented by the Vault servers.
     */
    public readonly trustStoreFile!: pulumi.Output<string | undefined>;
    /**
     * The passphrase needed to access the contents of the trust store. This is only required if a trust store file is
     * required, and if that trust store requires a PIN to access its contents.
     */
    public readonly trustStorePin!: pulumi.Output<string | undefined>;
    /**
     * The store type for the specified trust store file. The value should likely be one of "JKS" or "PKCS12".
     */
    public readonly trustStoreType!: pulumi.Output<string>;
    /**
     * The type of Cipher Stream Provider resource. Options are ['amazon-key-management-service', 'amazon-secrets-manager',
     * 'azure-key-vault', 'file-based', 'wait-for-passphrase', 'conjur', 'pkcs11', 'vault', 'third-party']
     */
    public readonly type!: pulumi.Output<string>;
    /**
     * The mechanism used to authenticate to the Vault server.
     */
    public readonly vaultAuthenticationMethod!: pulumi.Output<string | undefined>;
    /**
     * The path to a file that will hold metadata about the encryption performed by this Vault Cipher Stream Provider.
     */
    public readonly vaultEncryptionMetadataFile!: pulumi.Output<string>;
    /**
     * An external server definition with information needed to connect and authenticate to the Vault server.
     */
    public readonly vaultExternalServer!: pulumi.Output<string | undefined>;
    /**
     * The name of the field in the Vault secret record that contains the passphrase to use to generate the encryption key.
     */
    public readonly vaultSecretFieldName!: pulumi.Output<string | undefined>;
    /**
     * The path to the desired secret in the Vault service. This will be appended to the value of the base-url property for the
     * associated Vault external server.
     */
    public readonly vaultSecretPath!: pulumi.Output<string | undefined>;
    /**
     * The base URL needed to access the Vault server. The base URL should consist of the protocol ("http" or "https"), the
     * server address (resolvable name or IP address), and the port number. For example, "https://vault.example.com:8200/".
     */
    public readonly vaultServerBaseUris!: pulumi.Output<string[]>;
    /**
     * Indicates whether the server should wait for the password file to become available if it does not exist.
     */
    public readonly waitForPasswordFile!: pulumi.Output<boolean>;

    /**
     * Create a CipherStreamProvider resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: CipherStreamProviderArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: CipherStreamProviderArgs | CipherStreamProviderState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as CipherStreamProviderState | undefined;
            resourceInputs["awsAccessKeyId"] = state ? state.awsAccessKeyId : undefined;
            resourceInputs["awsExternalServer"] = state ? state.awsExternalServer : undefined;
            resourceInputs["awsRegionName"] = state ? state.awsRegionName : undefined;
            resourceInputs["awsSecretAccessKey"] = state ? state.awsSecretAccessKey : undefined;
            resourceInputs["azureAuthenticationMethod"] = state ? state.azureAuthenticationMethod : undefined;
            resourceInputs["conjurExternalServer"] = state ? state.conjurExternalServer : undefined;
            resourceInputs["conjurSecretRelativePath"] = state ? state.conjurSecretRelativePath : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["enabled"] = state ? state.enabled : undefined;
            resourceInputs["encryptedPassphraseFile"] = state ? state.encryptedPassphraseFile : undefined;
            resourceInputs["encryptionMetadataFile"] = state ? state.encryptionMetadataFile : undefined;
            resourceInputs["extensionArguments"] = state ? state.extensionArguments : undefined;
            resourceInputs["extensionClass"] = state ? state.extensionClass : undefined;
            resourceInputs["httpProxyExternalServer"] = state ? state.httpProxyExternalServer : undefined;
            resourceInputs["iterationCount"] = state ? state.iterationCount : undefined;
            resourceInputs["keyStorePin"] = state ? state.keyStorePin : undefined;
            resourceInputs["keyStorePinEnvironmentVariable"] = state ? state.keyStorePinEnvironmentVariable : undefined;
            resourceInputs["keyStorePinFile"] = state ? state.keyStorePinFile : undefined;
            resourceInputs["keyVaultUri"] = state ? state.keyVaultUri : undefined;
            resourceInputs["keyWrappingTransformation"] = state ? state.keyWrappingTransformation : undefined;
            resourceInputs["kmsEncryptionKeyArn"] = state ? state.kmsEncryptionKeyArn : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["notifications"] = state ? state.notifications : undefined;
            resourceInputs["passwordFile"] = state ? state.passwordFile : undefined;
            resourceInputs["pkcs11KeyStoreType"] = state ? state.pkcs11KeyStoreType : undefined;
            resourceInputs["pkcs11ProviderClass"] = state ? state.pkcs11ProviderClass : undefined;
            resourceInputs["pkcs11ProviderConfigurationFile"] = state ? state.pkcs11ProviderConfigurationFile : undefined;
            resourceInputs["requiredActions"] = state ? state.requiredActions : undefined;
            resourceInputs["secretFieldName"] = state ? state.secretFieldName : undefined;
            resourceInputs["secretId"] = state ? state.secretId : undefined;
            resourceInputs["secretName"] = state ? state.secretName : undefined;
            resourceInputs["secretVersionId"] = state ? state.secretVersionId : undefined;
            resourceInputs["secretVersionStage"] = state ? state.secretVersionStage : undefined;
            resourceInputs["sslCertNickname"] = state ? state.sslCertNickname : undefined;
            resourceInputs["trustStoreFile"] = state ? state.trustStoreFile : undefined;
            resourceInputs["trustStorePin"] = state ? state.trustStorePin : undefined;
            resourceInputs["trustStoreType"] = state ? state.trustStoreType : undefined;
            resourceInputs["type"] = state ? state.type : undefined;
            resourceInputs["vaultAuthenticationMethod"] = state ? state.vaultAuthenticationMethod : undefined;
            resourceInputs["vaultEncryptionMetadataFile"] = state ? state.vaultEncryptionMetadataFile : undefined;
            resourceInputs["vaultExternalServer"] = state ? state.vaultExternalServer : undefined;
            resourceInputs["vaultSecretFieldName"] = state ? state.vaultSecretFieldName : undefined;
            resourceInputs["vaultSecretPath"] = state ? state.vaultSecretPath : undefined;
            resourceInputs["vaultServerBaseUris"] = state ? state.vaultServerBaseUris : undefined;
            resourceInputs["waitForPasswordFile"] = state ? state.waitForPasswordFile : undefined;
        } else {
            const args = argsOrState as CipherStreamProviderArgs | undefined;
            if ((!args || args.enabled === undefined) && !opts.urn) {
                throw new Error("Missing required property 'enabled'");
            }
            if ((!args || args.type === undefined) && !opts.urn) {
                throw new Error("Missing required property 'type'");
            }
            resourceInputs["awsAccessKeyId"] = args ? args.awsAccessKeyId : undefined;
            resourceInputs["awsExternalServer"] = args ? args.awsExternalServer : undefined;
            resourceInputs["awsRegionName"] = args ? args.awsRegionName : undefined;
            resourceInputs["awsSecretAccessKey"] = args?.awsSecretAccessKey ? pulumi.secret(args.awsSecretAccessKey) : undefined;
            resourceInputs["azureAuthenticationMethod"] = args ? args.azureAuthenticationMethod : undefined;
            resourceInputs["conjurExternalServer"] = args ? args.conjurExternalServer : undefined;
            resourceInputs["conjurSecretRelativePath"] = args ? args.conjurSecretRelativePath : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["enabled"] = args ? args.enabled : undefined;
            resourceInputs["encryptedPassphraseFile"] = args ? args.encryptedPassphraseFile : undefined;
            resourceInputs["encryptionMetadataFile"] = args ? args.encryptionMetadataFile : undefined;
            resourceInputs["extensionArguments"] = args ? args.extensionArguments : undefined;
            resourceInputs["extensionClass"] = args ? args.extensionClass : undefined;
            resourceInputs["httpProxyExternalServer"] = args ? args.httpProxyExternalServer : undefined;
            resourceInputs["iterationCount"] = args ? args.iterationCount : undefined;
            resourceInputs["keyStorePin"] = args?.keyStorePin ? pulumi.secret(args.keyStorePin) : undefined;
            resourceInputs["keyStorePinEnvironmentVariable"] = args ? args.keyStorePinEnvironmentVariable : undefined;
            resourceInputs["keyStorePinFile"] = args ? args.keyStorePinFile : undefined;
            resourceInputs["keyVaultUri"] = args ? args.keyVaultUri : undefined;
            resourceInputs["keyWrappingTransformation"] = args ? args.keyWrappingTransformation : undefined;
            resourceInputs["kmsEncryptionKeyArn"] = args ? args.kmsEncryptionKeyArn : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["passwordFile"] = args ? args.passwordFile : undefined;
            resourceInputs["pkcs11KeyStoreType"] = args ? args.pkcs11KeyStoreType : undefined;
            resourceInputs["pkcs11ProviderClass"] = args ? args.pkcs11ProviderClass : undefined;
            resourceInputs["pkcs11ProviderConfigurationFile"] = args ? args.pkcs11ProviderConfigurationFile : undefined;
            resourceInputs["secretFieldName"] = args ? args.secretFieldName : undefined;
            resourceInputs["secretId"] = args ? args.secretId : undefined;
            resourceInputs["secretName"] = args ? args.secretName : undefined;
            resourceInputs["secretVersionId"] = args ? args.secretVersionId : undefined;
            resourceInputs["secretVersionStage"] = args ? args.secretVersionStage : undefined;
            resourceInputs["sslCertNickname"] = args ? args.sslCertNickname : undefined;
            resourceInputs["trustStoreFile"] = args ? args.trustStoreFile : undefined;
            resourceInputs["trustStorePin"] = args?.trustStorePin ? pulumi.secret(args.trustStorePin) : undefined;
            resourceInputs["trustStoreType"] = args ? args.trustStoreType : undefined;
            resourceInputs["type"] = args ? args.type : undefined;
            resourceInputs["vaultAuthenticationMethod"] = args ? args.vaultAuthenticationMethod : undefined;
            resourceInputs["vaultEncryptionMetadataFile"] = args ? args.vaultEncryptionMetadataFile : undefined;
            resourceInputs["vaultExternalServer"] = args ? args.vaultExternalServer : undefined;
            resourceInputs["vaultSecretFieldName"] = args ? args.vaultSecretFieldName : undefined;
            resourceInputs["vaultSecretPath"] = args ? args.vaultSecretPath : undefined;
            resourceInputs["vaultServerBaseUris"] = args ? args.vaultServerBaseUris : undefined;
            resourceInputs["waitForPasswordFile"] = args ? args.waitForPasswordFile : undefined;
            resourceInputs["notifications"] = undefined /*out*/;
            resourceInputs["requiredActions"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["awsSecretAccessKey", "keyStorePin", "trustStorePin"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(CipherStreamProvider.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering CipherStreamProvider resources.
 */
export interface CipherStreamProviderState {
    /**
     * The access key ID that will be used if this cipher stream provider will authenticate to the Amazon Key Management
     * Service using an access key rather than an IAM role associated with an EC2 instance.
     */
    awsAccessKeyId?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `amazon-key-management-service`: The external server with information to use when
     * interacting with the Amazon Key Management Service. - `amazon-secrets-manager`: The external server with information to
     * use when interacting with the AWS Secrets Manager.
     */
    awsExternalServer?: pulumi.Input<string>;
    /**
     * The name of the Amazon Web Services region that holds the encryption key. This is optional, and if it is not provided,
     * then the server will attempt to determine the region from the key ARN.
     */
    awsRegionName?: pulumi.Input<string>;
    /**
     * The secret access key that will be used if this cipher stream provider will authenticate to the Amazon Key Management
     * Service using an access key rather than an IAM role associated with an EC2 instance.
     */
    awsSecretAccessKey?: pulumi.Input<string>;
    /**
     * The mechanism used to authenticate to the Azure service.
     */
    azureAuthenticationMethod?: pulumi.Input<string>;
    /**
     * An external server definition with information needed to connect and authenticate to the Conjur server.
     */
    conjurExternalServer?: pulumi.Input<string>;
    /**
     * The portion of the path that follows the account name in the URI needed to obtain the secret passphrase to use to
     * generate the encryption key. Any special characters in the path must be URL-encoded.
     */
    conjurSecretRelativePath?: pulumi.Input<string>;
    /**
     * A description for this Cipher Stream Provider
     */
    description?: pulumi.Input<string>;
    /**
     * Indicates whether this Cipher Stream Provider is enabled for use in the Directory Server.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * The path to a file that will hold the encrypted passphrase used by this cipher stream provider.
     */
    encryptedPassphraseFile?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `amazon-secrets-manager`: The path to a file that will hold metadata about the
     * encryption performed by this Amazon Secrets Manager Cipher Stream Provider. - `azure-key-vault`: The path to a file that
     * will hold metadata about the encryption performed by this Azure Key Vault Cipher Stream Provider. - `file-based`: The
     * path to a file that will hold metadata about the encryption performed by this File Based Cipher Stream Provider. -
     * `conjur`: The path to a file that will hold metadata about the encryption performed by this Conjur Cipher Stream
     * Provider. - `pkcs11`: The path to a file that will hold metadata about the encryption performed by this PKCS11 Cipher
     * Stream Provider.
     */
    encryptionMetadataFile?: pulumi.Input<string>;
    /**
     * The set of arguments used to customize the behavior for the Third Party Cipher Stream Provider. Each configuration
     * property should be given in the form 'name=value'.
     */
    extensionArguments?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The fully-qualified name of the Java class providing the logic for the Third Party Cipher Stream Provider.
     */
    extensionClass?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 9.2.0.0+. A reference to an HTTP proxy server that should be used for
     * requests sent to the Azure service.
     */
    httpProxyExternalServer?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 9.3.0.0+. The PBKDF2 iteration count that will be used when deriving the
     * encryption key used to protect the encryption settings database.
     */
    iterationCount?: pulumi.Input<number>;
    /**
     * The clear-text user PIN needed to interact with the PKCS #11 token.
     */
    keyStorePin?: pulumi.Input<string>;
    /**
     * The name of an environment variable whose value is the user PIN needed to interact with the PKCS #11 token. The
     * environment variable must be defined and must contain a clear-text representation of the PIN.
     */
    keyStorePinEnvironmentVariable?: pulumi.Input<string>;
    /**
     * The path to a file containing the user PIN needed to interact with the PKCS #11 token. The file must exist and must
     * contain exactly one line with a clear-text representation of the PIN.
     */
    keyStorePinFile?: pulumi.Input<string>;
    /**
     * The URI that identifies the Azure Key Vault from which the secret is to be retrieved.
     */
    keyVaultUri?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 10.1.0.0+. The cipher transformation that will be used to wrap and unwrap the
     * encryption key. If no key wrapping transformation is defined, then the server will select a transformation based on the
     * type of certificate being used.
     */
    keyWrappingTransformation?: pulumi.Input<string>;
    /**
     * The Amazon resource name (ARN) for the KMS key that will be used to encrypt the contents of the passphrase file. This
     * key must exist, and the AWS client must have access to encrypt and decrypt data using this key.
     */
    kmsEncryptionKeyArn?: pulumi.Input<string>;
    /**
     * Name of this config object.
     */
    name?: pulumi.Input<string>;
    /**
     * Notifications returned by the PingDirectory Configuration API.
     */
    notifications?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The path to the file containing the password to use when generating ciphers.
     */
    passwordFile?: pulumi.Input<string>;
    /**
     * The key store type to use when obtaining an instance of a key store for interacting with a PKCS #11 token.
     */
    pkcs11KeyStoreType?: pulumi.Input<string>;
    /**
     * The fully-qualified name of the Java security provider class that implements support for interacting with PKCS #11
     * tokens.
     */
    pkcs11ProviderClass?: pulumi.Input<string>;
    /**
     * The path to the file to use to configure the security provider that implements support for interacting with PKCS #11
     * tokens.
     */
    pkcs11ProviderConfigurationFile?: pulumi.Input<string>;
    /**
     * Required actions returned by the PingDirectory Configuration API.
     */
    requiredActions?: pulumi.Input<pulumi.Input<inputs.CipherStreamProviderRequiredAction>[]>;
    /**
     * The name of the JSON field whose value is the passphrase that will be used to generate the encryption key for protecting
     * the contents of the encryption settings database.
     */
    secretFieldName?: pulumi.Input<string>;
    /**
     * The Amazon Resource Name (ARN) or the user-friendly name of the secret to be retrieved.
     */
    secretId?: pulumi.Input<string>;
    /**
     * The name of the secret to retrieve.
     */
    secretName?: pulumi.Input<string>;
    /**
     * The unique identifier for the version of the secret to be retrieved.
     */
    secretVersionId?: pulumi.Input<string>;
    /**
     * The staging label for the version of the secret to be retrieved.
     */
    secretVersionStage?: pulumi.Input<string>;
    /**
     * The alias for the certificate in the PKCS #11 token that will be used to wrap the encryption key. The target certificate
     * must exist in the PKCS #11 token, and it must have an RSA key pair because the JVM does not currently provide adequate
     * key wrapping support for elliptic curve key pairs. If you have also configured the server to use a PKCS #11 token for
     * accessing listener certificates, we strongly recommend that you use a different certificate to protect the contents of
     * the encryption settings database than you use for negotiating TLS sessions with clients. It is imperative that the
     * certificate used by this PKCS11 Cipher Stream Provider remain constant for the life of the provider because if the
     * certificate were to be replaced, then the contents of the encryption settings database could become inaccessible. Unlike
     * with listener certificates used for TLS negotiation that need to be replaced on a regular basis, this PKCS11 Cipher
     * Stream Provider does not consider the validity period for the associated certificate, and it will continue to function
     * even after the certificate has expired. If you need to rotate the certificate used to protect the server's encryption
     * settings database, you should first install the desired new certificate in the PKCS #11 token under a different alias.
     * Then, you should create a new instance of this PKCS11 Cipher Stream Provider that is configured to use that certificate,
     * and that also uses a different value for the encryption-metadata-file because the information in that file is tied to
     * the certificate used to generate it. Finally, you will need to update the global configuration so that the
     * encryption-settings-cipher-stream-provider property references the new cipher stream provider rather than this one. The
     * update to the global configuration must be done with the server online so that it can properly re-encrypt the contents
     * of the encryption settings database with the correct key tied to the new certificate.
     */
    sslCertNickname?: pulumi.Input<string>;
    /**
     * The path to a file containing the information needed to trust the certificate presented by the Vault servers.
     */
    trustStoreFile?: pulumi.Input<string>;
    /**
     * The passphrase needed to access the contents of the trust store. This is only required if a trust store file is
     * required, and if that trust store requires a PIN to access its contents.
     */
    trustStorePin?: pulumi.Input<string>;
    /**
     * The store type for the specified trust store file. The value should likely be one of "JKS" or "PKCS12".
     */
    trustStoreType?: pulumi.Input<string>;
    /**
     * The type of Cipher Stream Provider resource. Options are ['amazon-key-management-service', 'amazon-secrets-manager',
     * 'azure-key-vault', 'file-based', 'wait-for-passphrase', 'conjur', 'pkcs11', 'vault', 'third-party']
     */
    type?: pulumi.Input<string>;
    /**
     * The mechanism used to authenticate to the Vault server.
     */
    vaultAuthenticationMethod?: pulumi.Input<string>;
    /**
     * The path to a file that will hold metadata about the encryption performed by this Vault Cipher Stream Provider.
     */
    vaultEncryptionMetadataFile?: pulumi.Input<string>;
    /**
     * An external server definition with information needed to connect and authenticate to the Vault server.
     */
    vaultExternalServer?: pulumi.Input<string>;
    /**
     * The name of the field in the Vault secret record that contains the passphrase to use to generate the encryption key.
     */
    vaultSecretFieldName?: pulumi.Input<string>;
    /**
     * The path to the desired secret in the Vault service. This will be appended to the value of the base-url property for the
     * associated Vault external server.
     */
    vaultSecretPath?: pulumi.Input<string>;
    /**
     * The base URL needed to access the Vault server. The base URL should consist of the protocol ("http" or "https"), the
     * server address (resolvable name or IP address), and the port number. For example, "https://vault.example.com:8200/".
     */
    vaultServerBaseUris?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Indicates whether the server should wait for the password file to become available if it does not exist.
     */
    waitForPasswordFile?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a CipherStreamProvider resource.
 */
export interface CipherStreamProviderArgs {
    /**
     * The access key ID that will be used if this cipher stream provider will authenticate to the Amazon Key Management
     * Service using an access key rather than an IAM role associated with an EC2 instance.
     */
    awsAccessKeyId?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `amazon-key-management-service`: The external server with information to use when
     * interacting with the Amazon Key Management Service. - `amazon-secrets-manager`: The external server with information to
     * use when interacting with the AWS Secrets Manager.
     */
    awsExternalServer?: pulumi.Input<string>;
    /**
     * The name of the Amazon Web Services region that holds the encryption key. This is optional, and if it is not provided,
     * then the server will attempt to determine the region from the key ARN.
     */
    awsRegionName?: pulumi.Input<string>;
    /**
     * The secret access key that will be used if this cipher stream provider will authenticate to the Amazon Key Management
     * Service using an access key rather than an IAM role associated with an EC2 instance.
     */
    awsSecretAccessKey?: pulumi.Input<string>;
    /**
     * The mechanism used to authenticate to the Azure service.
     */
    azureAuthenticationMethod?: pulumi.Input<string>;
    /**
     * An external server definition with information needed to connect and authenticate to the Conjur server.
     */
    conjurExternalServer?: pulumi.Input<string>;
    /**
     * The portion of the path that follows the account name in the URI needed to obtain the secret passphrase to use to
     * generate the encryption key. Any special characters in the path must be URL-encoded.
     */
    conjurSecretRelativePath?: pulumi.Input<string>;
    /**
     * A description for this Cipher Stream Provider
     */
    description?: pulumi.Input<string>;
    /**
     * Indicates whether this Cipher Stream Provider is enabled for use in the Directory Server.
     */
    enabled: pulumi.Input<boolean>;
    /**
     * The path to a file that will hold the encrypted passphrase used by this cipher stream provider.
     */
    encryptedPassphraseFile?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `amazon-secrets-manager`: The path to a file that will hold metadata about the
     * encryption performed by this Amazon Secrets Manager Cipher Stream Provider. - `azure-key-vault`: The path to a file that
     * will hold metadata about the encryption performed by this Azure Key Vault Cipher Stream Provider. - `file-based`: The
     * path to a file that will hold metadata about the encryption performed by this File Based Cipher Stream Provider. -
     * `conjur`: The path to a file that will hold metadata about the encryption performed by this Conjur Cipher Stream
     * Provider. - `pkcs11`: The path to a file that will hold metadata about the encryption performed by this PKCS11 Cipher
     * Stream Provider.
     */
    encryptionMetadataFile?: pulumi.Input<string>;
    /**
     * The set of arguments used to customize the behavior for the Third Party Cipher Stream Provider. Each configuration
     * property should be given in the form 'name=value'.
     */
    extensionArguments?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The fully-qualified name of the Java class providing the logic for the Third Party Cipher Stream Provider.
     */
    extensionClass?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 9.2.0.0+. A reference to an HTTP proxy server that should be used for
     * requests sent to the Azure service.
     */
    httpProxyExternalServer?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 9.3.0.0+. The PBKDF2 iteration count that will be used when deriving the
     * encryption key used to protect the encryption settings database.
     */
    iterationCount?: pulumi.Input<number>;
    /**
     * The clear-text user PIN needed to interact with the PKCS #11 token.
     */
    keyStorePin?: pulumi.Input<string>;
    /**
     * The name of an environment variable whose value is the user PIN needed to interact with the PKCS #11 token. The
     * environment variable must be defined and must contain a clear-text representation of the PIN.
     */
    keyStorePinEnvironmentVariable?: pulumi.Input<string>;
    /**
     * The path to a file containing the user PIN needed to interact with the PKCS #11 token. The file must exist and must
     * contain exactly one line with a clear-text representation of the PIN.
     */
    keyStorePinFile?: pulumi.Input<string>;
    /**
     * The URI that identifies the Azure Key Vault from which the secret is to be retrieved.
     */
    keyVaultUri?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 10.1.0.0+. The cipher transformation that will be used to wrap and unwrap the
     * encryption key. If no key wrapping transformation is defined, then the server will select a transformation based on the
     * type of certificate being used.
     */
    keyWrappingTransformation?: pulumi.Input<string>;
    /**
     * The Amazon resource name (ARN) for the KMS key that will be used to encrypt the contents of the passphrase file. This
     * key must exist, and the AWS client must have access to encrypt and decrypt data using this key.
     */
    kmsEncryptionKeyArn?: pulumi.Input<string>;
    /**
     * Name of this config object.
     */
    name?: pulumi.Input<string>;
    /**
     * The path to the file containing the password to use when generating ciphers.
     */
    passwordFile?: pulumi.Input<string>;
    /**
     * The key store type to use when obtaining an instance of a key store for interacting with a PKCS #11 token.
     */
    pkcs11KeyStoreType?: pulumi.Input<string>;
    /**
     * The fully-qualified name of the Java security provider class that implements support for interacting with PKCS #11
     * tokens.
     */
    pkcs11ProviderClass?: pulumi.Input<string>;
    /**
     * The path to the file to use to configure the security provider that implements support for interacting with PKCS #11
     * tokens.
     */
    pkcs11ProviderConfigurationFile?: pulumi.Input<string>;
    /**
     * The name of the JSON field whose value is the passphrase that will be used to generate the encryption key for protecting
     * the contents of the encryption settings database.
     */
    secretFieldName?: pulumi.Input<string>;
    /**
     * The Amazon Resource Name (ARN) or the user-friendly name of the secret to be retrieved.
     */
    secretId?: pulumi.Input<string>;
    /**
     * The name of the secret to retrieve.
     */
    secretName?: pulumi.Input<string>;
    /**
     * The unique identifier for the version of the secret to be retrieved.
     */
    secretVersionId?: pulumi.Input<string>;
    /**
     * The staging label for the version of the secret to be retrieved.
     */
    secretVersionStage?: pulumi.Input<string>;
    /**
     * The alias for the certificate in the PKCS #11 token that will be used to wrap the encryption key. The target certificate
     * must exist in the PKCS #11 token, and it must have an RSA key pair because the JVM does not currently provide adequate
     * key wrapping support for elliptic curve key pairs. If you have also configured the server to use a PKCS #11 token for
     * accessing listener certificates, we strongly recommend that you use a different certificate to protect the contents of
     * the encryption settings database than you use for negotiating TLS sessions with clients. It is imperative that the
     * certificate used by this PKCS11 Cipher Stream Provider remain constant for the life of the provider because if the
     * certificate were to be replaced, then the contents of the encryption settings database could become inaccessible. Unlike
     * with listener certificates used for TLS negotiation that need to be replaced on a regular basis, this PKCS11 Cipher
     * Stream Provider does not consider the validity period for the associated certificate, and it will continue to function
     * even after the certificate has expired. If you need to rotate the certificate used to protect the server's encryption
     * settings database, you should first install the desired new certificate in the PKCS #11 token under a different alias.
     * Then, you should create a new instance of this PKCS11 Cipher Stream Provider that is configured to use that certificate,
     * and that also uses a different value for the encryption-metadata-file because the information in that file is tied to
     * the certificate used to generate it. Finally, you will need to update the global configuration so that the
     * encryption-settings-cipher-stream-provider property references the new cipher stream provider rather than this one. The
     * update to the global configuration must be done with the server online so that it can properly re-encrypt the contents
     * of the encryption settings database with the correct key tied to the new certificate.
     */
    sslCertNickname?: pulumi.Input<string>;
    /**
     * The path to a file containing the information needed to trust the certificate presented by the Vault servers.
     */
    trustStoreFile?: pulumi.Input<string>;
    /**
     * The passphrase needed to access the contents of the trust store. This is only required if a trust store file is
     * required, and if that trust store requires a PIN to access its contents.
     */
    trustStorePin?: pulumi.Input<string>;
    /**
     * The store type for the specified trust store file. The value should likely be one of "JKS" or "PKCS12".
     */
    trustStoreType?: pulumi.Input<string>;
    /**
     * The type of Cipher Stream Provider resource. Options are ['amazon-key-management-service', 'amazon-secrets-manager',
     * 'azure-key-vault', 'file-based', 'wait-for-passphrase', 'conjur', 'pkcs11', 'vault', 'third-party']
     */
    type: pulumi.Input<string>;
    /**
     * The mechanism used to authenticate to the Vault server.
     */
    vaultAuthenticationMethod?: pulumi.Input<string>;
    /**
     * The path to a file that will hold metadata about the encryption performed by this Vault Cipher Stream Provider.
     */
    vaultEncryptionMetadataFile?: pulumi.Input<string>;
    /**
     * An external server definition with information needed to connect and authenticate to the Vault server.
     */
    vaultExternalServer?: pulumi.Input<string>;
    /**
     * The name of the field in the Vault secret record that contains the passphrase to use to generate the encryption key.
     */
    vaultSecretFieldName?: pulumi.Input<string>;
    /**
     * The path to the desired secret in the Vault service. This will be appended to the value of the base-url property for the
     * associated Vault external server.
     */
    vaultSecretPath?: pulumi.Input<string>;
    /**
     * The base URL needed to access the Vault server. The base URL should consist of the protocol ("http" or "https"), the
     * server address (resolvable name or IP address), and the port number. For example, "https://vault.example.com:8200/".
     */
    vaultServerBaseUris?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Indicates whether the server should wait for the password file to become available if it does not exist.
     */
    waitForPasswordFile?: pulumi.Input<boolean>;
}
