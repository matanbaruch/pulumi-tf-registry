// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export function getRecurringTask(args: GetRecurringTaskArgs, opts?: pulumi.InvokeOptions): Promise<GetRecurringTaskResult> {

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("pingdirectory:index/getRecurringTask:getRecurringTask", {
        "name": args.name,
    }, opts, utilities.getPackage());
}

/**
 * A collection of arguments for invoking getRecurringTask.
 */
export interface GetRecurringTaskArgs {
    name: string;
}

/**
 * A collection of values returned by getRecurringTask.
 */
export interface GetRecurringTaskResult {
    readonly alertOnFailure: boolean;
    readonly alertOnStart: boolean;
    readonly alertOnSuccess: boolean;
    readonly backendIds: string[];
    readonly backends: string[];
    readonly backupDirectory: string;
    readonly baseOutputDirectory: string;
    readonly cancelOnTaskDependencyFailure: boolean;
    readonly commandArguments: string;
    readonly commandOutputFileBaseName: string;
    readonly commandPath: string;
    readonly comment: string;
    readonly compress: boolean;
    readonly dataSecurityAuditors: string[];
    readonly description: string;
    readonly durationToWaitForSearchToReturnEntries: string;
    readonly durationToWaitForWorkQueueIdle: string;
    readonly emailOnFailures: string[];
    readonly emailOnStarts: string[];
    readonly emailOnSuccesses: string[];
    readonly encrypt: boolean;
    readonly encryptionPassphraseFile: string;
    readonly encryptionSettingsDefinitionId: string;
    readonly excludeBackendIds: string[];
    readonly excludedBackendIds: string[];
    readonly extensionArguments: string[];
    readonly extensionClass: string;
    readonly filenamePattern: string;
    readonly id: string;
    readonly includeBinaryFiles: boolean;
    readonly includeExpensiveData: boolean;
    readonly includeExtensionSource: boolean;
    readonly includeFilters: string[];
    readonly includePaths: string[];
    readonly includeReplicationStateDump: boolean;
    readonly includedBackendIds: string[];
    readonly jstackCount: number;
    readonly ldapUrlForSearchExpectedToReturnEntries: string[];
    readonly ldifDirectory: string;
    readonly logCommandOutput: boolean;
    readonly logDuration: string;
    readonly logFileHeadCollectionSize: string;
    readonly logFileTailCollectionSize: string;
    readonly maxMegabytesPerSecond: number;
    readonly name: string;
    readonly outputDirectory: string;
    readonly postLdifExportTaskProcessors: string[];
    readonly profileDirectory: string;
    readonly reason: string;
    readonly reportCount: number;
    readonly reportIntervalSeconds: number;
    readonly retainAggregateFileSize: string;
    readonly retainFileAge: string;
    readonly retainFileCount: number;
    readonly retainPreviousFullBackupAge: string;
    readonly retainPreviousFullBackupCount: number;
    readonly retainPreviousLdifExportAge: string;
    readonly retainPreviousLdifExportCount: number;
    readonly retainPreviousOutputFileAge: string;
    readonly retainPreviousOutputFileCount: number;
    readonly retainPreviousProfileAge: string;
    readonly retainPreviousProfileCount: number;
    readonly retainPreviousReportAge: string;
    readonly retainPreviousReportCount: number;
    readonly retainPreviousSupportDataArchiveAge: string;
    readonly retainPreviousSupportDataArchiveCount: number;
    readonly searchInterval: string;
    readonly searchTimeLimit: string;
    readonly securityLevel: string;
    readonly sign: boolean;
    readonly sleepDuration: string;
    readonly targetDirectory: string;
    readonly taskAttributeValues: string[];
    readonly taskCompletionStateForNonzeroExitCode: string;
    readonly taskJavaClass: string;
    readonly taskObjectClasses: string[];
    readonly taskReturnStateIfTimeoutIsEncountered: string;
    readonly timestampFormat: string;
    readonly type: string;
    readonly useSequentialMode: boolean;
    readonly workingDirectory: string;
}
export function getRecurringTaskOutput(args: GetRecurringTaskOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetRecurringTaskResult> {
    return pulumi.output(args).apply((a: any) => getRecurringTask(a, opts))
}

/**
 * A collection of arguments for invoking getRecurringTask.
 */
export interface GetRecurringTaskOutputArgs {
    name: pulumi.Input<string>;
}
