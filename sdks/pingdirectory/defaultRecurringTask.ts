// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class DefaultRecurringTask extends pulumi.CustomResource {
    /**
     * Get an existing DefaultRecurringTask resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DefaultRecurringTaskState, opts?: pulumi.CustomResourceOptions): DefaultRecurringTask {
        return new DefaultRecurringTask(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'pingdirectory:index/defaultRecurringTask:DefaultRecurringTask';

    /**
     * Returns true if the given object is an instance of DefaultRecurringTask.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DefaultRecurringTask {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DefaultRecurringTask.__pulumiType;
    }

    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task fails
     * to complete successfully.
     */
    public readonly alertOnFailure!: pulumi.Output<boolean>;
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task starts
     * running.
     */
    public readonly alertOnStart!: pulumi.Output<boolean>;
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task
     * completes successfully.
     */
    public readonly alertOnSuccess!: pulumi.Output<boolean>;
    /**
     * The backend ID for a backend to be exported.
     */
    public readonly backendIds!: pulumi.Output<string[]>;
    /**
     * The set of backends that should be examined. If no backends are specified, then all backends that support this
     * functionality will be included.
     */
    public readonly backends!: pulumi.Output<string[]>;
    /**
     * The directory in which backup files will be placed. When backing up a single backend, the backup files will be placed
     * directly in this directory. When backing up multiple backends, the backup files for each backend will be placed in a
     * subdirectory whose name is the corresponding backend ID.
     */
    public readonly backupDirectory!: pulumi.Output<string>;
    /**
     * The base directory below which generated reports will be written. Each invocation of the audit-data-security task will
     * create a new subdirectory below this base directory whose name is a timestamp indicating when the report was generated.
     */
    public readonly baseOutputDirectory!: pulumi.Output<string>;
    /**
     * Indicates whether an instance of this Recurring Task should be canceled if the task immediately before it in the
     * recurring task chain fails to complete successfully (including if it is canceled by an administrator before it starts or
     * while it is running).
     */
    public readonly cancelOnTaskDependencyFailure!: pulumi.Output<boolean>;
    /**
     * A string containing the arguments to provide to the command. If the command should be run without arguments, this
     * property should be left undefined. If there should be multiple arguments, then they should be separated with spaces.
     */
    public readonly commandArguments!: pulumi.Output<string>;
    /**
     * The path and base name for a file to which the command output (both standard output and standard error) should be
     * written. This may be left undefined if the command output should not be recorded into a file.
     */
    public readonly commandOutputFileBaseName!: pulumi.Output<string>;
    /**
     * The absolute path to the command to execute. It must be an absolute path, the corresponding file must exist, and it must
     * be listed in the config/exec-command-whitelist.txt file.
     */
    public readonly commandPath!: pulumi.Output<string>;
    /**
     * An optional comment to include in a README file within the support data archive.
     */
    public readonly comment!: pulumi.Output<string>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to compress the data as it is written into the
     * backup. - `ldif-export`: Indicates whether to compress the LDIF data as it is exported.
     */
    public readonly compress!: pulumi.Output<boolean>;
    /**
     * The set of data security auditors that should be invoked. If no auditors are specified, then all auditors defined in the
     * configuration will be used.
     */
    public readonly dataSecurityAuditors!: pulumi.Output<string[]>;
    /**
     * A description for this Recurring Task
     */
    public readonly description!: pulumi.Output<string>;
    /**
     * The maximum length of time that the server will continue to perform internal searches using the criteria from the
     * ldap-url-for-search-expected-to-return-entries property.
     */
    public readonly durationToWaitForSearchToReturnEntries!: pulumi.Output<string>;
    /**
     * Indicates that task should wait for up to the specified length of time for the work queue to report that all worker
     * threads are idle and there are no pending operations. Note that this primarily monitors operations that use worker
     * threads, which does not include internal operations (for example, those invoked by extensions), and may not include
     * requests from non-LDAP clients (for example, HTTP-based clients).
     */
    public readonly durationToWaitForWorkQueueIdle!: pulumi.Output<string>;
    /**
     * The email addresses to which a message should be sent if an instance of this Recurring Task fails to complete
     * successfully. If this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    public readonly emailOnFailures!: pulumi.Output<string[]>;
    /**
     * The email addresses to which a message should be sent whenever an instance of this Recurring Task starts running. If
     * this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    public readonly emailOnStarts!: pulumi.Output<string[]>;
    /**
     * The email addresses to which a message should be sent whenever an instance of this Recurring Task completes
     * successfully. If this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    public readonly emailOnSuccesses!: pulumi.Output<string[]>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to encrypt the data as it is written into the backup.
     * - `ldif-export`: Indicates whether to encrypt the LDIF data as it exported.
     */
    public readonly encrypt!: pulumi.Output<boolean>;
    /**
     * The path to a file that contains the passphrase to encrypt the contents of the support data archive.
     */
    public readonly encryptionPassphraseFile!: pulumi.Output<string>;
    /**
     * When the `type` attribute is set to: - `backup`: The ID of an encryption settings definition to use to obtain the backup
     * encryption key. - `ldif-export`: The ID of an encryption settings definition to use to obtain the LDIF export encryption
     * key.
     */
    public readonly encryptionSettingsDefinitionId!: pulumi.Output<string>;
    /**
     * The backend ID for a backend to be excluded from the export.
     */
    public readonly excludeBackendIds!: pulumi.Output<string[]>;
    /**
     * The backend IDs of any backends that should be excluded from the backup. All backends that support backups and are not
     * listed will be included.
     */
    public readonly excludedBackendIds!: pulumi.Output<string[]>;
    /**
     * The set of arguments used to customize the behavior for the Third Party Recurring Task. Each configuration property
     * should be given in the form 'name=value'.
     */
    public readonly extensionArguments!: pulumi.Output<string[]>;
    /**
     * The fully-qualified name of the Java class providing the logic for the Third Party Recurring Task.
     */
    public readonly extensionClass!: pulumi.Output<string>;
    /**
     * A pattern that specifies the names of the files to examine. The pattern may contain zero or more asterisks as wildcards,
     * where each wildcard matches zero or more characters. It may also contain at most one occurrence of the special string
     * "${timestamp}", which will match a timestamp with the format specified using the timestamp-format property. All other
     * characters in the pattern will be treated literally.
     */
    public readonly filenamePattern!: pulumi.Output<string>;
    /**
     * Indicates whether the support data archive should include binary files that may not have otherwise been included. Note
     * that it may not be possible to obscure or redact sensitive information in binary files.
     */
    public readonly includeBinaryFiles!: pulumi.Output<boolean>;
    /**
     * Indicates whether the support data archive should include information that may be expensive to obtain, and that may
     * temporarily affect the server's performance or responsiveness.
     */
    public readonly includeExpensiveData!: pulumi.Output<boolean>;
    /**
     * Indicates whether the support data archive should include the source code (if available) for any third-party extensions
     * that may be installed in the server.
     */
    public readonly includeExtensionSource!: pulumi.Output<boolean>;
    /**
     * A filter that will be used to identify entries that may be included in the generated report. If multiple filters are
     * specified, then any entry that matches at least one of the filters will be included. If no filters are specified, then
     * all entries will be included.
     */
    public readonly includeFilters!: pulumi.Output<string[]>;
    /**
     * An optional set of additional paths to files within the instance root that should be included in the generated server
     * profile. All paths must be within the instance root, and relative paths will be relative to the instance root.
     */
    public readonly includePaths!: pulumi.Output<string[]>;
    /**
     * Indicates whether the support data archive should include a replication state dump, which may be several megabytes in
     * size.
     */
    public readonly includeReplicationStateDump!: pulumi.Output<boolean>;
    /**
     * The backend IDs of any backends that should be included in the backup.
     */
    public readonly includedBackendIds!: pulumi.Output<string[]>;
    /**
     * The number of times to invoke the jstack utility to obtain a stack trace of all threads running in the JVM. A value of
     * zero indicates that the jstack utility should not be invoked.
     */
    public readonly jstackCount!: pulumi.Output<number>;
    /**
     * An LDAP URL that provides the criteria for a search request that is expected to return at least one entry. The search
     * will be performed internally, and only the base DN, scope, and filter from the URL will be used; any host, port, or
     * requested attributes included in the URL will be ignored.
     */
    public readonly ldapUrlForSearchExpectedToReturnEntries!: pulumi.Output<string[]>;
    /**
     * The directory in which LDIF export files will be placed. The directory must already exist.
     */
    public readonly ldifDirectory!: pulumi.Output<string>;
    /**
     * Indicates whether the command's output (both standard output and standard error) should be recorded in the server's
     * error log.
     */
    public readonly logCommandOutput!: pulumi.Output<boolean>;
    /**
     * The maximum age (leading up to the time the collect-support-data tool was invoked) for log content to include in the
     * support data archive.
     */
    public readonly logDuration!: pulumi.Output<string>;
    /**
     * The amount of data to collect from the beginning of each log file included in the support data archive.
     */
    public readonly logFileHeadCollectionSize!: pulumi.Output<string>;
    /**
     * The amount of data to collect from the end of each log file included in the support data archive.
     */
    public readonly logFileTailCollectionSize!: pulumi.Output<string>;
    /**
     * When the `type` attribute is set to: - `backup`: The maximum rate, in megabytes per second, at which backups should be
     * written. - `ldif-export`: The maximum rate, in megabytes per second, at which LDIF exports should be written.
     */
    public readonly maxMegabytesPerSecond!: pulumi.Output<number>;
    /**
     * Name of this config object.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Notifications returned by the PingDirectory Configuration API.
     */
    public /*out*/ readonly notifications!: pulumi.Output<string[]>;
    /**
     * The directory in which the support data archive files will be placed. The path must be a directory, and that directory
     * must already exist. Relative paths will be interpreted as relative to the server root.
     */
    public readonly outputDirectory!: pulumi.Output<string>;
    /**
     * Supported in PingDirectory product version 10.0.0.0+. An optional set of post-LDIF-export task processors that should be
     * invoked for the resulting LDIF export files.
     */
    public readonly postLdifExportTaskProcessors!: pulumi.Output<string[]>;
    /**
     * The directory in which the generated server profiles will be placed. The files will be named with the pattern
     * "server-profile-{timestamp}.zip", where "{timestamp}" represents the time that the profile was generated.
     */
    public readonly profileDirectory!: pulumi.Output<string>;
    /**
     * When the `type` attribute is set to: - `leave-lockdown-mode`: The reason that the server is being taken out of in
     * lockdown mode. - `enter-lockdown-mode`: The reason that the server is being placed in lockdown mode.
     */
    public readonly reason!: pulumi.Output<string>;
    /**
     * The number of intervals of data to collect from tools that use sample-based reporting, like vmstat, iostat, and mpstat.
     * A value of zero indicates that these kinds of tools should not be used to collect any information.
     */
    public readonly reportCount!: pulumi.Output<number>;
    /**
     * The duration (in seconds) between each interval of data to collect from tools that use sample-based reporting, like
     * vmstat, iostat, and mpstat.
     */
    public readonly reportIntervalSeconds!: pulumi.Output<number>;
    /**
     * Required actions returned by the PingDirectory Configuration API.
     */
    public /*out*/ readonly requiredActions!: pulumi.Output<outputs.DefaultRecurringTaskRequiredAction[]>;
    /**
     * The minimum aggregate size of files that will be retained. The size should be specified as an integer followed by a unit
     * that is one of "b" or "bytes", "kb" or "kilobytes", "mb" or "megabytes", "gb" or "gigabytes", or "tb" or "terabytes".
     * For example, a value of "1 gb" indicates that at least one gigabyte of files should be retained.
     */
    public readonly retainAggregateFileSize!: pulumi.Output<string>;
    /**
     * The minimum age of files matching the pattern that will be retained.
     */
    public readonly retainFileAge!: pulumi.Output<string>;
    /**
     * The minimum number of files matching the pattern that will be retained.
     */
    public readonly retainFileCount!: pulumi.Output<number>;
    /**
     * The minimum age of previous full backups that should be preserved after a new backup completes successfully.
     */
    public readonly retainPreviousFullBackupAge!: pulumi.Output<string>;
    /**
     * The minimum number of previous full backups that should be preserved after a new backup completes successfully.
     */
    public readonly retainPreviousFullBackupCount!: pulumi.Output<number>;
    /**
     * The minimum age of previous LDIF exports that should be preserved after a new export completes successfully.
     */
    public readonly retainPreviousLdifExportAge!: pulumi.Output<string>;
    /**
     * The minimum number of previous LDIF exports that should be preserved after a new export completes successfully.
     */
    public readonly retainPreviousLdifExportCount!: pulumi.Output<number>;
    /**
     * The minimum age of previous command output files that should be preserved after a new instance of the command is
     * invoked.
     */
    public readonly retainPreviousOutputFileAge!: pulumi.Output<string>;
    /**
     * The minimum number of previous command output files that should be preserved after a new instance of the command is
     * invoked.
     */
    public readonly retainPreviousOutputFileCount!: pulumi.Output<number>;
    /**
     * The minimum age of previous server profile zip files that should be preserved after a new profile is generated.
     */
    public readonly retainPreviousProfileAge!: pulumi.Output<string>;
    /**
     * The minimum number of previous server profile zip files that should be preserved after a new profile is generated.
     */
    public readonly retainPreviousProfileCount!: pulumi.Output<number>;
    /**
     * The minimum age of previous reports that should be preserved after a new report completes successfully.
     */
    public readonly retainPreviousReportAge!: pulumi.Output<string>;
    /**
     * The minimum number of previous reports that should be preserved after a new report is generated.
     */
    public readonly retainPreviousReportCount!: pulumi.Output<number>;
    /**
     * The minimum age of previous support data archives that should be preserved after a new archive is generated.
     */
    public readonly retainPreviousSupportDataArchiveAge!: pulumi.Output<string>;
    /**
     * The minimum number of previous support data archives that should be preserved after a new archive is generated.
     */
    public readonly retainPreviousSupportDataArchiveCount!: pulumi.Output<number>;
    /**
     * The length of time the server should sleep between searches performed using the criteria from the
     * ldap-url-for-search-expected-to-return-entries property.
     */
    public readonly searchInterval!: pulumi.Output<string>;
    /**
     * The length of time that the server will wait for a response to each internal search performed using the criteria from
     * the ldap-url-for-search-expected-to-return-entries property.
     */
    public readonly searchTimeLimit!: pulumi.Output<string>;
    /**
     * The security level to use when deciding which information to include in or exclude from the support data archive, and
     * which included data should be obscured or redacted.
     */
    public readonly securityLevel!: pulumi.Output<string>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to cryptographically sign backups, which will make it
     * possible to detect whether the backup has been altered since it was created. - `ldif-export`: Indicates whether to
     * cryptographically sign the exported data, which will make it possible to detect whether the LDIF data has been altered
     * since it was exported.
     */
    public readonly sign!: pulumi.Output<boolean>;
    /**
     * The length of time to sleep before the task completes.
     */
    public readonly sleepDuration!: pulumi.Output<string>;
    /**
     * The path to the directory containing the files to examine. The directory must exist.
     */
    public readonly targetDirectory!: pulumi.Output<string>;
    /**
     * The set of attribute values that should be included in the tasks that are scheduled from this Statically Defined
     * Recurring Task. Each value must be in the form {attribute-type}={value}, where {attribute-type} is the name or OID of an
     * attribute type that is defined in the schema and permitted with the configured set of object classes, and {value} is a
     * value to assign to an attribute with that type. A multivalued attribute can be created by providing multiple name-value
     * pairs with the same name and different values.
     */
    public readonly taskAttributeValues!: pulumi.Output<string[]>;
    /**
     * The final task state that a task instance should have if the task executes the specified command and that command
     * completes with a nonzero exit code, which generally means that the command did not complete successfully.
     */
    public readonly taskCompletionStateForNonzeroExitCode!: pulumi.Output<string>;
    /**
     * The fully-qualified name of the Java class that provides the logic for the task to be invoked.
     */
    public readonly taskJavaClass!: pulumi.Output<string>;
    /**
     * The names or OIDs of the object classes to include in the tasks that are scheduled from this Statically Defined
     * Recurring Task. All object classes must be defined in the server schema, and the combination of object classes must be
     * valid for a task entry.
     */
    public readonly taskObjectClasses!: pulumi.Output<string[]>;
    /**
     * The return state to use if a timeout is encountered while waiting for the server work queue to become idle (if the
     * duration-to-wait-for-work-queue-idle property has a value), or if the time specified by the
     * duration-to-wait-for-search-to-return-entries elapses without the associated search returning any entries.
     */
    public readonly taskReturnStateIfTimeoutIsEncountered!: pulumi.Output<string>;
    /**
     * The format to use for the timestamp represented by the "${timestamp}" token in the filename pattern.
     */
    public readonly timestampFormat!: pulumi.Output<string>;
    /**
     * The type of Recurring Task resource. Options are ['generate-server-profile', 'leave-lockdown-mode', 'backup', 'delay',
     * 'statically-defined', 'collect-support-data', 'ldif-export', 'enter-lockdown-mode', 'audit-data-security', 'exec',
     * 'file-retention', 'third-party']
     */
    public /*out*/ readonly type!: pulumi.Output<string>;
    /**
     * Indicates whether to capture support data information sequentially rather than in parallel. Capturing data in sequential
     * mode may reduce the amount of memory that the tool requires to operate, at the cost of taking longer to run.
     */
    public readonly useSequentialMode!: pulumi.Output<boolean>;
    /**
     * The absolute path to a working directory where the command should be executed. It must be an absolute path and the
     * corresponding directory must exist.
     */
    public readonly workingDirectory!: pulumi.Output<string>;

    /**
     * Create a DefaultRecurringTask resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: DefaultRecurringTaskArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DefaultRecurringTaskArgs | DefaultRecurringTaskState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DefaultRecurringTaskState | undefined;
            resourceInputs["alertOnFailure"] = state ? state.alertOnFailure : undefined;
            resourceInputs["alertOnStart"] = state ? state.alertOnStart : undefined;
            resourceInputs["alertOnSuccess"] = state ? state.alertOnSuccess : undefined;
            resourceInputs["backendIds"] = state ? state.backendIds : undefined;
            resourceInputs["backends"] = state ? state.backends : undefined;
            resourceInputs["backupDirectory"] = state ? state.backupDirectory : undefined;
            resourceInputs["baseOutputDirectory"] = state ? state.baseOutputDirectory : undefined;
            resourceInputs["cancelOnTaskDependencyFailure"] = state ? state.cancelOnTaskDependencyFailure : undefined;
            resourceInputs["commandArguments"] = state ? state.commandArguments : undefined;
            resourceInputs["commandOutputFileBaseName"] = state ? state.commandOutputFileBaseName : undefined;
            resourceInputs["commandPath"] = state ? state.commandPath : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["compress"] = state ? state.compress : undefined;
            resourceInputs["dataSecurityAuditors"] = state ? state.dataSecurityAuditors : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["durationToWaitForSearchToReturnEntries"] = state ? state.durationToWaitForSearchToReturnEntries : undefined;
            resourceInputs["durationToWaitForWorkQueueIdle"] = state ? state.durationToWaitForWorkQueueIdle : undefined;
            resourceInputs["emailOnFailures"] = state ? state.emailOnFailures : undefined;
            resourceInputs["emailOnStarts"] = state ? state.emailOnStarts : undefined;
            resourceInputs["emailOnSuccesses"] = state ? state.emailOnSuccesses : undefined;
            resourceInputs["encrypt"] = state ? state.encrypt : undefined;
            resourceInputs["encryptionPassphraseFile"] = state ? state.encryptionPassphraseFile : undefined;
            resourceInputs["encryptionSettingsDefinitionId"] = state ? state.encryptionSettingsDefinitionId : undefined;
            resourceInputs["excludeBackendIds"] = state ? state.excludeBackendIds : undefined;
            resourceInputs["excludedBackendIds"] = state ? state.excludedBackendIds : undefined;
            resourceInputs["extensionArguments"] = state ? state.extensionArguments : undefined;
            resourceInputs["extensionClass"] = state ? state.extensionClass : undefined;
            resourceInputs["filenamePattern"] = state ? state.filenamePattern : undefined;
            resourceInputs["includeBinaryFiles"] = state ? state.includeBinaryFiles : undefined;
            resourceInputs["includeExpensiveData"] = state ? state.includeExpensiveData : undefined;
            resourceInputs["includeExtensionSource"] = state ? state.includeExtensionSource : undefined;
            resourceInputs["includeFilters"] = state ? state.includeFilters : undefined;
            resourceInputs["includePaths"] = state ? state.includePaths : undefined;
            resourceInputs["includeReplicationStateDump"] = state ? state.includeReplicationStateDump : undefined;
            resourceInputs["includedBackendIds"] = state ? state.includedBackendIds : undefined;
            resourceInputs["jstackCount"] = state ? state.jstackCount : undefined;
            resourceInputs["ldapUrlForSearchExpectedToReturnEntries"] = state ? state.ldapUrlForSearchExpectedToReturnEntries : undefined;
            resourceInputs["ldifDirectory"] = state ? state.ldifDirectory : undefined;
            resourceInputs["logCommandOutput"] = state ? state.logCommandOutput : undefined;
            resourceInputs["logDuration"] = state ? state.logDuration : undefined;
            resourceInputs["logFileHeadCollectionSize"] = state ? state.logFileHeadCollectionSize : undefined;
            resourceInputs["logFileTailCollectionSize"] = state ? state.logFileTailCollectionSize : undefined;
            resourceInputs["maxMegabytesPerSecond"] = state ? state.maxMegabytesPerSecond : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["notifications"] = state ? state.notifications : undefined;
            resourceInputs["outputDirectory"] = state ? state.outputDirectory : undefined;
            resourceInputs["postLdifExportTaskProcessors"] = state ? state.postLdifExportTaskProcessors : undefined;
            resourceInputs["profileDirectory"] = state ? state.profileDirectory : undefined;
            resourceInputs["reason"] = state ? state.reason : undefined;
            resourceInputs["reportCount"] = state ? state.reportCount : undefined;
            resourceInputs["reportIntervalSeconds"] = state ? state.reportIntervalSeconds : undefined;
            resourceInputs["requiredActions"] = state ? state.requiredActions : undefined;
            resourceInputs["retainAggregateFileSize"] = state ? state.retainAggregateFileSize : undefined;
            resourceInputs["retainFileAge"] = state ? state.retainFileAge : undefined;
            resourceInputs["retainFileCount"] = state ? state.retainFileCount : undefined;
            resourceInputs["retainPreviousFullBackupAge"] = state ? state.retainPreviousFullBackupAge : undefined;
            resourceInputs["retainPreviousFullBackupCount"] = state ? state.retainPreviousFullBackupCount : undefined;
            resourceInputs["retainPreviousLdifExportAge"] = state ? state.retainPreviousLdifExportAge : undefined;
            resourceInputs["retainPreviousLdifExportCount"] = state ? state.retainPreviousLdifExportCount : undefined;
            resourceInputs["retainPreviousOutputFileAge"] = state ? state.retainPreviousOutputFileAge : undefined;
            resourceInputs["retainPreviousOutputFileCount"] = state ? state.retainPreviousOutputFileCount : undefined;
            resourceInputs["retainPreviousProfileAge"] = state ? state.retainPreviousProfileAge : undefined;
            resourceInputs["retainPreviousProfileCount"] = state ? state.retainPreviousProfileCount : undefined;
            resourceInputs["retainPreviousReportAge"] = state ? state.retainPreviousReportAge : undefined;
            resourceInputs["retainPreviousReportCount"] = state ? state.retainPreviousReportCount : undefined;
            resourceInputs["retainPreviousSupportDataArchiveAge"] = state ? state.retainPreviousSupportDataArchiveAge : undefined;
            resourceInputs["retainPreviousSupportDataArchiveCount"] = state ? state.retainPreviousSupportDataArchiveCount : undefined;
            resourceInputs["searchInterval"] = state ? state.searchInterval : undefined;
            resourceInputs["searchTimeLimit"] = state ? state.searchTimeLimit : undefined;
            resourceInputs["securityLevel"] = state ? state.securityLevel : undefined;
            resourceInputs["sign"] = state ? state.sign : undefined;
            resourceInputs["sleepDuration"] = state ? state.sleepDuration : undefined;
            resourceInputs["targetDirectory"] = state ? state.targetDirectory : undefined;
            resourceInputs["taskAttributeValues"] = state ? state.taskAttributeValues : undefined;
            resourceInputs["taskCompletionStateForNonzeroExitCode"] = state ? state.taskCompletionStateForNonzeroExitCode : undefined;
            resourceInputs["taskJavaClass"] = state ? state.taskJavaClass : undefined;
            resourceInputs["taskObjectClasses"] = state ? state.taskObjectClasses : undefined;
            resourceInputs["taskReturnStateIfTimeoutIsEncountered"] = state ? state.taskReturnStateIfTimeoutIsEncountered : undefined;
            resourceInputs["timestampFormat"] = state ? state.timestampFormat : undefined;
            resourceInputs["type"] = state ? state.type : undefined;
            resourceInputs["useSequentialMode"] = state ? state.useSequentialMode : undefined;
            resourceInputs["workingDirectory"] = state ? state.workingDirectory : undefined;
        } else {
            const args = argsOrState as DefaultRecurringTaskArgs | undefined;
            resourceInputs["alertOnFailure"] = args ? args.alertOnFailure : undefined;
            resourceInputs["alertOnStart"] = args ? args.alertOnStart : undefined;
            resourceInputs["alertOnSuccess"] = args ? args.alertOnSuccess : undefined;
            resourceInputs["backendIds"] = args ? args.backendIds : undefined;
            resourceInputs["backends"] = args ? args.backends : undefined;
            resourceInputs["backupDirectory"] = args ? args.backupDirectory : undefined;
            resourceInputs["baseOutputDirectory"] = args ? args.baseOutputDirectory : undefined;
            resourceInputs["cancelOnTaskDependencyFailure"] = args ? args.cancelOnTaskDependencyFailure : undefined;
            resourceInputs["commandArguments"] = args ? args.commandArguments : undefined;
            resourceInputs["commandOutputFileBaseName"] = args ? args.commandOutputFileBaseName : undefined;
            resourceInputs["commandPath"] = args ? args.commandPath : undefined;
            resourceInputs["comment"] = args ? args.comment : undefined;
            resourceInputs["compress"] = args ? args.compress : undefined;
            resourceInputs["dataSecurityAuditors"] = args ? args.dataSecurityAuditors : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["durationToWaitForSearchToReturnEntries"] = args ? args.durationToWaitForSearchToReturnEntries : undefined;
            resourceInputs["durationToWaitForWorkQueueIdle"] = args ? args.durationToWaitForWorkQueueIdle : undefined;
            resourceInputs["emailOnFailures"] = args ? args.emailOnFailures : undefined;
            resourceInputs["emailOnStarts"] = args ? args.emailOnStarts : undefined;
            resourceInputs["emailOnSuccesses"] = args ? args.emailOnSuccesses : undefined;
            resourceInputs["encrypt"] = args ? args.encrypt : undefined;
            resourceInputs["encryptionPassphraseFile"] = args ? args.encryptionPassphraseFile : undefined;
            resourceInputs["encryptionSettingsDefinitionId"] = args ? args.encryptionSettingsDefinitionId : undefined;
            resourceInputs["excludeBackendIds"] = args ? args.excludeBackendIds : undefined;
            resourceInputs["excludedBackendIds"] = args ? args.excludedBackendIds : undefined;
            resourceInputs["extensionArguments"] = args ? args.extensionArguments : undefined;
            resourceInputs["extensionClass"] = args ? args.extensionClass : undefined;
            resourceInputs["filenamePattern"] = args ? args.filenamePattern : undefined;
            resourceInputs["includeBinaryFiles"] = args ? args.includeBinaryFiles : undefined;
            resourceInputs["includeExpensiveData"] = args ? args.includeExpensiveData : undefined;
            resourceInputs["includeExtensionSource"] = args ? args.includeExtensionSource : undefined;
            resourceInputs["includeFilters"] = args ? args.includeFilters : undefined;
            resourceInputs["includePaths"] = args ? args.includePaths : undefined;
            resourceInputs["includeReplicationStateDump"] = args ? args.includeReplicationStateDump : undefined;
            resourceInputs["includedBackendIds"] = args ? args.includedBackendIds : undefined;
            resourceInputs["jstackCount"] = args ? args.jstackCount : undefined;
            resourceInputs["ldapUrlForSearchExpectedToReturnEntries"] = args ? args.ldapUrlForSearchExpectedToReturnEntries : undefined;
            resourceInputs["ldifDirectory"] = args ? args.ldifDirectory : undefined;
            resourceInputs["logCommandOutput"] = args ? args.logCommandOutput : undefined;
            resourceInputs["logDuration"] = args ? args.logDuration : undefined;
            resourceInputs["logFileHeadCollectionSize"] = args ? args.logFileHeadCollectionSize : undefined;
            resourceInputs["logFileTailCollectionSize"] = args ? args.logFileTailCollectionSize : undefined;
            resourceInputs["maxMegabytesPerSecond"] = args ? args.maxMegabytesPerSecond : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["outputDirectory"] = args ? args.outputDirectory : undefined;
            resourceInputs["postLdifExportTaskProcessors"] = args ? args.postLdifExportTaskProcessors : undefined;
            resourceInputs["profileDirectory"] = args ? args.profileDirectory : undefined;
            resourceInputs["reason"] = args ? args.reason : undefined;
            resourceInputs["reportCount"] = args ? args.reportCount : undefined;
            resourceInputs["reportIntervalSeconds"] = args ? args.reportIntervalSeconds : undefined;
            resourceInputs["retainAggregateFileSize"] = args ? args.retainAggregateFileSize : undefined;
            resourceInputs["retainFileAge"] = args ? args.retainFileAge : undefined;
            resourceInputs["retainFileCount"] = args ? args.retainFileCount : undefined;
            resourceInputs["retainPreviousFullBackupAge"] = args ? args.retainPreviousFullBackupAge : undefined;
            resourceInputs["retainPreviousFullBackupCount"] = args ? args.retainPreviousFullBackupCount : undefined;
            resourceInputs["retainPreviousLdifExportAge"] = args ? args.retainPreviousLdifExportAge : undefined;
            resourceInputs["retainPreviousLdifExportCount"] = args ? args.retainPreviousLdifExportCount : undefined;
            resourceInputs["retainPreviousOutputFileAge"] = args ? args.retainPreviousOutputFileAge : undefined;
            resourceInputs["retainPreviousOutputFileCount"] = args ? args.retainPreviousOutputFileCount : undefined;
            resourceInputs["retainPreviousProfileAge"] = args ? args.retainPreviousProfileAge : undefined;
            resourceInputs["retainPreviousProfileCount"] = args ? args.retainPreviousProfileCount : undefined;
            resourceInputs["retainPreviousReportAge"] = args ? args.retainPreviousReportAge : undefined;
            resourceInputs["retainPreviousReportCount"] = args ? args.retainPreviousReportCount : undefined;
            resourceInputs["retainPreviousSupportDataArchiveAge"] = args ? args.retainPreviousSupportDataArchiveAge : undefined;
            resourceInputs["retainPreviousSupportDataArchiveCount"] = args ? args.retainPreviousSupportDataArchiveCount : undefined;
            resourceInputs["searchInterval"] = args ? args.searchInterval : undefined;
            resourceInputs["searchTimeLimit"] = args ? args.searchTimeLimit : undefined;
            resourceInputs["securityLevel"] = args ? args.securityLevel : undefined;
            resourceInputs["sign"] = args ? args.sign : undefined;
            resourceInputs["sleepDuration"] = args ? args.sleepDuration : undefined;
            resourceInputs["targetDirectory"] = args ? args.targetDirectory : undefined;
            resourceInputs["taskAttributeValues"] = args ? args.taskAttributeValues : undefined;
            resourceInputs["taskCompletionStateForNonzeroExitCode"] = args ? args.taskCompletionStateForNonzeroExitCode : undefined;
            resourceInputs["taskJavaClass"] = args ? args.taskJavaClass : undefined;
            resourceInputs["taskObjectClasses"] = args ? args.taskObjectClasses : undefined;
            resourceInputs["taskReturnStateIfTimeoutIsEncountered"] = args ? args.taskReturnStateIfTimeoutIsEncountered : undefined;
            resourceInputs["timestampFormat"] = args ? args.timestampFormat : undefined;
            resourceInputs["useSequentialMode"] = args ? args.useSequentialMode : undefined;
            resourceInputs["workingDirectory"] = args ? args.workingDirectory : undefined;
            resourceInputs["notifications"] = undefined /*out*/;
            resourceInputs["requiredActions"] = undefined /*out*/;
            resourceInputs["type"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DefaultRecurringTask.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering DefaultRecurringTask resources.
 */
export interface DefaultRecurringTaskState {
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task fails
     * to complete successfully.
     */
    alertOnFailure?: pulumi.Input<boolean>;
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task starts
     * running.
     */
    alertOnStart?: pulumi.Input<boolean>;
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task
     * completes successfully.
     */
    alertOnSuccess?: pulumi.Input<boolean>;
    /**
     * The backend ID for a backend to be exported.
     */
    backendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The set of backends that should be examined. If no backends are specified, then all backends that support this
     * functionality will be included.
     */
    backends?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The directory in which backup files will be placed. When backing up a single backend, the backup files will be placed
     * directly in this directory. When backing up multiple backends, the backup files for each backend will be placed in a
     * subdirectory whose name is the corresponding backend ID.
     */
    backupDirectory?: pulumi.Input<string>;
    /**
     * The base directory below which generated reports will be written. Each invocation of the audit-data-security task will
     * create a new subdirectory below this base directory whose name is a timestamp indicating when the report was generated.
     */
    baseOutputDirectory?: pulumi.Input<string>;
    /**
     * Indicates whether an instance of this Recurring Task should be canceled if the task immediately before it in the
     * recurring task chain fails to complete successfully (including if it is canceled by an administrator before it starts or
     * while it is running).
     */
    cancelOnTaskDependencyFailure?: pulumi.Input<boolean>;
    /**
     * A string containing the arguments to provide to the command. If the command should be run without arguments, this
     * property should be left undefined. If there should be multiple arguments, then they should be separated with spaces.
     */
    commandArguments?: pulumi.Input<string>;
    /**
     * The path and base name for a file to which the command output (both standard output and standard error) should be
     * written. This may be left undefined if the command output should not be recorded into a file.
     */
    commandOutputFileBaseName?: pulumi.Input<string>;
    /**
     * The absolute path to the command to execute. It must be an absolute path, the corresponding file must exist, and it must
     * be listed in the config/exec-command-whitelist.txt file.
     */
    commandPath?: pulumi.Input<string>;
    /**
     * An optional comment to include in a README file within the support data archive.
     */
    comment?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to compress the data as it is written into the
     * backup. - `ldif-export`: Indicates whether to compress the LDIF data as it is exported.
     */
    compress?: pulumi.Input<boolean>;
    /**
     * The set of data security auditors that should be invoked. If no auditors are specified, then all auditors defined in the
     * configuration will be used.
     */
    dataSecurityAuditors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A description for this Recurring Task
     */
    description?: pulumi.Input<string>;
    /**
     * The maximum length of time that the server will continue to perform internal searches using the criteria from the
     * ldap-url-for-search-expected-to-return-entries property.
     */
    durationToWaitForSearchToReturnEntries?: pulumi.Input<string>;
    /**
     * Indicates that task should wait for up to the specified length of time for the work queue to report that all worker
     * threads are idle and there are no pending operations. Note that this primarily monitors operations that use worker
     * threads, which does not include internal operations (for example, those invoked by extensions), and may not include
     * requests from non-LDAP clients (for example, HTTP-based clients).
     */
    durationToWaitForWorkQueueIdle?: pulumi.Input<string>;
    /**
     * The email addresses to which a message should be sent if an instance of this Recurring Task fails to complete
     * successfully. If this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    emailOnFailures?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The email addresses to which a message should be sent whenever an instance of this Recurring Task starts running. If
     * this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    emailOnStarts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The email addresses to which a message should be sent whenever an instance of this Recurring Task completes
     * successfully. If this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    emailOnSuccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to encrypt the data as it is written into the backup.
     * - `ldif-export`: Indicates whether to encrypt the LDIF data as it exported.
     */
    encrypt?: pulumi.Input<boolean>;
    /**
     * The path to a file that contains the passphrase to encrypt the contents of the support data archive.
     */
    encryptionPassphraseFile?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: The ID of an encryption settings definition to use to obtain the backup
     * encryption key. - `ldif-export`: The ID of an encryption settings definition to use to obtain the LDIF export encryption
     * key.
     */
    encryptionSettingsDefinitionId?: pulumi.Input<string>;
    /**
     * The backend ID for a backend to be excluded from the export.
     */
    excludeBackendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The backend IDs of any backends that should be excluded from the backup. All backends that support backups and are not
     * listed will be included.
     */
    excludedBackendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The set of arguments used to customize the behavior for the Third Party Recurring Task. Each configuration property
     * should be given in the form 'name=value'.
     */
    extensionArguments?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The fully-qualified name of the Java class providing the logic for the Third Party Recurring Task.
     */
    extensionClass?: pulumi.Input<string>;
    /**
     * A pattern that specifies the names of the files to examine. The pattern may contain zero or more asterisks as wildcards,
     * where each wildcard matches zero or more characters. It may also contain at most one occurrence of the special string
     * "${timestamp}", which will match a timestamp with the format specified using the timestamp-format property. All other
     * characters in the pattern will be treated literally.
     */
    filenamePattern?: pulumi.Input<string>;
    /**
     * Indicates whether the support data archive should include binary files that may not have otherwise been included. Note
     * that it may not be possible to obscure or redact sensitive information in binary files.
     */
    includeBinaryFiles?: pulumi.Input<boolean>;
    /**
     * Indicates whether the support data archive should include information that may be expensive to obtain, and that may
     * temporarily affect the server's performance or responsiveness.
     */
    includeExpensiveData?: pulumi.Input<boolean>;
    /**
     * Indicates whether the support data archive should include the source code (if available) for any third-party extensions
     * that may be installed in the server.
     */
    includeExtensionSource?: pulumi.Input<boolean>;
    /**
     * A filter that will be used to identify entries that may be included in the generated report. If multiple filters are
     * specified, then any entry that matches at least one of the filters will be included. If no filters are specified, then
     * all entries will be included.
     */
    includeFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An optional set of additional paths to files within the instance root that should be included in the generated server
     * profile. All paths must be within the instance root, and relative paths will be relative to the instance root.
     */
    includePaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Indicates whether the support data archive should include a replication state dump, which may be several megabytes in
     * size.
     */
    includeReplicationStateDump?: pulumi.Input<boolean>;
    /**
     * The backend IDs of any backends that should be included in the backup.
     */
    includedBackendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The number of times to invoke the jstack utility to obtain a stack trace of all threads running in the JVM. A value of
     * zero indicates that the jstack utility should not be invoked.
     */
    jstackCount?: pulumi.Input<number>;
    /**
     * An LDAP URL that provides the criteria for a search request that is expected to return at least one entry. The search
     * will be performed internally, and only the base DN, scope, and filter from the URL will be used; any host, port, or
     * requested attributes included in the URL will be ignored.
     */
    ldapUrlForSearchExpectedToReturnEntries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The directory in which LDIF export files will be placed. The directory must already exist.
     */
    ldifDirectory?: pulumi.Input<string>;
    /**
     * Indicates whether the command's output (both standard output and standard error) should be recorded in the server's
     * error log.
     */
    logCommandOutput?: pulumi.Input<boolean>;
    /**
     * The maximum age (leading up to the time the collect-support-data tool was invoked) for log content to include in the
     * support data archive.
     */
    logDuration?: pulumi.Input<string>;
    /**
     * The amount of data to collect from the beginning of each log file included in the support data archive.
     */
    logFileHeadCollectionSize?: pulumi.Input<string>;
    /**
     * The amount of data to collect from the end of each log file included in the support data archive.
     */
    logFileTailCollectionSize?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: The maximum rate, in megabytes per second, at which backups should be
     * written. - `ldif-export`: The maximum rate, in megabytes per second, at which LDIF exports should be written.
     */
    maxMegabytesPerSecond?: pulumi.Input<number>;
    /**
     * Name of this config object.
     */
    name?: pulumi.Input<string>;
    /**
     * Notifications returned by the PingDirectory Configuration API.
     */
    notifications?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The directory in which the support data archive files will be placed. The path must be a directory, and that directory
     * must already exist. Relative paths will be interpreted as relative to the server root.
     */
    outputDirectory?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 10.0.0.0+. An optional set of post-LDIF-export task processors that should be
     * invoked for the resulting LDIF export files.
     */
    postLdifExportTaskProcessors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The directory in which the generated server profiles will be placed. The files will be named with the pattern
     * "server-profile-{timestamp}.zip", where "{timestamp}" represents the time that the profile was generated.
     */
    profileDirectory?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `leave-lockdown-mode`: The reason that the server is being taken out of in
     * lockdown mode. - `enter-lockdown-mode`: The reason that the server is being placed in lockdown mode.
     */
    reason?: pulumi.Input<string>;
    /**
     * The number of intervals of data to collect from tools that use sample-based reporting, like vmstat, iostat, and mpstat.
     * A value of zero indicates that these kinds of tools should not be used to collect any information.
     */
    reportCount?: pulumi.Input<number>;
    /**
     * The duration (in seconds) between each interval of data to collect from tools that use sample-based reporting, like
     * vmstat, iostat, and mpstat.
     */
    reportIntervalSeconds?: pulumi.Input<number>;
    /**
     * Required actions returned by the PingDirectory Configuration API.
     */
    requiredActions?: pulumi.Input<pulumi.Input<inputs.DefaultRecurringTaskRequiredAction>[]>;
    /**
     * The minimum aggregate size of files that will be retained. The size should be specified as an integer followed by a unit
     * that is one of "b" or "bytes", "kb" or "kilobytes", "mb" or "megabytes", "gb" or "gigabytes", or "tb" or "terabytes".
     * For example, a value of "1 gb" indicates that at least one gigabyte of files should be retained.
     */
    retainAggregateFileSize?: pulumi.Input<string>;
    /**
     * The minimum age of files matching the pattern that will be retained.
     */
    retainFileAge?: pulumi.Input<string>;
    /**
     * The minimum number of files matching the pattern that will be retained.
     */
    retainFileCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous full backups that should be preserved after a new backup completes successfully.
     */
    retainPreviousFullBackupAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous full backups that should be preserved after a new backup completes successfully.
     */
    retainPreviousFullBackupCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous LDIF exports that should be preserved after a new export completes successfully.
     */
    retainPreviousLdifExportAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous LDIF exports that should be preserved after a new export completes successfully.
     */
    retainPreviousLdifExportCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous command output files that should be preserved after a new instance of the command is
     * invoked.
     */
    retainPreviousOutputFileAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous command output files that should be preserved after a new instance of the command is
     * invoked.
     */
    retainPreviousOutputFileCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous server profile zip files that should be preserved after a new profile is generated.
     */
    retainPreviousProfileAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous server profile zip files that should be preserved after a new profile is generated.
     */
    retainPreviousProfileCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous reports that should be preserved after a new report completes successfully.
     */
    retainPreviousReportAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous reports that should be preserved after a new report is generated.
     */
    retainPreviousReportCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous support data archives that should be preserved after a new archive is generated.
     */
    retainPreviousSupportDataArchiveAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous support data archives that should be preserved after a new archive is generated.
     */
    retainPreviousSupportDataArchiveCount?: pulumi.Input<number>;
    /**
     * The length of time the server should sleep between searches performed using the criteria from the
     * ldap-url-for-search-expected-to-return-entries property.
     */
    searchInterval?: pulumi.Input<string>;
    /**
     * The length of time that the server will wait for a response to each internal search performed using the criteria from
     * the ldap-url-for-search-expected-to-return-entries property.
     */
    searchTimeLimit?: pulumi.Input<string>;
    /**
     * The security level to use when deciding which information to include in or exclude from the support data archive, and
     * which included data should be obscured or redacted.
     */
    securityLevel?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to cryptographically sign backups, which will make it
     * possible to detect whether the backup has been altered since it was created. - `ldif-export`: Indicates whether to
     * cryptographically sign the exported data, which will make it possible to detect whether the LDIF data has been altered
     * since it was exported.
     */
    sign?: pulumi.Input<boolean>;
    /**
     * The length of time to sleep before the task completes.
     */
    sleepDuration?: pulumi.Input<string>;
    /**
     * The path to the directory containing the files to examine. The directory must exist.
     */
    targetDirectory?: pulumi.Input<string>;
    /**
     * The set of attribute values that should be included in the tasks that are scheduled from this Statically Defined
     * Recurring Task. Each value must be in the form {attribute-type}={value}, where {attribute-type} is the name or OID of an
     * attribute type that is defined in the schema and permitted with the configured set of object classes, and {value} is a
     * value to assign to an attribute with that type. A multivalued attribute can be created by providing multiple name-value
     * pairs with the same name and different values.
     */
    taskAttributeValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The final task state that a task instance should have if the task executes the specified command and that command
     * completes with a nonzero exit code, which generally means that the command did not complete successfully.
     */
    taskCompletionStateForNonzeroExitCode?: pulumi.Input<string>;
    /**
     * The fully-qualified name of the Java class that provides the logic for the task to be invoked.
     */
    taskJavaClass?: pulumi.Input<string>;
    /**
     * The names or OIDs of the object classes to include in the tasks that are scheduled from this Statically Defined
     * Recurring Task. All object classes must be defined in the server schema, and the combination of object classes must be
     * valid for a task entry.
     */
    taskObjectClasses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The return state to use if a timeout is encountered while waiting for the server work queue to become idle (if the
     * duration-to-wait-for-work-queue-idle property has a value), or if the time specified by the
     * duration-to-wait-for-search-to-return-entries elapses without the associated search returning any entries.
     */
    taskReturnStateIfTimeoutIsEncountered?: pulumi.Input<string>;
    /**
     * The format to use for the timestamp represented by the "${timestamp}" token in the filename pattern.
     */
    timestampFormat?: pulumi.Input<string>;
    /**
     * The type of Recurring Task resource. Options are ['generate-server-profile', 'leave-lockdown-mode', 'backup', 'delay',
     * 'statically-defined', 'collect-support-data', 'ldif-export', 'enter-lockdown-mode', 'audit-data-security', 'exec',
     * 'file-retention', 'third-party']
     */
    type?: pulumi.Input<string>;
    /**
     * Indicates whether to capture support data information sequentially rather than in parallel. Capturing data in sequential
     * mode may reduce the amount of memory that the tool requires to operate, at the cost of taking longer to run.
     */
    useSequentialMode?: pulumi.Input<boolean>;
    /**
     * The absolute path to a working directory where the command should be executed. It must be an absolute path and the
     * corresponding directory must exist.
     */
    workingDirectory?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DefaultRecurringTask resource.
 */
export interface DefaultRecurringTaskArgs {
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task fails
     * to complete successfully.
     */
    alertOnFailure?: pulumi.Input<boolean>;
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task starts
     * running.
     */
    alertOnStart?: pulumi.Input<boolean>;
    /**
     * Indicates whether the server should generate an administrative alert whenever an instance of this Recurring Task
     * completes successfully.
     */
    alertOnSuccess?: pulumi.Input<boolean>;
    /**
     * The backend ID for a backend to be exported.
     */
    backendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The set of backends that should be examined. If no backends are specified, then all backends that support this
     * functionality will be included.
     */
    backends?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The directory in which backup files will be placed. When backing up a single backend, the backup files will be placed
     * directly in this directory. When backing up multiple backends, the backup files for each backend will be placed in a
     * subdirectory whose name is the corresponding backend ID.
     */
    backupDirectory?: pulumi.Input<string>;
    /**
     * The base directory below which generated reports will be written. Each invocation of the audit-data-security task will
     * create a new subdirectory below this base directory whose name is a timestamp indicating when the report was generated.
     */
    baseOutputDirectory?: pulumi.Input<string>;
    /**
     * Indicates whether an instance of this Recurring Task should be canceled if the task immediately before it in the
     * recurring task chain fails to complete successfully (including if it is canceled by an administrator before it starts or
     * while it is running).
     */
    cancelOnTaskDependencyFailure?: pulumi.Input<boolean>;
    /**
     * A string containing the arguments to provide to the command. If the command should be run without arguments, this
     * property should be left undefined. If there should be multiple arguments, then they should be separated with spaces.
     */
    commandArguments?: pulumi.Input<string>;
    /**
     * The path and base name for a file to which the command output (both standard output and standard error) should be
     * written. This may be left undefined if the command output should not be recorded into a file.
     */
    commandOutputFileBaseName?: pulumi.Input<string>;
    /**
     * The absolute path to the command to execute. It must be an absolute path, the corresponding file must exist, and it must
     * be listed in the config/exec-command-whitelist.txt file.
     */
    commandPath?: pulumi.Input<string>;
    /**
     * An optional comment to include in a README file within the support data archive.
     */
    comment?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to compress the data as it is written into the
     * backup. - `ldif-export`: Indicates whether to compress the LDIF data as it is exported.
     */
    compress?: pulumi.Input<boolean>;
    /**
     * The set of data security auditors that should be invoked. If no auditors are specified, then all auditors defined in the
     * configuration will be used.
     */
    dataSecurityAuditors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A description for this Recurring Task
     */
    description?: pulumi.Input<string>;
    /**
     * The maximum length of time that the server will continue to perform internal searches using the criteria from the
     * ldap-url-for-search-expected-to-return-entries property.
     */
    durationToWaitForSearchToReturnEntries?: pulumi.Input<string>;
    /**
     * Indicates that task should wait for up to the specified length of time for the work queue to report that all worker
     * threads are idle and there are no pending operations. Note that this primarily monitors operations that use worker
     * threads, which does not include internal operations (for example, those invoked by extensions), and may not include
     * requests from non-LDAP clients (for example, HTTP-based clients).
     */
    durationToWaitForWorkQueueIdle?: pulumi.Input<string>;
    /**
     * The email addresses to which a message should be sent if an instance of this Recurring Task fails to complete
     * successfully. If this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    emailOnFailures?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The email addresses to which a message should be sent whenever an instance of this Recurring Task starts running. If
     * this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    emailOnStarts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The email addresses to which a message should be sent whenever an instance of this Recurring Task completes
     * successfully. If this option is used, then at least one smtp-server must be configured in the global configuration.
     */
    emailOnSuccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to encrypt the data as it is written into the backup.
     * - `ldif-export`: Indicates whether to encrypt the LDIF data as it exported.
     */
    encrypt?: pulumi.Input<boolean>;
    /**
     * The path to a file that contains the passphrase to encrypt the contents of the support data archive.
     */
    encryptionPassphraseFile?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: The ID of an encryption settings definition to use to obtain the backup
     * encryption key. - `ldif-export`: The ID of an encryption settings definition to use to obtain the LDIF export encryption
     * key.
     */
    encryptionSettingsDefinitionId?: pulumi.Input<string>;
    /**
     * The backend ID for a backend to be excluded from the export.
     */
    excludeBackendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The backend IDs of any backends that should be excluded from the backup. All backends that support backups and are not
     * listed will be included.
     */
    excludedBackendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The set of arguments used to customize the behavior for the Third Party Recurring Task. Each configuration property
     * should be given in the form 'name=value'.
     */
    extensionArguments?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The fully-qualified name of the Java class providing the logic for the Third Party Recurring Task.
     */
    extensionClass?: pulumi.Input<string>;
    /**
     * A pattern that specifies the names of the files to examine. The pattern may contain zero or more asterisks as wildcards,
     * where each wildcard matches zero or more characters. It may also contain at most one occurrence of the special string
     * "${timestamp}", which will match a timestamp with the format specified using the timestamp-format property. All other
     * characters in the pattern will be treated literally.
     */
    filenamePattern?: pulumi.Input<string>;
    /**
     * Indicates whether the support data archive should include binary files that may not have otherwise been included. Note
     * that it may not be possible to obscure or redact sensitive information in binary files.
     */
    includeBinaryFiles?: pulumi.Input<boolean>;
    /**
     * Indicates whether the support data archive should include information that may be expensive to obtain, and that may
     * temporarily affect the server's performance or responsiveness.
     */
    includeExpensiveData?: pulumi.Input<boolean>;
    /**
     * Indicates whether the support data archive should include the source code (if available) for any third-party extensions
     * that may be installed in the server.
     */
    includeExtensionSource?: pulumi.Input<boolean>;
    /**
     * A filter that will be used to identify entries that may be included in the generated report. If multiple filters are
     * specified, then any entry that matches at least one of the filters will be included. If no filters are specified, then
     * all entries will be included.
     */
    includeFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An optional set of additional paths to files within the instance root that should be included in the generated server
     * profile. All paths must be within the instance root, and relative paths will be relative to the instance root.
     */
    includePaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Indicates whether the support data archive should include a replication state dump, which may be several megabytes in
     * size.
     */
    includeReplicationStateDump?: pulumi.Input<boolean>;
    /**
     * The backend IDs of any backends that should be included in the backup.
     */
    includedBackendIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The number of times to invoke the jstack utility to obtain a stack trace of all threads running in the JVM. A value of
     * zero indicates that the jstack utility should not be invoked.
     */
    jstackCount?: pulumi.Input<number>;
    /**
     * An LDAP URL that provides the criteria for a search request that is expected to return at least one entry. The search
     * will be performed internally, and only the base DN, scope, and filter from the URL will be used; any host, port, or
     * requested attributes included in the URL will be ignored.
     */
    ldapUrlForSearchExpectedToReturnEntries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The directory in which LDIF export files will be placed. The directory must already exist.
     */
    ldifDirectory?: pulumi.Input<string>;
    /**
     * Indicates whether the command's output (both standard output and standard error) should be recorded in the server's
     * error log.
     */
    logCommandOutput?: pulumi.Input<boolean>;
    /**
     * The maximum age (leading up to the time the collect-support-data tool was invoked) for log content to include in the
     * support data archive.
     */
    logDuration?: pulumi.Input<string>;
    /**
     * The amount of data to collect from the beginning of each log file included in the support data archive.
     */
    logFileHeadCollectionSize?: pulumi.Input<string>;
    /**
     * The amount of data to collect from the end of each log file included in the support data archive.
     */
    logFileTailCollectionSize?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: The maximum rate, in megabytes per second, at which backups should be
     * written. - `ldif-export`: The maximum rate, in megabytes per second, at which LDIF exports should be written.
     */
    maxMegabytesPerSecond?: pulumi.Input<number>;
    /**
     * Name of this config object.
     */
    name?: pulumi.Input<string>;
    /**
     * The directory in which the support data archive files will be placed. The path must be a directory, and that directory
     * must already exist. Relative paths will be interpreted as relative to the server root.
     */
    outputDirectory?: pulumi.Input<string>;
    /**
     * Supported in PingDirectory product version 10.0.0.0+. An optional set of post-LDIF-export task processors that should be
     * invoked for the resulting LDIF export files.
     */
    postLdifExportTaskProcessors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The directory in which the generated server profiles will be placed. The files will be named with the pattern
     * "server-profile-{timestamp}.zip", where "{timestamp}" represents the time that the profile was generated.
     */
    profileDirectory?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `leave-lockdown-mode`: The reason that the server is being taken out of in
     * lockdown mode. - `enter-lockdown-mode`: The reason that the server is being placed in lockdown mode.
     */
    reason?: pulumi.Input<string>;
    /**
     * The number of intervals of data to collect from tools that use sample-based reporting, like vmstat, iostat, and mpstat.
     * A value of zero indicates that these kinds of tools should not be used to collect any information.
     */
    reportCount?: pulumi.Input<number>;
    /**
     * The duration (in seconds) between each interval of data to collect from tools that use sample-based reporting, like
     * vmstat, iostat, and mpstat.
     */
    reportIntervalSeconds?: pulumi.Input<number>;
    /**
     * The minimum aggregate size of files that will be retained. The size should be specified as an integer followed by a unit
     * that is one of "b" or "bytes", "kb" or "kilobytes", "mb" or "megabytes", "gb" or "gigabytes", or "tb" or "terabytes".
     * For example, a value of "1 gb" indicates that at least one gigabyte of files should be retained.
     */
    retainAggregateFileSize?: pulumi.Input<string>;
    /**
     * The minimum age of files matching the pattern that will be retained.
     */
    retainFileAge?: pulumi.Input<string>;
    /**
     * The minimum number of files matching the pattern that will be retained.
     */
    retainFileCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous full backups that should be preserved after a new backup completes successfully.
     */
    retainPreviousFullBackupAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous full backups that should be preserved after a new backup completes successfully.
     */
    retainPreviousFullBackupCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous LDIF exports that should be preserved after a new export completes successfully.
     */
    retainPreviousLdifExportAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous LDIF exports that should be preserved after a new export completes successfully.
     */
    retainPreviousLdifExportCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous command output files that should be preserved after a new instance of the command is
     * invoked.
     */
    retainPreviousOutputFileAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous command output files that should be preserved after a new instance of the command is
     * invoked.
     */
    retainPreviousOutputFileCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous server profile zip files that should be preserved after a new profile is generated.
     */
    retainPreviousProfileAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous server profile zip files that should be preserved after a new profile is generated.
     */
    retainPreviousProfileCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous reports that should be preserved after a new report completes successfully.
     */
    retainPreviousReportAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous reports that should be preserved after a new report is generated.
     */
    retainPreviousReportCount?: pulumi.Input<number>;
    /**
     * The minimum age of previous support data archives that should be preserved after a new archive is generated.
     */
    retainPreviousSupportDataArchiveAge?: pulumi.Input<string>;
    /**
     * The minimum number of previous support data archives that should be preserved after a new archive is generated.
     */
    retainPreviousSupportDataArchiveCount?: pulumi.Input<number>;
    /**
     * The length of time the server should sleep between searches performed using the criteria from the
     * ldap-url-for-search-expected-to-return-entries property.
     */
    searchInterval?: pulumi.Input<string>;
    /**
     * The length of time that the server will wait for a response to each internal search performed using the criteria from
     * the ldap-url-for-search-expected-to-return-entries property.
     */
    searchTimeLimit?: pulumi.Input<string>;
    /**
     * The security level to use when deciding which information to include in or exclude from the support data archive, and
     * which included data should be obscured or redacted.
     */
    securityLevel?: pulumi.Input<string>;
    /**
     * When the `type` attribute is set to: - `backup`: Indicates whether to cryptographically sign backups, which will make it
     * possible to detect whether the backup has been altered since it was created. - `ldif-export`: Indicates whether to
     * cryptographically sign the exported data, which will make it possible to detect whether the LDIF data has been altered
     * since it was exported.
     */
    sign?: pulumi.Input<boolean>;
    /**
     * The length of time to sleep before the task completes.
     */
    sleepDuration?: pulumi.Input<string>;
    /**
     * The path to the directory containing the files to examine. The directory must exist.
     */
    targetDirectory?: pulumi.Input<string>;
    /**
     * The set of attribute values that should be included in the tasks that are scheduled from this Statically Defined
     * Recurring Task. Each value must be in the form {attribute-type}={value}, where {attribute-type} is the name or OID of an
     * attribute type that is defined in the schema and permitted with the configured set of object classes, and {value} is a
     * value to assign to an attribute with that type. A multivalued attribute can be created by providing multiple name-value
     * pairs with the same name and different values.
     */
    taskAttributeValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The final task state that a task instance should have if the task executes the specified command and that command
     * completes with a nonzero exit code, which generally means that the command did not complete successfully.
     */
    taskCompletionStateForNonzeroExitCode?: pulumi.Input<string>;
    /**
     * The fully-qualified name of the Java class that provides the logic for the task to be invoked.
     */
    taskJavaClass?: pulumi.Input<string>;
    /**
     * The names or OIDs of the object classes to include in the tasks that are scheduled from this Statically Defined
     * Recurring Task. All object classes must be defined in the server schema, and the combination of object classes must be
     * valid for a task entry.
     */
    taskObjectClasses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The return state to use if a timeout is encountered while waiting for the server work queue to become idle (if the
     * duration-to-wait-for-work-queue-idle property has a value), or if the time specified by the
     * duration-to-wait-for-search-to-return-entries elapses without the associated search returning any entries.
     */
    taskReturnStateIfTimeoutIsEncountered?: pulumi.Input<string>;
    /**
     * The format to use for the timestamp represented by the "${timestamp}" token in the filename pattern.
     */
    timestampFormat?: pulumi.Input<string>;
    /**
     * Indicates whether to capture support data information sequentially rather than in parallel. Capturing data in sequential
     * mode may reduce the amount of memory that the tool requires to operate, at the cost of taking longer to run.
     */
    useSequentialMode?: pulumi.Input<boolean>;
    /**
     * The absolute path to a working directory where the command should be executed. It must be an absolute path and the
     * corresponding directory must exist.
     */
    workingDirectory?: pulumi.Input<string>;
}
